
/Users/rishubhanda/Desktop/MedLock_Dev/Firmware/Tests/target/1.4.0/photon/Tests.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00007b34  080a001c  080a001c  0001001c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .backup       000004b8  40024000  080a7b50  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000140  20000000  080a8008  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000600  20000140  20000140  00040140  2**2
                  ALLOC
  6 .module_info_suffix 00000028  080a8148  080a8148  00038148  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .module_info_crc 00000004  080a8170  080a8170  00038170  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_info   000b6e54  00000000  00000000  00038174  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00010ec6  00000000  00000000  000eefc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000149ae  00000000  00000000  000ffe8e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 000023b0  00000000  00000000  0011483c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000036f0  00000000  00000000  00116bec  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00026d55  00000000  00000000  0011a2dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00026ea0  00000000  00000000  00141031  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000aa394  00000000  00000000  00167ed1  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000c02c  00000000  00000000  00212268  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <link_dynalib_end+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <link_dynalib_end+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <link_dynalib_end+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f002 f8f1 	bl	80a2214 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <link_dynalib_end+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <link_dynalib_end+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f002 f8f6 	bl	80a222a <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <link_dynalib_end+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000000 	.word	0x20000000
 80a0048:	080a8008 	.word	0x080a8008
 80a004c:	20000140 	.word	0x20000140
 80a0050:	20000140 	.word	0x20000140
 80a0054:	20000740 	.word	0x20000740
 80a0058:	20000740 	.word	0x20000740

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f001 fe6d 	bl	80a1d3c <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a7b08 	.word	0x080a7b08
 80a0084:	080a7b44 	.word	0x080a7b44

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 bbbe 	b.w	80a0808 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 fb63 	bl	80a0758 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f001 be13 	b.w	80a1cc0 <_post_loop>

080a009a <_Znwj>:
 80a009a:	f000 bdf3 	b.w	80a0c84 <malloc>

080a009e <_ZdlPv>:
 80a009e:	f000 bdf9 	b.w	80a0c94 <free>

080a00a2 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00a2:	7800      	ldrb	r0, [r0, #0]
 80a00a4:	fab0 f080 	clz	r0, r0
 80a00a8:	0940      	lsrs	r0, r0, #5
 80a00aa:	4770      	bx	lr

080a00ac <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00ac:	2301      	movs	r3, #1
 80a00ae:	7003      	strb	r3, [r0, #0]
 80a00b0:	4770      	bx	lr
	...

080a00b4 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_>:
     { "/rsa-utils/prng4.js", "application/javascript", prng4_js },
     { nullptr }
};

void myPage(const char* url, ResponseCallback* cb, void* cbArg, Reader* body, Writer* result, void* reserved)
{
 80a00b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a00b8:	4607      	mov	r7, r0
 80a00ba:	b085      	sub	sp, #20
 80a00bc:	460c      	mov	r4, r1
 80a00be:	4615      	mov	r5, r2
    Serial.printlnf("handling page %s", url);
 80a00c0:	f001 fc92 	bl	80a19e8 <_Z16_fetch_usbserialv>
    }

    template <typename... Args>
    inline size_t printlnf(const char* format, Args... args)
    {
        return this->printf_impl(true, format, args...);
 80a00c4:	463b      	mov	r3, r7
 80a00c6:	4a28      	ldr	r2, [pc, #160]	; (80a0168 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xb4>)
 80a00c8:	2101      	movs	r1, #1
 80a00ca:	f000 ffcc 	bl	80a1066 <_ZN5Print11printf_implEbPKcz>

    if (strcmp(url,"/index")==0) {
 80a00ce:	4927      	ldr	r1, [pc, #156]	; (80a016c <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xb8>)
 80a00d0:	4638      	mov	r0, r7
 80a00d2:	f002 f8db 	bl	80a228c <strcmp>
 80a00d6:	4606      	mov	r6, r0
 80a00d8:	b988      	cbnz	r0, 80a00fe <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0x4a>
        Serial.println("sending redirect");
 80a00da:	f001 fc85 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a00de:	4924      	ldr	r1, [pc, #144]	; (80a0170 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xbc>)
 80a00e0:	f000 ff55 	bl	80a0f8e <_ZN5Print7printlnEPKc>

    struct __attribute__((packed)) Header {
    		uint16_t size;
    		const char* header_list;		// when non-null, a series of headers. Each header MUST be terminated by CRLF.

    		Header(const char* headers) : size(sizeof(*this)), header_list(headers) {}
 80a00e4:	2306      	movs	r3, #6
 80a00e6:	f8ad 3008 	strh.w	r3, [sp, #8]
 80a00ea:	4b22      	ldr	r3, [pc, #136]	; (80a0174 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xc0>)
        Header h("Location: /index.html\r\n");
        cb(cbArg, 0, 301, "text/plain", &h);
 80a00ec:	f240 122d 	movw	r2, #301	; 0x12d
 80a00f0:	f8cd 300a 	str.w	r3, [sp, #10]
 80a00f4:	ab02      	add	r3, sp, #8
 80a00f6:	9300      	str	r3, [sp, #0]
 80a00f8:	4631      	mov	r1, r6
 80a00fa:	4b1f      	ldr	r3, [pc, #124]	; (80a0178 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xc4>)
 80a00fc:	e01c      	b.n	80a0138 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0x84>
    }

    int8_t idx = 0;
    for (;;idx++) {
        Page& p = myPages[idx];
        if (!p.url) {
 80a00fe:	f8df b07c 	ldr.w	fp, [pc, #124]	; 80a017c <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xc8>
 80a0102:	2600      	movs	r6, #0
 80a0104:	f04f 080c 	mov.w	r8, #12
 80a0108:	fa4f fa86 	sxtb.w	sl, r6
 80a010c:	fb08 f20a 	mul.w	r2, r8, sl
 80a0110:	f85b 1002 	ldr.w	r1, [fp, r2]
 80a0114:	eb0b 0902 	add.w	r9, fp, r2
 80a0118:	b149      	cbz	r1, 80a012e <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0x7a>
            idx = -1;
            break;
        }
        else if (strcmp(url, p.url)==0) {
 80a011a:	4638      	mov	r0, r7
 80a011c:	f002 f8b6 	bl	80a228c <strcmp>
 80a0120:	3601      	adds	r6, #1
 80a0122:	4601      	mov	r1, r0
 80a0124:	2800      	cmp	r0, #0
 80a0126:	d1ef      	bne.n	80a0108 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0x54>
            break;
        }
    }

    if (idx==-1) {
 80a0128:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 80a012c:	d107      	bne.n	80a013e <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0x8a>
        cb(cbArg, 0, 404, nullptr, nullptr);
 80a012e:	2300      	movs	r3, #0
 80a0130:	4619      	mov	r1, r3
 80a0132:	9300      	str	r3, [sp, #0]
 80a0134:	f44f 72ca 	mov.w	r2, #404	; 0x194
 80a0138:	4628      	mov	r0, r5
 80a013a:	47a0      	blx	r4
 80a013c:	e010      	b.n	80a0160 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xac>
    }
    else {
        cb(cbArg, 0, 200, myPages[idx].mime_type, nullptr);
 80a013e:	9000      	str	r0, [sp, #0]
 80a0140:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80a0144:	22c8      	movs	r2, #200	; 0xc8
 80a0146:	4628      	mov	r0, r5
 80a0148:	47a0      	blx	r4
        result->write(myPages[idx].data);
 80a014a:	f8d9 4008 	ldr.w	r4, [r9, #8]
        inline void write(const uint8_t* buf, size_t length) {
            callback(this, buf, length);
        }

        inline void write(const char* s) {
            write((const uint8_t*)s, strlen(s));
 80a014e:	4620      	mov	r0, r4
 80a0150:	f002 f8ae 	bl	80a22b0 <strlen>

        callback_t callback;
        void* state;

        inline void write(const uint8_t* buf, size_t length) {
            callback(this, buf, length);
 80a0154:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80a0156:	4602      	mov	r2, r0
 80a0158:	681b      	ldr	r3, [r3, #0]
 80a015a:	4621      	mov	r1, r4
 80a015c:	980e      	ldr	r0, [sp, #56]	; 0x38
 80a015e:	4798      	blx	r3
    }
}
 80a0160:	b005      	add	sp, #20
 80a0162:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a0166:	bf00      	nop
 80a0168:	080a4063 	.word	0x080a4063
 80a016c:	080a4074 	.word	0x080a4074
 80a0170:	080a407b 	.word	0x080a407b
 80a0174:	080a408c 	.word	0x080a408c
 80a0178:	080a40a4 	.word	0x080a40a4
 80a017c:	20000000 	.word	0x20000000

080a0180 <_Z13setUpInternetv>:

void setUpInternet() {
    softap_set_application_page_handler(myPage, nullptr); 
 80a0180:	2100      	movs	r1, #0
 80a0182:	4801      	ldr	r0, [pc, #4]	; (80a0188 <_Z13setUpInternetv+0x8>)
 80a0184:	f000 bcf2 	b.w	80a0b6c <softap_set_application_page_handler>
 80a0188:	080a00b5 	.word	0x080a00b5

080a018c <_GLOBAL__sub_I_myPages>:
inline int32_t pinReadFast(pin_t _pin)
{
    return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a018c:	f000 bbb4 	b.w	80a08f8 <HAL_Pin_Map>

080a0190 <_ZN9TCPClientD1Ev>:
class TCPClient : public Client {

public:
    TCPClient();
    TCPClient(sock_handle_t sock);
    virtual ~TCPClient() {};
 80a0190:	b538      	push	{r3, r4, r5, lr}
 80a0192:	4b0b      	ldr	r3, [pc, #44]	; (80a01c0 <_ZN9TCPClientD1Ev+0x30>)
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a0194:	6984      	ldr	r4, [r0, #24]
 80a0196:	4605      	mov	r5, r0
 80a0198:	6003      	str	r3, [r0, #0]
 80a019a:	b17c      	cbz	r4, 80a01bc <_ZN9TCPClientD1Ev+0x2c>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a019c:	6863      	ldr	r3, [r4, #4]
 80a019e:	3b01      	subs	r3, #1
 80a01a0:	6063      	str	r3, [r4, #4]
 80a01a2:	b95b      	cbnz	r3, 80a01bc <_ZN9TCPClientD1Ev+0x2c>
        {
          _M_dispose();
 80a01a4:	6823      	ldr	r3, [r4, #0]
 80a01a6:	4620      	mov	r0, r4
 80a01a8:	689b      	ldr	r3, [r3, #8]
 80a01aa:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a01ac:	68a3      	ldr	r3, [r4, #8]
 80a01ae:	3b01      	subs	r3, #1
 80a01b0:	60a3      	str	r3, [r4, #8]
 80a01b2:	b91b      	cbnz	r3, 80a01bc <_ZN9TCPClientD1Ev+0x2c>
            _M_destroy();
 80a01b4:	6823      	ldr	r3, [r4, #0]
 80a01b6:	4620      	mov	r0, r4
 80a01b8:	68db      	ldr	r3, [r3, #12]
 80a01ba:	4798      	blx	r3
 80a01bc:	4628      	mov	r0, r5
 80a01be:	bd38      	pop	{r3, r4, r5, pc}
 80a01c0:	080a7988 	.word	0x080a7988

080a01c4 <_ZN9TCPClientD0Ev>:
 80a01c4:	b510      	push	{r4, lr}
 80a01c6:	4604      	mov	r4, r0
 80a01c8:	f7ff ffe2 	bl	80a0190 <_ZN9TCPClientD1Ev>
 80a01cc:	4620      	mov	r0, r4
 80a01ce:	211c      	movs	r1, #28
 80a01d0:	f001 feb3 	bl	80a1f3a <_ZdlPvj>
 80a01d4:	4620      	mov	r0, r4
 80a01d6:	bd10      	pop	{r4, pc}

080a01d8 <_Z12print_eventsv>:
    events_encoded[events_counter] = value; 
    events_counter++; 
    print_events(); 
} 

void print_events() {
 80a01d8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    Serial.print("SRAM: [ "); 
 80a01da:	f001 fc05 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a01de:	4925      	ldr	r1, [pc, #148]	; (80a0274 <_Z12print_eventsv+0x9c>)
 80a01e0:	f000 fec2 	bl	80a0f68 <_ZN5Print5printEPKc>
    for(int i = 0; i < events_counter; i++) {
 80a01e4:	4d24      	ldr	r5, [pc, #144]	; (80a0278 <_Z12print_eventsv+0xa0>)
 80a01e6:	2400      	movs	r4, #0
        Serial.print(events_encoded[i]); 
 80a01e8:	1d2e      	adds	r6, r5, #4
    print_events(); 
} 

void print_events() {
    Serial.print("SRAM: [ "); 
    for(int i = 0; i < events_counter; i++) {
 80a01ea:	682b      	ldr	r3, [r5, #0]
 80a01ec:	429c      	cmp	r4, r3
 80a01ee:	da0d      	bge.n	80a020c <_Z12print_eventsv+0x34>
        Serial.print(events_encoded[i]); 
 80a01f0:	f001 fbfa 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a01f4:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
 80a01f8:	220a      	movs	r2, #10
 80a01fa:	f000 fef1 	bl	80a0fe0 <_ZN5Print5printEmi>
        Serial.print(", "); 
 80a01fe:	f001 fbf3 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a0202:	491e      	ldr	r1, [pc, #120]	; (80a027c <_Z12print_eventsv+0xa4>)
 80a0204:	f000 feb0 	bl	80a0f68 <_ZN5Print5printEPKc>
    print_events(); 
} 

void print_events() {
    Serial.print("SRAM: [ "); 
    for(int i = 0; i < events_counter; i++) {
 80a0208:	3401      	adds	r4, #1
 80a020a:	e7ee      	b.n	80a01ea <_Z12print_eventsv+0x12>
        Serial.print(events_encoded[i]); 
        Serial.print(", "); 
    } 
    Serial.println("]. "); 
 80a020c:	f001 fbec 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a0210:	491b      	ldr	r1, [pc, #108]	; (80a0280 <_Z12print_eventsv+0xa8>)
 80a0212:	f000 febc 	bl	80a0f8e <_ZN5Print7printlnEPKc>

    unsigned long curr_address; 
    EEPROM.get(0, curr_address); 
 80a0216:	f001 fe1d 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
    uint16_t length()                    { return HAL_EEPROM_Length(); }

    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template <typename T> T &get( int idx, T &t )
    {
        HAL_EEPROM_Get(idx, &t, sizeof(T));
 80a021a:	2204      	movs	r2, #4
 80a021c:	4669      	mov	r1, sp
 80a021e:	2000      	movs	r0, #0
 80a0220:	f000 fb52 	bl	80a08c8 <HAL_EEPROM_Get>
    if(curr_address != -1) {
 80a0224:	9b00      	ldr	r3, [sp, #0]
 80a0226:	3301      	adds	r3, #1
 80a0228:	d022      	beq.n	80a0270 <_Z12print_eventsv+0x98>
        Serial.print("EEPROM: [ "); 
 80a022a:	f001 fbdd 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a022e:	4915      	ldr	r1, [pc, #84]	; (80a0284 <_Z12print_eventsv+0xac>)
 80a0230:	f000 fe9a 	bl	80a0f68 <_ZN5Print5printEPKc>
        for(unsigned int i = 0; i < curr_address; i += 8) { 
 80a0234:	2400      	movs	r4, #0
 80a0236:	9b00      	ldr	r3, [sp, #0]
 80a0238:	429c      	cmp	r4, r3
 80a023a:	d214      	bcs.n	80a0266 <_Z12print_eventsv+0x8e>
            long value; 
            EEPROM.get(i, value); 
 80a023c:	f001 fe0a 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
 80a0240:	2204      	movs	r2, #4
 80a0242:	eb0d 0102 	add.w	r1, sp, r2
 80a0246:	4620      	mov	r0, r4
 80a0248:	f000 fb3e 	bl	80a08c8 <HAL_EEPROM_Get>
            Serial.print(value); 
 80a024c:	f001 fbcc 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a0250:	220a      	movs	r2, #10
 80a0252:	9901      	ldr	r1, [sp, #4]
 80a0254:	f000 fedb 	bl	80a100e <_ZN5Print5printEli>
            Serial.print(", "); 
 80a0258:	f001 fbc6 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a025c:	4907      	ldr	r1, [pc, #28]	; (80a027c <_Z12print_eventsv+0xa4>)
 80a025e:	f000 fe83 	bl	80a0f68 <_ZN5Print5printEPKc>

    unsigned long curr_address; 
    EEPROM.get(0, curr_address); 
    if(curr_address != -1) {
        Serial.print("EEPROM: [ "); 
        for(unsigned int i = 0; i < curr_address; i += 8) { 
 80a0262:	3408      	adds	r4, #8
 80a0264:	e7e7      	b.n	80a0236 <_Z12print_eventsv+0x5e>
            long value; 
            EEPROM.get(i, value); 
            Serial.print(value); 
            Serial.print(", "); 
        } 
        Serial.println("]. "); 
 80a0266:	f001 fbbf 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a026a:	4905      	ldr	r1, [pc, #20]	; (80a0280 <_Z12print_eventsv+0xa8>)
 80a026c:	f000 fe8f 	bl	80a0f8e <_ZN5Print7printlnEPKc>


    }

} 
 80a0270:	b002      	add	sp, #8
 80a0272:	bd70      	pop	{r4, r5, r6, pc}
 80a0274:	080a76c9 	.word	0x080a76c9
 80a0278:	40024000 	.word	0x40024000
 80a027c:	080a7738 	.word	0x080a7738
 80a0280:	080a76d2 	.word	0x080a76d2
 80a0284:	080a76d6 	.word	0x080a76d6

080a0288 <_Z10store_dataim>:

    // Develop mechanism to check if the POST Request was successful 
} 


void store_data(int id, unsigned long value) {
 80a0288:	b530      	push	{r4, r5, lr}
    unsigned long encoded_value = encoded(value, id); 
    
    if(events_counter < EVENTS_LIMIT) { 
 80a028a:	4a23      	ldr	r2, [pc, #140]	; (80a0318 <_Z10store_dataim+0x90>)

} 

unsigned long encoded(unsigned long value, int code) { 
    long mask = ~0u << 4; 
    value &= mask;
 80a028c:	f021 010f 	bic.w	r1, r1, #15


void store_data(int id, unsigned long value) {
    unsigned long encoded_value = encoded(value, id); 
    
    if(events_counter < EVENTS_LIMIT) { 
 80a0290:	6813      	ldr	r3, [r2, #0]

    // Develop mechanism to check if the POST Request was successful 
} 


void store_data(int id, unsigned long value) {
 80a0292:	b085      	sub	sp, #20
    unsigned long encoded_value = encoded(value, id); 
    
    if(events_counter < EVENTS_LIMIT) { 
 80a0294:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
} 

unsigned long encoded(unsigned long value, int code) { 
    long mask = ~0u << 4; 
    value &= mask;
    value |= code; 
 80a0298:	ea41 0100 	orr.w	r1, r1, r0

    // Develop mechanism to check if the POST Request was successful 
} 


void store_data(int id, unsigned long value) {
 80a029c:	4604      	mov	r4, r0
    unsigned long encoded_value = encoded(value, id); 
    
    if(events_counter < EVENTS_LIMIT) { 
        events_encoded[events_counter] = encoded_value; 
 80a029e:	bfbf      	itttt	lt
 80a02a0:	eb02 0083 	addlt.w	r0, r2, r3, lsl #2
        events_counter++; 
 80a02a4:	3301      	addlt	r3, #1
 80a02a6:	6013      	strlt	r3, [r2, #0]

void store_data(int id, unsigned long value) {
    unsigned long encoded_value = encoded(value, id); 
    
    if(events_counter < EVENTS_LIMIT) { 
        events_encoded[events_counter] = encoded_value; 
 80a02a8:	6041      	strlt	r1, [r0, #4]
    // Develop mechanism to check if the POST Request was successful 
} 


void store_data(int id, unsigned long value) {
    unsigned long encoded_value = encoded(value, id); 
 80a02aa:	9101      	str	r1, [sp, #4]
        events_encoded[events_counter] = encoded_value; 
        events_counter++; 
    } 
    
    unsigned long curr_address; 
    EEPROM.get(0, curr_address); 
 80a02ac:	f001 fdd2 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
 80a02b0:	2204      	movs	r2, #4
 80a02b2:	a902      	add	r1, sp, #8
 80a02b4:	2000      	movs	r0, #0
 80a02b6:	f000 fb07 	bl	80a08c8 <HAL_EEPROM_Get>
    if(curr_address == -1) {
 80a02ba:	9b02      	ldr	r3, [sp, #8]
 80a02bc:	3301      	adds	r3, #1
 80a02be:	d10a      	bne.n	80a02d6 <_Z10store_dataim+0x4e>
        EEPROM.put(0, 8ul); 
 80a02c0:	f001 fdc8 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
 80a02c4:	2508      	movs	r5, #8
 80a02c6:	a904      	add	r1, sp, #16
 80a02c8:	f841 5d04 	str.w	r5, [r1, #-4]!
        return t;
    }

    template <typename T> const T &put( int idx, const T &t )
    {
        HAL_EEPROM_Put(idx, &t, sizeof(T));
 80a02cc:	2204      	movs	r2, #4
 80a02ce:	2000      	movs	r0, #0
 80a02d0:	f000 fb02 	bl	80a08d8 <HAL_EEPROM_Put>
        curr_address = 8; 
 80a02d4:	9502      	str	r5, [sp, #8]
    }
    
    if(( id == btn1_id || 
 80a02d6:	f024 0404 	bic.w	r4, r4, #4
 80a02da:	2c02      	cmp	r4, #2
 80a02dc:	d817      	bhi.n	80a030e <_Z10store_dataim+0x86>
            id == btn2_id || 
            id == btn3_id || 
            id == col_off_id || 
            id == dispense_id || 
            id == curr_time_id ) && 
        curr_address < EEPROM_LENGTH - 8) {
 80a02de:	4b0f      	ldr	r3, [pc, #60]	; (80a031c <_Z10store_dataim+0x94>)
    if(( id == btn1_id || 
            id == btn2_id || 
            id == btn3_id || 
            id == col_off_id || 
            id == dispense_id || 
            id == curr_time_id ) && 
 80a02e0:	9a02      	ldr	r2, [sp, #8]
 80a02e2:	681b      	ldr	r3, [r3, #0]
 80a02e4:	3b08      	subs	r3, #8
 80a02e6:	4293      	cmp	r3, r2
 80a02e8:	d911      	bls.n	80a030e <_Z10store_dataim+0x86>
        curr_address < EEPROM_LENGTH - 8) {
        EEPROM.put(curr_address, encoded_value); 
 80a02ea:	f001 fdb3 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
 80a02ee:	2204      	movs	r2, #4
 80a02f0:	eb0d 0102 	add.w	r1, sp, r2
 80a02f4:	9802      	ldr	r0, [sp, #8]
 80a02f6:	f000 faef 	bl	80a08d8 <HAL_EEPROM_Put>
        curr_address += 8; 
 80a02fa:	9b02      	ldr	r3, [sp, #8]
 80a02fc:	3308      	adds	r3, #8
 80a02fe:	9302      	str	r3, [sp, #8]
        EEPROM.put(0, curr_address); 
 80a0300:	f001 fda8 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
 80a0304:	2204      	movs	r2, #4
 80a0306:	a902      	add	r1, sp, #8
 80a0308:	2000      	movs	r0, #0
 80a030a:	f000 fae5 	bl	80a08d8 <HAL_EEPROM_Put>
    } 

    print_events(); 
 80a030e:	f7ff ff63 	bl	80a01d8 <_Z12print_eventsv>
}
 80a0312:	b005      	add	sp, #20
 80a0314:	bd30      	pop	{r4, r5, pc}
 80a0316:	bf00      	nop
 80a0318:	40024000 	.word	0x40024000
 80a031c:	20000160 	.word	0x20000160

080a0320 <_Z11decode_namem>:

String decode_name(unsigned long value) {
    long mask = 0xF; 
    unsigned int code = value & mask; 

    switch(code) {
 80a0320:	f001 010f 	and.w	r1, r1, #15
    value |= code; 
    
    return value; 	
} 

String decode_name(unsigned long value) {
 80a0324:	b510      	push	{r4, lr}
 80a0326:	4604      	mov	r4, r0
    long mask = 0xF; 
    unsigned int code = value & mask; 

    switch(code) {
 80a0328:	2906      	cmp	r1, #6
 80a032a:	d813      	bhi.n	80a0354 <_Z11decode_namem+0x34>
 80a032c:	e8df f001 	tbb	[pc, r1]
 80a0330:	0a080604 	.word	0x0a080604
 80a0334:	0e0c      	.short	0x0e0c
 80a0336:	10          	.byte	0x10
 80a0337:	00          	.byte	0x00
        case btn1_id: 
            return "Button 1"; 
 80a0338:	4909      	ldr	r1, [pc, #36]	; (80a0360 <_Z11decode_namem+0x40>)
 80a033a:	e00c      	b.n	80a0356 <_Z11decode_namem+0x36>
            break; 
        case btn2_id: 
            return "Button 2"; 
 80a033c:	4909      	ldr	r1, [pc, #36]	; (80a0364 <_Z11decode_namem+0x44>)
 80a033e:	e00a      	b.n	80a0356 <_Z11decode_namem+0x36>
            break; 
        case btn3_id: 
            return "Button 3"; 
 80a0340:	4909      	ldr	r1, [pc, #36]	; (80a0368 <_Z11decode_namem+0x48>)
 80a0342:	e008      	b.n	80a0356 <_Z11decode_namem+0x36>
            break; 
        case cap_turn_id: 
            return "Cap Turn"; 
 80a0344:	4909      	ldr	r1, [pc, #36]	; (80a036c <_Z11decode_namem+0x4c>)
 80a0346:	e006      	b.n	80a0356 <_Z11decode_namem+0x36>
            break; 
        case col_off_id: 
            return "Col Off"; 
 80a0348:	4909      	ldr	r1, [pc, #36]	; (80a0370 <_Z11decode_namem+0x50>)
 80a034a:	e004      	b.n	80a0356 <_Z11decode_namem+0x36>
            break; 
        case dispense_id: 
            return "Dispense"; 
 80a034c:	4909      	ldr	r1, [pc, #36]	; (80a0374 <_Z11decode_namem+0x54>)
 80a034e:	e002      	b.n	80a0356 <_Z11decode_namem+0x36>
            break; 
        case curr_time_id: 
            return "Curr Time"; 
 80a0350:	4909      	ldr	r1, [pc, #36]	; (80a0378 <_Z11decode_namem+0x58>)
 80a0352:	e000      	b.n	80a0356 <_Z11decode_namem+0x36>
            break; 
        default: 
            return "Default"; 
 80a0354:	4909      	ldr	r1, [pc, #36]	; (80a037c <_Z11decode_namem+0x5c>)
 80a0356:	4620      	mov	r0, r4
 80a0358:	f000 ff3a 	bl	80a11d0 <_ZN6StringC1EPK19__FlashStringHelper>
            break;
    }

}
 80a035c:	4620      	mov	r0, r4
 80a035e:	bd10      	pop	{r4, pc}
 80a0360:	080a76e1 	.word	0x080a76e1
 80a0364:	080a76ea 	.word	0x080a76ea
 80a0368:	080a76f3 	.word	0x080a76f3
 80a036c:	080a76fc 	.word	0x080a76fc
 80a0370:	080a7705 	.word	0x080a7705
 80a0374:	080a770d 	.word	0x080a770d
 80a0378:	080a7716 	.word	0x080a7716
 80a037c:	080a7720 	.word	0x080a7720

080a0380 <_Z11format_jsonv>:

String format_json() {
 80a0380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a0384:	4604      	mov	r4, r0
 80a0386:	b08a      	sub	sp, #40	; 0x28

    unsigned long curr_address; 
    EEPROM.get(0, curr_address); 
 80a0388:	f001 fd64 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
    uint16_t length()                    { return HAL_EEPROM_Length(); }

    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template <typename T> T &get( int idx, T &t )
    {
        HAL_EEPROM_Get(idx, &t, sizeof(T));
 80a038c:	2204      	movs	r2, #4
 80a038e:	4669      	mov	r1, sp
 80a0390:	2000      	movs	r0, #0
 80a0392:	f000 fa99 	bl	80a08c8 <HAL_EEPROM_Get>

    String res = "[ "; 
 80a0396:	495d      	ldr	r1, [pc, #372]	; (80a050c <_Z11format_jsonv+0x18c>)
 80a0398:	4620      	mov	r0, r4
 80a039a:	f000 ff19 	bl	80a11d0 <_ZN6StringC1EPK19__FlashStringHelper>

    // Check to return SRAM or EEPROM memory 
    if(events_counter >= (curr_address / 8) - 1) {
 80a039e:	4e5c      	ldr	r6, [pc, #368]	; (80a0510 <_Z11format_jsonv+0x190>)
 80a03a0:	9a00      	ldr	r2, [sp, #0]
 80a03a2:	6831      	ldr	r1, [r6, #0]
 80a03a4:	08d3      	lsrs	r3, r2, #3
 80a03a6:	3b01      	subs	r3, #1
 80a03a8:	428b      	cmp	r3, r1
 80a03aa:	d84e      	bhi.n	80a044a <_Z11format_jsonv+0xca>
        // Print SRAM: 

        for(int i = 0; i < events_counter; i++) { 
 80a03ac:	46b0      	mov	r8, r6
 80a03ae:	2500      	movs	r5, #0
 80a03b0:	6833      	ldr	r3, [r6, #0]
 80a03b2:	429d      	cmp	r5, r3
 80a03b4:	f280 80a1 	bge.w	80a04fa <_Z11format_jsonv+0x17a>
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
 80a03b8:	4956      	ldr	r1, [pc, #344]	; (80a0514 <_Z11format_jsonv+0x194>)
            res += " { \"name\": "; 
            res += " \"" + decode_name(events_encoded[i]) + "\", "; 
 80a03ba:	4f57      	ldr	r7, [pc, #348]	; (80a0518 <_Z11format_jsonv+0x198>)
 80a03bc:	4620      	mov	r0, r4
 80a03be:	f000 ff6d 	bl	80a129c <_ZN6String6concatEPKc>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a03c2:	4956      	ldr	r1, [pc, #344]	; (80a051c <_Z11format_jsonv+0x19c>)
 80a03c4:	a806      	add	r0, sp, #24
 80a03c6:	f000 ff03 	bl	80a11d0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a03ca:	f857 1025 	ldr.w	r1, [r7, r5, lsl #2]
 80a03ce:	a802      	add	r0, sp, #8
 80a03d0:	f7ff ffa6 	bl	80a0320 <_Z11decode_namem>
 80a03d4:	a902      	add	r1, sp, #8
 80a03d6:	a806      	add	r0, sp, #24
 80a03d8:	f000 ff6f 	bl	80a12ba <_ZplRK15StringSumHelperRK6String>
 80a03dc:	4950      	ldr	r1, [pc, #320]	; (80a0520 <_Z11format_jsonv+0x1a0>)
 80a03de:	f000 ff78 	bl	80a12d2 <_ZplRK15StringSumHelperPKc>
	unsigned char concat(float num);
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
 80a03e2:	4601      	mov	r1, r0
 80a03e4:	4620      	mov	r0, r4
 80a03e6:	f000 ff55 	bl	80a1294 <_ZN6String6concatERKS_>
 80a03ea:	a802      	add	r0, sp, #8
 80a03ec:	f000 fea9 	bl	80a1142 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a03f0:	a806      	add	r0, sp, #24
 80a03f2:	f000 fea6 	bl	80a1142 <_ZN6StringD1Ev>
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
 80a03f6:	494b      	ldr	r1, [pc, #300]	; (80a0524 <_Z11format_jsonv+0x1a4>)
 80a03f8:	4620      	mov	r0, r4
 80a03fa:	f000 ff4f 	bl	80a129c <_ZN6String6concatEPKc>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a03fe:	494a      	ldr	r1, [pc, #296]	; (80a0528 <_Z11format_jsonv+0x1a8>)
 80a0400:	a806      	add	r0, sp, #24
 80a0402:	f000 fee5 	bl	80a11d0 <_ZN6StringC1EPK19__FlashStringHelper>
            res += " \"value\": "; 
            res += "" + String(events_encoded[i]) + " }"; 
 80a0406:	220a      	movs	r2, #10
 80a0408:	f857 1025 	ldr.w	r1, [r7, r5, lsl #2]
 80a040c:	a802      	add	r0, sp, #8
 80a040e:	f000 ff16 	bl	80a123e <_ZN6StringC1Emh>
 80a0412:	a902      	add	r1, sp, #8
 80a0414:	a806      	add	r0, sp, #24
 80a0416:	f000 ff50 	bl	80a12ba <_ZplRK15StringSumHelperRK6String>
 80a041a:	4944      	ldr	r1, [pc, #272]	; (80a052c <_Z11format_jsonv+0x1ac>)
 80a041c:	f000 ff59 	bl	80a12d2 <_ZplRK15StringSumHelperPKc>
	unsigned char concat(float num);
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
 80a0420:	4601      	mov	r1, r0
 80a0422:	4620      	mov	r0, r4
 80a0424:	f000 ff36 	bl	80a1294 <_ZN6String6concatERKS_>
 80a0428:	a802      	add	r0, sp, #8
 80a042a:	f000 fe8a 	bl	80a1142 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a042e:	a806      	add	r0, sp, #24
 80a0430:	f000 fe87 	bl	80a1142 <_ZN6StringD1Ev>
            
            if(i < events_counter - 1) {
 80a0434:	f8d8 3000 	ldr.w	r3, [r8]
 80a0438:	3b01      	subs	r3, #1
 80a043a:	429d      	cmp	r5, r3
 80a043c:	da03      	bge.n	80a0446 <_Z11format_jsonv+0xc6>
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
 80a043e:	493c      	ldr	r1, [pc, #240]	; (80a0530 <_Z11format_jsonv+0x1b0>)
 80a0440:	4620      	mov	r0, r4
 80a0442:	f000 ff2b 	bl	80a129c <_ZN6String6concatEPKc>

    // Check to return SRAM or EEPROM memory 
    if(events_counter >= (curr_address / 8) - 1) {
        // Print SRAM: 

        for(int i = 0; i < events_counter; i++) { 
 80a0446:	3501      	adds	r5, #1
 80a0448:	e7b2      	b.n	80a03b0 <_Z11format_jsonv+0x30>
            }
        } 

    } else {
        // Print EEPROM: 
        if(curr_address != -1) {
 80a044a:	3201      	adds	r2, #1
 80a044c:	d055      	beq.n	80a04fa <_Z11format_jsonv+0x17a>
 80a044e:	2508      	movs	r5, #8
            for(unsigned int i = 8; i < curr_address; i += 8) { 
 80a0450:	9b00      	ldr	r3, [sp, #0]
 80a0452:	429d      	cmp	r5, r3
 80a0454:	d24c      	bcs.n	80a04f0 <_Z11format_jsonv+0x170>
                long value; 
                EEPROM.get(i, value); 
 80a0456:	f001 fcfd 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
 80a045a:	2204      	movs	r2, #4
 80a045c:	eb0d 0102 	add.w	r1, sp, r2
 80a0460:	4628      	mov	r0, r5
 80a0462:	f000 fa31 	bl	80a08c8 <HAL_EEPROM_Get>
 80a0466:	492b      	ldr	r1, [pc, #172]	; (80a0514 <_Z11format_jsonv+0x194>)
 80a0468:	4620      	mov	r0, r4
 80a046a:	f000 ff17 	bl	80a129c <_ZN6String6concatEPKc>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a046e:	492b      	ldr	r1, [pc, #172]	; (80a051c <_Z11format_jsonv+0x19c>)
 80a0470:	a806      	add	r0, sp, #24
 80a0472:	f000 fead 	bl	80a11d0 <_ZN6StringC1EPK19__FlashStringHelper>

                res += " { \"name\": "; 
                res += " \"" + decode_name(value) + "\", "; 
 80a0476:	9901      	ldr	r1, [sp, #4]
 80a0478:	a802      	add	r0, sp, #8
 80a047a:	f7ff ff51 	bl	80a0320 <_Z11decode_namem>
 80a047e:	a902      	add	r1, sp, #8
 80a0480:	a806      	add	r0, sp, #24
 80a0482:	f000 ff1a 	bl	80a12ba <_ZplRK15StringSumHelperRK6String>
 80a0486:	4926      	ldr	r1, [pc, #152]	; (80a0520 <_Z11format_jsonv+0x1a0>)
 80a0488:	f000 ff23 	bl	80a12d2 <_ZplRK15StringSumHelperPKc>
	unsigned char concat(float num);
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
 80a048c:	4601      	mov	r1, r0
 80a048e:	4620      	mov	r0, r4
 80a0490:	f000 ff00 	bl	80a1294 <_ZN6String6concatERKS_>
 80a0494:	a802      	add	r0, sp, #8
 80a0496:	f000 fe54 	bl	80a1142 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a049a:	a806      	add	r0, sp, #24
 80a049c:	f000 fe51 	bl	80a1142 <_ZN6StringD1Ev>
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
 80a04a0:	4920      	ldr	r1, [pc, #128]	; (80a0524 <_Z11format_jsonv+0x1a4>)
 80a04a2:	4620      	mov	r0, r4
 80a04a4:	f000 fefa 	bl	80a129c <_ZN6String6concatEPKc>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a04a8:	491f      	ldr	r1, [pc, #124]	; (80a0528 <_Z11format_jsonv+0x1a8>)
 80a04aa:	a806      	add	r0, sp, #24
 80a04ac:	f000 fe90 	bl	80a11d0 <_ZN6StringC1EPK19__FlashStringHelper>
                res += " \"value\": "; 
                res += "" + String(value) + " }"; 
 80a04b0:	220a      	movs	r2, #10
 80a04b2:	9901      	ldr	r1, [sp, #4]
 80a04b4:	a802      	add	r0, sp, #8
 80a04b6:	f000 feaf 	bl	80a1218 <_ZN6StringC1Elh>
 80a04ba:	a902      	add	r1, sp, #8
 80a04bc:	a806      	add	r0, sp, #24
 80a04be:	f000 fefc 	bl	80a12ba <_ZplRK15StringSumHelperRK6String>
 80a04c2:	491a      	ldr	r1, [pc, #104]	; (80a052c <_Z11format_jsonv+0x1ac>)
 80a04c4:	f000 ff05 	bl	80a12d2 <_ZplRK15StringSumHelperPKc>
	unsigned char concat(float num);
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
 80a04c8:	4601      	mov	r1, r0
 80a04ca:	4620      	mov	r0, r4
 80a04cc:	f000 fee2 	bl	80a1294 <_ZN6String6concatERKS_>
 80a04d0:	a802      	add	r0, sp, #8
 80a04d2:	f000 fe36 	bl	80a1142 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a04d6:	a806      	add	r0, sp, #24
 80a04d8:	f000 fe33 	bl	80a1142 <_ZN6StringD1Ev>
                
                if(i < curr_address - 8) {
 80a04dc:	9b00      	ldr	r3, [sp, #0]
 80a04de:	3b08      	subs	r3, #8
 80a04e0:	429d      	cmp	r5, r3
 80a04e2:	d203      	bcs.n	80a04ec <_Z11format_jsonv+0x16c>
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
 80a04e4:	4912      	ldr	r1, [pc, #72]	; (80a0530 <_Z11format_jsonv+0x1b0>)
 80a04e6:	4620      	mov	r0, r4
 80a04e8:	f000 fed8 	bl	80a129c <_ZN6String6concatEPKc>
        } 

    } else {
        // Print EEPROM: 
        if(curr_address != -1) {
            for(unsigned int i = 8; i < curr_address; i += 8) { 
 80a04ec:	3508      	adds	r5, #8
 80a04ee:	e7af      	b.n	80a0450 <_Z11format_jsonv+0xd0>
                
                if(i < curr_address - 8) {
                    res += ","; 
                }
            } 
            Serial.println("]. "); 
 80a04f0:	f001 fa7a 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a04f4:	490f      	ldr	r1, [pc, #60]	; (80a0534 <_Z11format_jsonv+0x1b4>)
 80a04f6:	f000 fd4a 	bl	80a0f8e <_ZN5Print7printlnEPKc>
 80a04fa:	490f      	ldr	r1, [pc, #60]	; (80a0538 <_Z11format_jsonv+0x1b8>)
 80a04fc:	4620      	mov	r0, r4
 80a04fe:	f000 fecd 	bl	80a129c <_ZN6String6concatEPKc>
    }

    res += " ]"; 

    return res; 
}
 80a0502:	4620      	mov	r0, r4
 80a0504:	b00a      	add	sp, #40	; 0x28
 80a0506:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a050a:	bf00      	nop
 80a050c:	080a76cf 	.word	0x080a76cf
 80a0510:	40024000 	.word	0x40024000
 80a0514:	080a7728 	.word	0x080a7728
 80a0518:	40024004 	.word	0x40024004
 80a051c:	080a7734 	.word	0x080a7734
 80a0520:	080a7737 	.word	0x080a7737
 80a0524:	080a773b 	.word	0x080a773b
 80a0528:	080a40a3 	.word	0x080a40a3
 80a052c:	080a7746 	.word	0x080a7746
 80a0530:	080a7749 	.word	0x080a7749
 80a0534:	080a76d2 	.word	0x080a76d2
 80a0538:	080a774b 	.word	0x080a774b

080a053c <_Z9send_datav>:

unsigned long encoded(unsigned long value, int code); 
String decode_name(unsigned long value); 
String format_json(); 

void send_data() { 
 80a053c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    String json_string = format_json(); 
 80a053e:	4668      	mov	r0, sp
 80a0540:	f7ff ff1e 	bl	80a0380 <_Z11format_jsonv>
    Serial.println(json_string); 
 80a0544:	f001 fa50 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a0548:	9900      	ldr	r1, [sp, #0]
 80a054a:	f000 fd20 	bl	80a0f8e <_ZN5Print7printlnEPKc>

    if (client.connect("9377fcd5.ngrok.io", 80)) {         
 80a054e:	2300      	movs	r3, #0
 80a0550:	2250      	movs	r2, #80	; 0x50
 80a0552:	491d      	ldr	r1, [pc, #116]	; (80a05c8 <_Z9send_datav+0x8c>)
 80a0554:	481d      	ldr	r0, [pc, #116]	; (80a05cc <_Z9send_datav+0x90>)
 80a0556:	f001 f919 	bl	80a178c <_ZN9TCPClient7connectEPKctm>
 80a055a:	b350      	cbz	r0, 80a05b2 <_Z9send_datav+0x76>
        Serial.println("connected");
 80a055c:	f001 fa44 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a0560:	491b      	ldr	r1, [pc, #108]	; (80a05d0 <_Z9send_datav+0x94>)
 80a0562:	f000 fd14 	bl	80a0f8e <_ZN5Print7printlnEPKc>
        
        // Learn how to send a correct POST request. 
        
        client.println("POST /api/dispense HTTP/1.1");
 80a0566:	491b      	ldr	r1, [pc, #108]	; (80a05d4 <_Z9send_datav+0x98>)
 80a0568:	4818      	ldr	r0, [pc, #96]	; (80a05cc <_Z9send_datav+0x90>)
 80a056a:	f000 fd10 	bl	80a0f8e <_ZN5Print7printlnEPKc>
        client.println("Host: 9377fcd5.ngrok.io");
 80a056e:	491a      	ldr	r1, [pc, #104]	; (80a05d8 <_Z9send_datav+0x9c>)
 80a0570:	4816      	ldr	r0, [pc, #88]	; (80a05cc <_Z9send_datav+0x90>)
 80a0572:	f000 fd0c 	bl	80a0f8e <_ZN5Print7printlnEPKc>
        client.println("Content-Type: application/json");
 80a0576:	4919      	ldr	r1, [pc, #100]	; (80a05dc <_Z9send_datav+0xa0>)
 80a0578:	4814      	ldr	r0, [pc, #80]	; (80a05cc <_Z9send_datav+0x90>)
 80a057a:	f000 fd08 	bl	80a0f8e <_ZN5Print7printlnEPKc>
        client.print("Content-Length: ");
 80a057e:	4918      	ldr	r1, [pc, #96]	; (80a05e0 <_Z9send_datav+0xa4>)
 80a0580:	4812      	ldr	r0, [pc, #72]	; (80a05cc <_Z9send_datav+0x90>)
 80a0582:	f000 fcf1 	bl	80a0f68 <_ZN5Print5printEPKc>
        client.println(strlen(json_string));
 80a0586:	9800      	ldr	r0, [sp, #0]
 80a0588:	f001 fe92 	bl	80a22b0 <strlen>
 80a058c:	220a      	movs	r2, #10
 80a058e:	4601      	mov	r1, r0
 80a0590:	480e      	ldr	r0, [pc, #56]	; (80a05cc <_Z9send_datav+0x90>)
 80a0592:	f000 fd32 	bl	80a0ffa <_ZN5Print7printlnEji>
        client.println();
 80a0596:	480d      	ldr	r0, [pc, #52]	; (80a05cc <_Z9send_datav+0x90>)
 80a0598:	f000 fced 	bl	80a0f76 <_ZN5Print7printlnEv>
        client.println(json_string);
 80a059c:	9900      	ldr	r1, [sp, #0]
 80a059e:	480b      	ldr	r0, [pc, #44]	; (80a05cc <_Z9send_datav+0x90>)
 80a05a0:	f000 fcf5 	bl	80a0f8e <_ZN5Print7printlnEPKc>
        client.println();
 80a05a4:	4809      	ldr	r0, [pc, #36]	; (80a05cc <_Z9send_datav+0x90>)
 80a05a6:	f000 fce6 	bl	80a0f76 <_ZN5Print7printlnEv>
        client.stop();
 80a05aa:	4808      	ldr	r0, [pc, #32]	; (80a05cc <_Z9send_datav+0x90>)
 80a05ac:	f000 ff9c 	bl	80a14e8 <_ZN9TCPClient4stopEv>
 80a05b0:	e004      	b.n	80a05bc <_Z9send_datav+0x80>
    }
    else
    {
        Serial.println("connection failed");
 80a05b2:	f001 fa19 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a05b6:	490b      	ldr	r1, [pc, #44]	; (80a05e4 <_Z9send_datav+0xa8>)
 80a05b8:	f000 fce9 	bl	80a0f8e <_ZN5Print7printlnEPKc>
unsigned long encoded(unsigned long value, int code); 
String decode_name(unsigned long value); 
String format_json(); 

void send_data() { 
    String json_string = format_json(); 
 80a05bc:	4668      	mov	r0, sp
 80a05be:	f000 fdc0 	bl	80a1142 <_ZN6StringD1Ev>
    {
        Serial.println("connection failed");
    }

    // Develop mechanism to check if the POST Request was successful 
} 
 80a05c2:	b005      	add	sp, #20
 80a05c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80a05c8:	080a777a 	.word	0x080a777a
 80a05cc:	20000144 	.word	0x20000144
 80a05d0:	080a774e 	.word	0x080a774e
 80a05d4:	080a7758 	.word	0x080a7758
 80a05d8:	080a7774 	.word	0x080a7774
 80a05dc:	080a778c 	.word	0x080a778c
 80a05e0:	080a77ab 	.word	0x080a77ab
 80a05e4:	080a77bc 	.word	0x080a77bc

080a05e8 <_Z12clear_EEPROMv>:
    res += " ]"; 

    return res; 
}

void clear_EEPROM() { 
 80a05e8:	b507      	push	{r0, r1, r2, lr}
    EEPROM.clear(); 
 80a05ea:	f001 fc33 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
        return t;
    }

    void clear()
    {
        HAL_EEPROM_Clear();
 80a05ee:	f000 f97b 	bl	80a08e8 <HAL_EEPROM_Clear>
    EEPROM.put(0, 8ul); 
 80a05f2:	f001 fc2f 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
 80a05f6:	a902      	add	r1, sp, #8
 80a05f8:	2308      	movs	r3, #8
 80a05fa:	f841 3d04 	str.w	r3, [r1, #-4]!
        return t;
    }

    template <typename T> const T &put( int idx, const T &t )
    {
        HAL_EEPROM_Put(idx, &t, sizeof(T));
 80a05fe:	2204      	movs	r2, #4
 80a0600:	2000      	movs	r0, #0
 80a0602:	f000 f969 	bl	80a08d8 <HAL_EEPROM_Put>
    Serial.println("EEPROM cleared. "); 
 80a0606:	f001 f9ef 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a060a:	4903      	ldr	r1, [pc, #12]	; (80a0618 <_Z12clear_EEPROMv+0x30>)
 80a060c:	f000 fcbf 	bl	80a0f8e <_ZN5Print7printlnEPKc>
} 
 80a0610:	b003      	add	sp, #12
 80a0612:	f85d fb04 	ldr.w	pc, [sp], #4
 80a0616:	bf00      	nop
 80a0618:	080a77ce 	.word	0x080a77ce

080a061c <_Z10clear_SRAMv>:

void clear_SRAM() {
 80a061c:	b510      	push	{r4, lr}
    memset(events_encoded, 0, sizeof(long) * events_counter); 
 80a061e:	4c08      	ldr	r4, [pc, #32]	; (80a0640 <_Z10clear_SRAMv+0x24>)
 80a0620:	2100      	movs	r1, #0
 80a0622:	4620      	mov	r0, r4
 80a0624:	f850 2b04 	ldr.w	r2, [r0], #4
 80a0628:	0092      	lsls	r2, r2, #2
 80a062a:	f001 fdfe 	bl	80a222a <memset>
    events_counter = 0; 
 80a062e:	2300      	movs	r3, #0
 80a0630:	6023      	str	r3, [r4, #0]
    Serial.println("SRAM cleared. "); 
 80a0632:	f001 f9d9 	bl	80a19e8 <_Z16_fetch_usbserialv>
}
 80a0636:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
} 

void clear_SRAM() {
    memset(events_encoded, 0, sizeof(long) * events_counter); 
    events_counter = 0; 
    Serial.println("SRAM cleared. "); 
 80a063a:	4902      	ldr	r1, [pc, #8]	; (80a0644 <_Z10clear_SRAMv+0x28>)
 80a063c:	f000 bca7 	b.w	80a0f8e <_ZN5Print7printlnEPKc>
 80a0640:	40024000 	.word	0x40024000
 80a0644:	080a77df 	.word	0x080a77df

080a0648 <_GLOBAL__sub_I_events_encoded>:
}
 80a0648:	b510      	push	{r4, lr}
 80a064a:	f000 f955 	bl	80a08f8 <HAL_Pin_Map>
#include "string.h" 

const int EVENTS_LIMIT = 300; 
retained unsigned long events_encoded[EVENTS_LIMIT]; 
retained int events_counter = 0; 
const size_t EEPROM_LENGTH = EEPROM.length(); 
 80a064e:	f001 fc01 	bl	80a1e54 <_Z21__fetch_global_EEPROMv>
    void update( int idx, uint8_t val )  { EERef( idx ).update( val ); }

    //STL and C++11 iteration capability.
    EEPtr begin()                        { return 0x00; }
    EEPtr end()                          { return length(); } //Standards requires this to be the item after the last valid entry. The returned pointer is invalid.
    uint16_t length()                    { return HAL_EEPROM_Length(); }
 80a0652:	f000 f931 	bl	80a08b8 <HAL_EEPROM_Length>

TCPClient client; 
 80a0656:	4c07      	ldr	r4, [pc, #28]	; (80a0674 <_GLOBAL__sub_I_events_encoded+0x2c>)
#include "string.h" 

const int EVENTS_LIMIT = 300; 
retained unsigned long events_encoded[EVENTS_LIMIT]; 
retained int events_counter = 0; 
const size_t EEPROM_LENGTH = EEPROM.length(); 
 80a0658:	4b07      	ldr	r3, [pc, #28]	; (80a0678 <_GLOBAL__sub_I_events_encoded+0x30>)
 80a065a:	b280      	uxth	r0, r0
 80a065c:	6018      	str	r0, [r3, #0]

TCPClient client; 
 80a065e:	4620      	mov	r0, r4
 80a0660:	f001 f872 	bl	80a1748 <_ZN9TCPClientC1Ev>
 80a0664:	4620      	mov	r0, r4

void clear_SRAM() {
    memset(events_encoded, 0, sizeof(long) * events_counter); 
    events_counter = 0; 
    Serial.println("SRAM cleared. "); 
}
 80a0666:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
const int EVENTS_LIMIT = 300; 
retained unsigned long events_encoded[EVENTS_LIMIT]; 
retained int events_counter = 0; 
const size_t EEPROM_LENGTH = EEPROM.length(); 

TCPClient client; 
 80a066a:	4a04      	ldr	r2, [pc, #16]	; (80a067c <_GLOBAL__sub_I_events_encoded+0x34>)
 80a066c:	4904      	ldr	r1, [pc, #16]	; (80a0680 <_GLOBAL__sub_I_events_encoded+0x38>)
 80a066e:	f001 bc5f 	b.w	80a1f30 <__aeabi_atexit>
 80a0672:	bf00      	nop
 80a0674:	20000144 	.word	0x20000144
 80a0678:	20000160 	.word	0x20000160
 80a067c:	20000140 	.word	0x20000140
 80a0680:	080a0191 	.word	0x080a0191

080a0684 <_Z10check_btnsP5Inputi>:


    delay(100); 
} 

void check_btns(Input btns[], int size) {
 80a0684:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0686:	460e      	mov	r6, r1
 80a0688:	f100 0408 	add.w	r4, r0, #8

    for(int i = 0; i < size; i++) {
 80a068c:	2500      	movs	r5, #0
 80a068e:	42b5      	cmp	r5, r6
 80a0690:	da31      	bge.n	80a06f6 <_Z10check_btnsP5Inputi+0x72>
        if(digitalRead(btns[i].pin) == HIGH && !btns[i].activated){ 
 80a0692:	f834 0c04 	ldrh.w	r0, [r4, #-4]
 80a0696:	f001 fbb2 	bl	80a1dfe <digitalRead>
 80a069a:	2801      	cmp	r0, #1
 80a069c:	d101      	bne.n	80a06a2 <_Z10check_btnsP5Inputi+0x1e>
 80a069e:	7aa3      	ldrb	r3, [r4, #10]
 80a06a0:	b14b      	cbz	r3, 80a06b6 <_Z10check_btnsP5Inputi+0x32>

            Serial.print(btns[i].name); 
            Serial.println(" Pressed. "); 
        }
    
        if(digitalRead(btns[i].pin) == LOW && btns[i].activated) {
 80a06a2:	f834 0c04 	ldrh.w	r0, [r4, #-4]
 80a06a6:	f001 fbaa 	bl	80a1dfe <digitalRead>
 80a06aa:	b908      	cbnz	r0, 80a06b0 <_Z10check_btnsP5Inputi+0x2c>
 80a06ac:	7aa3      	ldrb	r3, [r4, #10]
 80a06ae:	b9b3      	cbnz	r3, 80a06de <_Z10check_btnsP5Inputi+0x5a>
    delay(100); 
} 

void check_btns(Input btns[], int size) {

    for(int i = 0; i < size; i++) {
 80a06b0:	3501      	adds	r5, #1
 80a06b2:	3418      	adds	r4, #24
 80a06b4:	e7eb      	b.n	80a068e <_Z10check_btnsP5Inputi+0xa>
        if(digitalRead(btns[i].pin) == HIGH && !btns[i].activated){ 
            btns[i].activated = true; 
 80a06b6:	72a0      	strb	r0, [r4, #10]
            store_data(btns[i].event_id, millis()); 
 80a06b8:	f854 7c08 	ldr.w	r7, [r4, #-8]
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a06bc:	f000 f8ec 	bl	80a0898 <HAL_Timer_Get_Milli_Seconds>
 80a06c0:	4601      	mov	r1, r0
 80a06c2:	4638      	mov	r0, r7
 80a06c4:	f7ff fde0 	bl	80a0288 <_Z10store_dataim>

            Serial.print(btns[i].name); 
 80a06c8:	f001 f98e 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a06cc:	4621      	mov	r1, r4
 80a06ce:	f000 fc4b 	bl	80a0f68 <_ZN5Print5printEPKc>
            Serial.println(" Pressed. "); 
 80a06d2:	f001 f989 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a06d6:	4908      	ldr	r1, [pc, #32]	; (80a06f8 <_Z10check_btnsP5Inputi+0x74>)
 80a06d8:	f000 fc59 	bl	80a0f8e <_ZN5Print7printlnEPKc>
 80a06dc:	e7e1      	b.n	80a06a2 <_Z10check_btnsP5Inputi+0x1e>
        }
    
        if(digitalRead(btns[i].pin) == LOW && btns[i].activated) {
            btns[i].activated = false; 
 80a06de:	72a0      	strb	r0, [r4, #10]

            Serial.print(btns[i].name); 
 80a06e0:	f001 f982 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a06e4:	4621      	mov	r1, r4
 80a06e6:	f000 fc3f 	bl	80a0f68 <_ZN5Print5printEPKc>
            Serial.println(" Released. "); 
 80a06ea:	f001 f97d 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a06ee:	4903      	ldr	r1, [pc, #12]	; (80a06fc <_Z10check_btnsP5Inputi+0x78>)
 80a06f0:	f000 fc4d 	bl	80a0f8e <_ZN5Print7printlnEPKc>
 80a06f4:	e7dc      	b.n	80a06b0 <_Z10check_btnsP5Inputi+0x2c>
 80a06f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a06f8:	080a77ee 	.word	0x080a77ee
 80a06fc:	080a77f9 	.word	0x080a77f9

080a0700 <_Z17special_functionsv>:
        }
    }
} 

void special_functions() {
 80a0700:	b510      	push	{r4, lr}

    if(digitalRead(btn1.pin) == HIGH && digitalRead(btn2.pin) == HIGH) {
 80a0702:	4c12      	ldr	r4, [pc, #72]	; (80a074c <_Z17special_functionsv+0x4c>)
 80a0704:	88a0      	ldrh	r0, [r4, #4]
 80a0706:	f001 fb7a 	bl	80a1dfe <digitalRead>
 80a070a:	2801      	cmp	r0, #1
 80a070c:	d105      	bne.n	80a071a <_Z17special_functionsv+0x1a>
 80a070e:	4b10      	ldr	r3, [pc, #64]	; (80a0750 <_Z17special_functionsv+0x50>)
 80a0710:	8898      	ldrh	r0, [r3, #4]
 80a0712:	f001 fb74 	bl	80a1dfe <digitalRead>
 80a0716:	2801      	cmp	r0, #1
 80a0718:	d012      	beq.n	80a0740 <_Z17special_functionsv+0x40>
        clear_EEPROM(); 
        clear_SRAM(); 
    } 

    if(digitalRead(btn1.pin) == HIGH && digitalRead(btn3.pin) == HIGH) {
 80a071a:	88a0      	ldrh	r0, [r4, #4]
 80a071c:	f001 fb6f 	bl	80a1dfe <digitalRead>
 80a0720:	2801      	cmp	r0, #1
 80a0722:	d112      	bne.n	80a074a <_Z17special_functionsv+0x4a>
 80a0724:	4b0b      	ldr	r3, [pc, #44]	; (80a0754 <_Z17special_functionsv+0x54>)
 80a0726:	8898      	ldrh	r0, [r3, #4]
 80a0728:	f001 fb69 	bl	80a1dfe <digitalRead>
 80a072c:	2801      	cmp	r0, #1
 80a072e:	d10c      	bne.n	80a074a <_Z17special_functionsv+0x4a>
        send_data(); 
 80a0730:	f7ff ff04 	bl	80a053c <_Z9send_datav>
    }




}
 80a0734:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        clear_SRAM(); 
    } 

    if(digitalRead(btn1.pin) == HIGH && digitalRead(btn3.pin) == HIGH) {
        send_data(); 
        delay(1000); 
 80a0738:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a073c:	f000 bac2 	b.w	80a0cc4 <delay>
} 

void special_functions() {

    if(digitalRead(btn1.pin) == HIGH && digitalRead(btn2.pin) == HIGH) {
        clear_EEPROM(); 
 80a0740:	f7ff ff52 	bl	80a05e8 <_Z12clear_EEPROMv>
        clear_SRAM(); 
 80a0744:	f7ff ff6a 	bl	80a061c <_Z10clear_SRAMv>
 80a0748:	e7e7      	b.n	80a071a <_Z17special_functionsv+0x1a>
 80a074a:	bd10      	pop	{r4, pc}
 80a074c:	20000090 	.word	0x20000090
 80a0750:	200000a8 	.word	0x200000a8
 80a0754:	200000c0 	.word	0x200000c0

080a0758 <loop>:
void setup() {
    set_pins(); 

} 

void loop() { 
 80a0758:	b510      	push	{r4, lr}

    check_btns(btns, 3); 
 80a075a:	2103      	movs	r1, #3
 80a075c:	480a      	ldr	r0, [pc, #40]	; (80a0788 <loop+0x30>)
 80a075e:	f7ff ff91 	bl	80a0684 <_Z10check_btnsP5Inputi>

    special_functions(); 
 80a0762:	f7ff ffcd 	bl	80a0700 <_Z17special_functionsv>

    // Testing 
    Serial.println(analogRead(collar_out)); 
 80a0766:	f001 f93f 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a076a:	4b08      	ldr	r3, [pc, #32]	; (80a078c <loop+0x34>)
 80a076c:	4604      	mov	r4, r0
 80a076e:	8818      	ldrh	r0, [r3, #0]
 80a0770:	f001 fb58 	bl	80a1e24 <analogRead>
 80a0774:	220a      	movs	r2, #10
 80a0776:	4601      	mov	r1, r0
 80a0778:	4620      	mov	r0, r4
 80a077a:	f000 fc6a 	bl	80a1052 <_ZN5Print7printlnEli>


    delay(100); 
} 
 80a077e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

    // Testing 
    Serial.println(analogRead(collar_out)); 


    delay(100); 
 80a0782:	2064      	movs	r0, #100	; 0x64
 80a0784:	f000 ba9e 	b.w	80a0cc4 <delay>
 80a0788:	20000164 	.word	0x20000164
 80a078c:	20000070 	.word	0x20000070

080a0790 <_Z8set_pinsv>:

}



void set_pins() {
 80a0790:	b508      	push	{r3, lr}
    pinMode(inr_emit, OUTPUT); 
 80a0792:	4b15      	ldr	r3, [pc, #84]	; (80a07e8 <_Z8set_pinsv+0x58>)
 80a0794:	2101      	movs	r1, #1
 80a0796:	8818      	ldrh	r0, [r3, #0]
 80a0798:	f001 fb20 	bl	80a1ddc <pinMode>
    pinMode(photo_vcc, OUTPUT); 
 80a079c:	4b13      	ldr	r3, [pc, #76]	; (80a07ec <_Z8set_pinsv+0x5c>)
 80a079e:	2101      	movs	r1, #1
 80a07a0:	8818      	ldrh	r0, [r3, #0]
 80a07a2:	f001 fb1b 	bl	80a1ddc <pinMode>
    pinMode(photo_out.pin, INPUT); 
 80a07a6:	4b12      	ldr	r3, [pc, #72]	; (80a07f0 <_Z8set_pinsv+0x60>)
 80a07a8:	2100      	movs	r1, #0
 80a07aa:	8898      	ldrh	r0, [r3, #4]
 80a07ac:	f001 fb16 	bl	80a1ddc <pinMode>

    pinMode(btn1.pin, INPUT); 
 80a07b0:	4b10      	ldr	r3, [pc, #64]	; (80a07f4 <_Z8set_pinsv+0x64>)
 80a07b2:	2100      	movs	r1, #0
 80a07b4:	8898      	ldrh	r0, [r3, #4]
 80a07b6:	f001 fb11 	bl	80a1ddc <pinMode>
    pinMode(btn2.pin, INPUT);  
 80a07ba:	4b0f      	ldr	r3, [pc, #60]	; (80a07f8 <_Z8set_pinsv+0x68>)
 80a07bc:	2100      	movs	r1, #0
 80a07be:	8898      	ldrh	r0, [r3, #4]
 80a07c0:	f001 fb0c 	bl	80a1ddc <pinMode>
    pinMode(btn3.pin, INPUT); 
 80a07c4:	4b0d      	ldr	r3, [pc, #52]	; (80a07fc <_Z8set_pinsv+0x6c>)
 80a07c6:	2100      	movs	r1, #0
 80a07c8:	8898      	ldrh	r0, [r3, #4]
 80a07ca:	f001 fb07 	bl	80a1ddc <pinMode>

    // Testing 
    pinMode(collar_vcc, OUTPUT); 
 80a07ce:	4b0c      	ldr	r3, [pc, #48]	; (80a0800 <_Z8set_pinsv+0x70>)
 80a07d0:	2101      	movs	r1, #1
 80a07d2:	8818      	ldrh	r0, [r3, #0]
 80a07d4:	f001 fb02 	bl	80a1ddc <pinMode>
    pinMode(collar_out, INPUT); 
 80a07d8:	4b0a      	ldr	r3, [pc, #40]	; (80a0804 <_Z8set_pinsv+0x74>)
 80a07da:	2100      	movs	r1, #0
 80a07dc:	8818      	ldrh	r0, [r3, #0]
}
 80a07de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    pinMode(btn2.pin, INPUT);  
    pinMode(btn3.pin, INPUT); 

    // Testing 
    pinMode(collar_vcc, OUTPUT); 
    pinMode(collar_out, INPUT); 
 80a07e2:	f001 bafb 	b.w	80a1ddc <pinMode>
 80a07e6:	bf00      	nop
 80a07e8:	2000006c 	.word	0x2000006c
 80a07ec:	200001ac 	.word	0x200001ac
 80a07f0:	20000074 	.word	0x20000074
 80a07f4:	20000090 	.word	0x20000090
 80a07f8:	200000a8 	.word	0x200000a8
 80a07fc:	200000c0 	.word	0x200000c0
 80a0800:	2000008c 	.word	0x2000008c
 80a0804:	20000070 	.word	0x20000070

080a0808 <setup>:
void SRAM_test(); 
void check_btns(Input btns[], int size); 
void special_functions(); 

void setup() {
    set_pins(); 
 80a0808:	f7ff bfc2 	b.w	80a0790 <_Z8set_pinsv>

080a080c <_GLOBAL__sub_I_inr_emit>:
    pinMode(btn3.pin, INPUT); 

    // Testing 
    pinMode(collar_vcc, OUTPUT); 
    pinMode(collar_out, INPUT); 
}
 80a080c:	b570      	push	{r4, r5, r6, lr}
// int btn2 = D6;
// int btn3 = D7; 
Input btn1 = { btn1_id, D5, "Button 1", false, 0 }; 
Input btn2 = { btn2_id, D6, "Button 2", false, 0 }; 
Input btn3 = { btn3_id, D7, "Button 3", false, 0 }; 
Input btns[] = { btn1, btn2, btn3 }; 
 80a080e:	4c12      	ldr	r4, [pc, #72]	; (80a0858 <_GLOBAL__sub_I_inr_emit+0x4c>)
 80a0810:	4e12      	ldr	r6, [pc, #72]	; (80a085c <_GLOBAL__sub_I_inr_emit+0x50>)
 80a0812:	4625      	mov	r5, r4
 80a0814:	f000 f870 	bl	80a08f8 <HAL_Pin_Map>
 80a0818:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80a081a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a081c:	e896 0003 	ldmia.w	r6, {r0, r1}
 80a0820:	4e0f      	ldr	r6, [pc, #60]	; (80a0860 <_GLOBAL__sub_I_inr_emit+0x54>)
 80a0822:	e885 0003 	stmia.w	r5, {r0, r1}
 80a0826:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80a0828:	f104 0518 	add.w	r5, r4, #24
 80a082c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a082e:	e896 0003 	ldmia.w	r6, {r0, r1}
 80a0832:	e885 0003 	stmia.w	r5, {r0, r1}
 80a0836:	4d0b      	ldr	r5, [pc, #44]	; (80a0864 <_GLOBAL__sub_I_inr_emit+0x58>)
 80a0838:	3430      	adds	r4, #48	; 0x30
 80a083a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a083c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a083e:	e895 0003 	ldmia.w	r5, {r0, r1}
 80a0842:	e884 0003 	stmia.w	r4, {r0, r1}
        return HAL_Feature_Get(feature);
    }

    inline int enableFeature(HAL_Feature feature)
    {
        return HAL_Feature_Set(feature, true);
 80a0846:	2101      	movs	r1, #1
 80a0848:	4608      	mov	r0, r1
 80a084a:	f000 f815 	bl	80a0878 <HAL_Feature_Set>
    pinMode(btn3.pin, INPUT); 

    // Testing 
    pinMode(collar_vcc, OUTPUT); 
    pinMode(collar_out, INPUT); 
}
 80a084e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
// DATA STORAGE 

STARTUP(System.enableFeature(FEATURE_RETAINED_MEMORY)); 

// WIFI 
STARTUP(setUpInternet()); // Press SETUP for 3 seconds to make the Photon enter Listening mode. Navigate to http://192.168.0.1 to setup Wi-Fi 
 80a0852:	f7ff bc95 	b.w	80a0180 <_Z13setUpInternetv>
 80a0856:	bf00      	nop
 80a0858:	20000164 	.word	0x20000164
 80a085c:	20000090 	.word	0x20000090
 80a0860:	200000a8 	.word	0x200000a8
 80a0864:	200000c0 	.word	0x200000c0

080a0868 <os_mutex_create>:
DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))

DYNALIB_FN(12, hal_concurrent, os_mutex_create, int(os_mutex_t*))
 80a0868:	b508      	push	{r3, lr}
 80a086a:	4b02      	ldr	r3, [pc, #8]	; (80a0874 <os_mutex_create+0xc>)
 80a086c:	681b      	ldr	r3, [r3, #0]
 80a086e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0870:	9301      	str	r3, [sp, #4]
 80a0872:	bd08      	pop	{r3, pc}
 80a0874:	080601d0 	.word	0x080601d0

080a0878 <HAL_Feature_Set>:
DYNALIB_FN(20, hal_core, HAL_Core_System_Reset_FlagSet, bool(RESET_TypeDef))
DYNALIB_FN(21, hal_core, HAL_Core_Runtime_Info, uint32_t(runtime_info_t*, void*))
DYNALIB_FN(22, hal_core, HAL_Set_System_Config, int(hal_system_config_t, const void*, unsigned))
DYNALIB_FN(23, hal_core, HAL_Core_Enter_Safe_Mode, void(void*))
DYNALIB_FN(24, hal_core, HAL_Feature_Get, bool(HAL_Feature))
DYNALIB_FN(25, hal_core, HAL_Feature_Set, int(HAL_Feature, bool))
 80a0878:	b508      	push	{r3, lr}
 80a087a:	4b02      	ldr	r3, [pc, #8]	; (80a0884 <HAL_Feature_Set+0xc>)
 80a087c:	681b      	ldr	r3, [r3, #0]
 80a087e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a0880:	9301      	str	r3, [sp, #4]
 80a0882:	bd08      	pop	{r3, pc}
 80a0884:	080601b8 	.word	0x080601b8

080a0888 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a0888:	b508      	push	{r3, lr}
 80a088a:	4b02      	ldr	r3, [pc, #8]	; (80a0894 <HAL_RNG_GetRandomNumber+0xc>)
 80a088c:	681b      	ldr	r3, [r3, #0]
 80a088e:	685b      	ldr	r3, [r3, #4]
 80a0890:	9301      	str	r3, [sp, #4]
 80a0892:	bd08      	pop	{r3, pc}
 80a0894:	0806019c 	.word	0x0806019c

080a0898 <HAL_Timer_Get_Milli_Seconds>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a0898:	b508      	push	{r3, lr}
 80a089a:	4b02      	ldr	r3, [pc, #8]	; (80a08a4 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a089c:	681b      	ldr	r3, [r3, #0]
 80a089e:	695b      	ldr	r3, [r3, #20]
 80a08a0:	9301      	str	r3, [sp, #4]
 80a08a2:	bd08      	pop	{r3, pc}
 80a08a4:	0806019c 	.word	0x0806019c

080a08a8 <HAL_EEPROM_Init>:
DYNALIB_FN(BASE_IDX + 4, hal, HAL_RTC_Configuration, void(void))
DYNALIB_FN(BASE_IDX + 5, hal, HAL_RTC_Get_UnixTime, time_t(void))
DYNALIB_FN(BASE_IDX + 6, hal, HAL_RTC_Set_UnixTime, void(time_t))
DYNALIB_FN(BASE_IDX + 7, hal, HAL_RTC_Set_UnixAlarm, void(time_t))

DYNALIB_FN(BASE_IDX + 8, hal, HAL_EEPROM_Init, void(void))
 80a08a8:	b508      	push	{r3, lr}
 80a08aa:	4b02      	ldr	r3, [pc, #8]	; (80a08b4 <HAL_EEPROM_Init+0xc>)
 80a08ac:	681b      	ldr	r3, [r3, #0]
 80a08ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a08b0:	9301      	str	r3, [sp, #4]
 80a08b2:	bd08      	pop	{r3, pc}
 80a08b4:	0806019c 	.word	0x0806019c

080a08b8 <HAL_EEPROM_Length>:
DYNALIB_FN(BASE_IDX + 9, hal, HAL_EEPROM_Read, uint8_t(uint32_t))
DYNALIB_FN(BASE_IDX + 10, hal, HAL_EEPROM_Write, void(uint32_t, uint8_t))
DYNALIB_FN(BASE_IDX + 11, hal, HAL_EEPROM_Length, size_t(void))
 80a08b8:	b508      	push	{r3, lr}
 80a08ba:	4b02      	ldr	r3, [pc, #8]	; (80a08c4 <HAL_EEPROM_Length+0xc>)
 80a08bc:	681b      	ldr	r3, [r3, #0]
 80a08be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a08c0:	9301      	str	r3, [sp, #4]
 80a08c2:	bd08      	pop	{r3, pc}
 80a08c4:	0806019c 	.word	0x0806019c

080a08c8 <HAL_EEPROM_Get>:

DYNALIB_FN(BASE_IDX + 12, hal, HAL_disable_irq, int(void))
DYNALIB_FN(BASE_IDX + 13, hal, HAL_enable_irq, void(int))
DYNALIB_FN(BASE_IDX + 14, hal, HAL_RTC_Cancel_UnixAlarm, void(void))

DYNALIB_FN(BASE_IDX + 15, hal,HAL_EEPROM_Get, void(uint32_t, void *, size_t))
 80a08c8:	b508      	push	{r3, lr}
 80a08ca:	4b02      	ldr	r3, [pc, #8]	; (80a08d4 <HAL_EEPROM_Get+0xc>)
 80a08cc:	681b      	ldr	r3, [r3, #0]
 80a08ce:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a08d0:	9301      	str	r3, [sp, #4]
 80a08d2:	bd08      	pop	{r3, pc}
 80a08d4:	0806019c 	.word	0x0806019c

080a08d8 <HAL_EEPROM_Put>:
DYNALIB_FN(BASE_IDX + 16, hal,HAL_EEPROM_Put, void(uint32_t, const void *, size_t))
 80a08d8:	b508      	push	{r3, lr}
 80a08da:	4b02      	ldr	r3, [pc, #8]	; (80a08e4 <HAL_EEPROM_Put+0xc>)
 80a08dc:	681b      	ldr	r3, [r3, #0]
 80a08de:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a08e0:	9301      	str	r3, [sp, #4]
 80a08e2:	bd08      	pop	{r3, pc}
 80a08e4:	0806019c 	.word	0x0806019c

080a08e8 <HAL_EEPROM_Clear>:
DYNALIB_FN(BASE_IDX + 17, hal,HAL_EEPROM_Clear, void(void))
 80a08e8:	b508      	push	{r3, lr}
 80a08ea:	4b02      	ldr	r3, [pc, #8]	; (80a08f4 <HAL_EEPROM_Clear+0xc>)
 80a08ec:	681b      	ldr	r3, [r3, #0]
 80a08ee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a08f0:	9301      	str	r3, [sp, #4]
 80a08f2:	bd08      	pop	{r3, pc}
 80a08f4:	0806019c 	.word	0x0806019c

080a08f8 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
 80a08f8:	b508      	push	{r3, lr}
 80a08fa:	4b02      	ldr	r3, [pc, #8]	; (80a0904 <HAL_Pin_Map+0xc>)
 80a08fc:	681b      	ldr	r3, [r3, #0]
 80a08fe:	681b      	ldr	r3, [r3, #0]
 80a0900:	9301      	str	r3, [sp, #4]
 80a0902:	bd08      	pop	{r3, pc}
 80a0904:	080601b0 	.word	0x080601b0

080a0908 <HAL_Validate_Pin_Function>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
 80a0908:	b508      	push	{r3, lr}
 80a090a:	4b02      	ldr	r3, [pc, #8]	; (80a0914 <HAL_Validate_Pin_Function+0xc>)
 80a090c:	681b      	ldr	r3, [r3, #0]
 80a090e:	685b      	ldr	r3, [r3, #4]
 80a0910:	9301      	str	r3, [sp, #4]
 80a0912:	bd08      	pop	{r3, pc}
 80a0914:	080601b0 	.word	0x080601b0

080a0918 <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a0918:	b508      	push	{r3, lr}
 80a091a:	4b02      	ldr	r3, [pc, #8]	; (80a0924 <HAL_Pin_Mode+0xc>)
 80a091c:	681b      	ldr	r3, [r3, #0]
 80a091e:	689b      	ldr	r3, [r3, #8]
 80a0920:	9301      	str	r3, [sp, #4]
 80a0922:	bd08      	pop	{r3, pc}
 80a0924:	080601b0 	.word	0x080601b0

080a0928 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a0928:	b508      	push	{r3, lr}
 80a092a:	4b02      	ldr	r3, [pc, #8]	; (80a0934 <HAL_Get_Pin_Mode+0xc>)
 80a092c:	681b      	ldr	r3, [r3, #0]
 80a092e:	68db      	ldr	r3, [r3, #12]
 80a0930:	9301      	str	r3, [sp, #4]
 80a0932:	bd08      	pop	{r3, pc}
 80a0934:	080601b0 	.word	0x080601b0

080a0938 <HAL_GPIO_Read>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
DYNALIB_FN(5, hal_gpio, HAL_GPIO_Read, int32_t(pin_t))
 80a0938:	b508      	push	{r3, lr}
 80a093a:	4b02      	ldr	r3, [pc, #8]	; (80a0944 <HAL_GPIO_Read+0xc>)
 80a093c:	681b      	ldr	r3, [r3, #0]
 80a093e:	695b      	ldr	r3, [r3, #20]
 80a0940:	9301      	str	r3, [sp, #4]
 80a0942:	bd08      	pop	{r3, pc}
 80a0944:	080601b0 	.word	0x080601b0

080a0948 <HAL_ADC_Read>:
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
DYNALIB_FN(11, hal_gpio, HAL_ADC_Set_Sample_Time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, HAL_ADC_Read, int32_t(uint16_t))
 80a0948:	b508      	push	{r3, lr}
 80a094a:	4b02      	ldr	r3, [pc, #8]	; (80a0954 <HAL_ADC_Read+0xc>)
 80a094c:	681b      	ldr	r3, [r3, #0]
 80a094e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0950:	9301      	str	r3, [sp, #4]
 80a0952:	bd08      	pop	{r3, pc}
 80a0954:	080601b0 	.word	0x080601b0

080a0958 <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a0958:	b508      	push	{r3, lr}
 80a095a:	4b02      	ldr	r3, [pc, #8]	; (80a0964 <HAL_I2C_Write_Data+0xc>)
 80a095c:	681b      	ldr	r3, [r3, #0]
 80a095e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a0960:	9301      	str	r3, [sp, #4]
 80a0962:	bd08      	pop	{r3, pc}
 80a0964:	080601ac 	.word	0x080601ac

080a0968 <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a0968:	b508      	push	{r3, lr}
 80a096a:	4b02      	ldr	r3, [pc, #8]	; (80a0974 <HAL_I2C_Available_Data+0xc>)
 80a096c:	681b      	ldr	r3, [r3, #0]
 80a096e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a0970:	9301      	str	r3, [sp, #4]
 80a0972:	bd08      	pop	{r3, pc}
 80a0974:	080601ac 	.word	0x080601ac

080a0978 <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a0978:	b508      	push	{r3, lr}
 80a097a:	4b02      	ldr	r3, [pc, #8]	; (80a0984 <HAL_I2C_Read_Data+0xc>)
 80a097c:	681b      	ldr	r3, [r3, #0]
 80a097e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a0980:	9301      	str	r3, [sp, #4]
 80a0982:	bd08      	pop	{r3, pc}
 80a0984:	080601ac 	.word	0x080601ac

080a0988 <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a0988:	b508      	push	{r3, lr}
 80a098a:	4b02      	ldr	r3, [pc, #8]	; (80a0994 <HAL_I2C_Peek_Data+0xc>)
 80a098c:	681b      	ldr	r3, [r3, #0]
 80a098e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a0990:	9301      	str	r3, [sp, #4]
 80a0992:	bd08      	pop	{r3, pc}
 80a0994:	080601ac 	.word	0x080601ac

080a0998 <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a0998:	b508      	push	{r3, lr}
 80a099a:	4b02      	ldr	r3, [pc, #8]	; (80a09a4 <HAL_I2C_Flush_Data+0xc>)
 80a099c:	681b      	ldr	r3, [r3, #0]
 80a099e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a09a0:	9301      	str	r3, [sp, #4]
 80a09a2:	bd08      	pop	{r3, pc}
 80a09a4:	080601ac 	.word	0x080601ac

080a09a8 <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a09a8:	b508      	push	{r3, lr}
 80a09aa:	4b02      	ldr	r3, [pc, #8]	; (80a09b4 <HAL_I2C_Is_Enabled+0xc>)
 80a09ac:	681b      	ldr	r3, [r3, #0]
 80a09ae:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a09b0:	9301      	str	r3, [sp, #4]
 80a09b2:	bd08      	pop	{r3, pc}
 80a09b4:	080601ac 	.word	0x080601ac

080a09b8 <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a09b8:	b508      	push	{r3, lr}
 80a09ba:	4b03      	ldr	r3, [pc, #12]	; (80a09c8 <HAL_I2C_Init+0x10>)
 80a09bc:	681b      	ldr	r3, [r3, #0]
 80a09be:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a09c2:	9301      	str	r3, [sp, #4]
 80a09c4:	bd08      	pop	{r3, pc}
 80a09c6:	0000      	.short	0x0000
 80a09c8:	080601ac 	.word	0x080601ac

080a09cc <socket_active_status>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_socket)

DYNALIB_FN(0, hal_socket, socket_active_status, uint8_t(sock_handle_t))
 80a09cc:	b508      	push	{r3, lr}
 80a09ce:	4b02      	ldr	r3, [pc, #8]	; (80a09d8 <socket_active_status+0xc>)
 80a09d0:	681b      	ldr	r3, [r3, #0]
 80a09d2:	681b      	ldr	r3, [r3, #0]
 80a09d4:	9301      	str	r3, [sp, #4]
 80a09d6:	bd08      	pop	{r3, pc}
 80a09d8:	080601bc 	.word	0x080601bc

080a09dc <socket_handle_valid>:
DYNALIB_FN(1, hal_socket, socket_handle_valid, uint8_t(sock_handle_t))
 80a09dc:	b508      	push	{r3, lr}
 80a09de:	4b02      	ldr	r3, [pc, #8]	; (80a09e8 <socket_handle_valid+0xc>)
 80a09e0:	681b      	ldr	r3, [r3, #0]
 80a09e2:	685b      	ldr	r3, [r3, #4]
 80a09e4:	9301      	str	r3, [sp, #4]
 80a09e6:	bd08      	pop	{r3, pc}
 80a09e8:	080601bc 	.word	0x080601bc

080a09ec <socket_create>:
DYNALIB_FN(2, hal_socket, socket_create, sock_handle_t(uint8_t, uint8_t, uint8_t, uint16_t, network_interface_t))
 80a09ec:	b508      	push	{r3, lr}
 80a09ee:	4b02      	ldr	r3, [pc, #8]	; (80a09f8 <socket_create+0xc>)
 80a09f0:	681b      	ldr	r3, [r3, #0]
 80a09f2:	689b      	ldr	r3, [r3, #8]
 80a09f4:	9301      	str	r3, [sp, #4]
 80a09f6:	bd08      	pop	{r3, pc}
 80a09f8:	080601bc 	.word	0x080601bc

080a09fc <socket_connect>:
DYNALIB_FN(3, hal_socket, socket_connect, int32_t(sock_handle_t, const sockaddr_t*, long))
 80a09fc:	b508      	push	{r3, lr}
 80a09fe:	4b02      	ldr	r3, [pc, #8]	; (80a0a08 <socket_connect+0xc>)
 80a0a00:	681b      	ldr	r3, [r3, #0]
 80a0a02:	68db      	ldr	r3, [r3, #12]
 80a0a04:	9301      	str	r3, [sp, #4]
 80a0a06:	bd08      	pop	{r3, pc}
 80a0a08:	080601bc 	.word	0x080601bc

080a0a0c <socket_receive>:
DYNALIB_FN(4, hal_socket, socket_receive, sock_result_t(sock_handle_t, void*, socklen_t, system_tick_t))
 80a0a0c:	b508      	push	{r3, lr}
 80a0a0e:	4b02      	ldr	r3, [pc, #8]	; (80a0a18 <socket_receive+0xc>)
 80a0a10:	681b      	ldr	r3, [r3, #0]
 80a0a12:	691b      	ldr	r3, [r3, #16]
 80a0a14:	9301      	str	r3, [sp, #4]
 80a0a16:	bd08      	pop	{r3, pc}
 80a0a18:	080601bc 	.word	0x080601bc

080a0a1c <socket_close>:
DYNALIB_FN(5, hal_socket, socket_receivefrom, sock_result_t(sock_handle_t, void*, socklen_t, uint32_t, sockaddr_t*, socklen_t*))
DYNALIB_FN(6, hal_socket, socket_send, sock_result_t(sock_handle_t, const void*, socklen_t))
DYNALIB_FN(7, hal_socket, socket_sendto, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, sockaddr_t*, socklen_t))
DYNALIB_FN(8, hal_socket, socket_close, sock_result_t(sock_handle_t))
 80a0a1c:	b508      	push	{r3, lr}
 80a0a1e:	4b02      	ldr	r3, [pc, #8]	; (80a0a28 <socket_close+0xc>)
 80a0a20:	681b      	ldr	r3, [r3, #0]
 80a0a22:	6a1b      	ldr	r3, [r3, #32]
 80a0a24:	9301      	str	r3, [sp, #4]
 80a0a26:	bd08      	pop	{r3, pc}
 80a0a28:	080601bc 	.word	0x080601bc

080a0a2c <socket_handle_invalid>:
DYNALIB_FN(9, hal_socket, socket_reset_blocking_call, sock_result_t(void))
DYNALIB_FN(10, hal_socket, socket_create_tcp_server, sock_result_t(uint16_t, network_interface_t))
DYNALIB_FN(11, hal_socket, socket_accept, sock_result_t(sock_handle_t))
DYNALIB_FN(12, hal_socket, socket_handle_invalid, sock_handle_t(void))
 80a0a2c:	b508      	push	{r3, lr}
 80a0a2e:	4b02      	ldr	r3, [pc, #8]	; (80a0a38 <socket_handle_invalid+0xc>)
 80a0a30:	681b      	ldr	r3, [r3, #0]
 80a0a32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0a34:	9301      	str	r3, [sp, #4]
 80a0a36:	bd08      	pop	{r3, pc}
 80a0a38:	080601bc 	.word	0x080601bc

080a0a3c <socket_send_ex>:
DYNALIB_FN(13, hal_socket, socket_join_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(14, hal_socket, socket_leave_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(15, hal_socket, socket_peer, sock_result_t(sock_handle_t, sock_peer_t*, void*))
DYNALIB_FN(16, hal_socket, socket_shutdown, sock_result_t(sock_handle_t, int))
DYNALIB_FN(17, hal_socket, socket_send_ex, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, system_tick_t, void*))
 80a0a3c:	b508      	push	{r3, lr}
 80a0a3e:	4b02      	ldr	r3, [pc, #8]	; (80a0a48 <socket_send_ex+0xc>)
 80a0a40:	681b      	ldr	r3, [r3, #0]
 80a0a42:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a0a44:	9301      	str	r3, [sp, #4]
 80a0a46:	bd08      	pop	{r3, pc}
 80a0a48:	080601bc 	.word	0x080601bc

080a0a4c <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a0a4c:	b508      	push	{r3, lr}
 80a0a4e:	4b02      	ldr	r3, [pc, #8]	; (80a0a58 <HAL_SPI_Init+0xc>)
 80a0a50:	681b      	ldr	r3, [r3, #0]
 80a0a52:	69db      	ldr	r3, [r3, #28]
 80a0a54:	9301      	str	r3, [sp, #4]
 80a0a56:	bd08      	pop	{r3, pc}
 80a0a58:	080601b4 	.word	0x080601b4

080a0a5c <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a0a5c:	b508      	push	{r3, lr}
 80a0a5e:	4b02      	ldr	r3, [pc, #8]	; (80a0a68 <HAL_SPI_Is_Enabled+0xc>)
 80a0a60:	681b      	ldr	r3, [r3, #0]
 80a0a62:	6a1b      	ldr	r3, [r3, #32]
 80a0a64:	9301      	str	r3, [sp, #4]
 80a0a66:	bd08      	pop	{r3, pc}
 80a0a68:	080601b4 	.word	0x080601b4

080a0a6c <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a0a6c:	b508      	push	{r3, lr}
 80a0a6e:	4b02      	ldr	r3, [pc, #8]	; (80a0a78 <HAL_USART_Init+0xc>)
 80a0a70:	681b      	ldr	r3, [r3, #0]
 80a0a72:	699b      	ldr	r3, [r3, #24]
 80a0a74:	9301      	str	r3, [sp, #4]
 80a0a76:	bd08      	pop	{r3, pc}
 80a0a78:	080601c4 	.word	0x080601c4

080a0a7c <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a0a7c:	b508      	push	{r3, lr}
 80a0a7e:	4b02      	ldr	r3, [pc, #8]	; (80a0a88 <HAL_USART_Write_Data+0xc>)
 80a0a80:	681b      	ldr	r3, [r3, #0]
 80a0a82:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0a84:	9301      	str	r3, [sp, #4]
 80a0a86:	bd08      	pop	{r3, pc}
 80a0a88:	080601c4 	.word	0x080601c4

080a0a8c <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a0a8c:	b508      	push	{r3, lr}
 80a0a8e:	4b02      	ldr	r3, [pc, #8]	; (80a0a98 <HAL_USART_Available_Data+0xc>)
 80a0a90:	681b      	ldr	r3, [r3, #0]
 80a0a92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0a94:	9301      	str	r3, [sp, #4]
 80a0a96:	bd08      	pop	{r3, pc}
 80a0a98:	080601c4 	.word	0x080601c4

080a0a9c <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a0a9c:	b508      	push	{r3, lr}
 80a0a9e:	4b02      	ldr	r3, [pc, #8]	; (80a0aa8 <HAL_USART_Read_Data+0xc>)
 80a0aa0:	681b      	ldr	r3, [r3, #0]
 80a0aa2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0aa4:	9301      	str	r3, [sp, #4]
 80a0aa6:	bd08      	pop	{r3, pc}
 80a0aa8:	080601c4 	.word	0x080601c4

080a0aac <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a0aac:	b508      	push	{r3, lr}
 80a0aae:	4b02      	ldr	r3, [pc, #8]	; (80a0ab8 <HAL_USART_Peek_Data+0xc>)
 80a0ab0:	681b      	ldr	r3, [r3, #0]
 80a0ab2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0ab4:	9301      	str	r3, [sp, #4]
 80a0ab6:	bd08      	pop	{r3, pc}
 80a0ab8:	080601c4 	.word	0x080601c4

080a0abc <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a0abc:	b508      	push	{r3, lr}
 80a0abe:	4b02      	ldr	r3, [pc, #8]	; (80a0ac8 <HAL_USART_Flush_Data+0xc>)
 80a0ac0:	681b      	ldr	r3, [r3, #0]
 80a0ac2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0ac4:	9301      	str	r3, [sp, #4]
 80a0ac6:	bd08      	pop	{r3, pc}
 80a0ac8:	080601c4 	.word	0x080601c4

080a0acc <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a0acc:	b508      	push	{r3, lr}
 80a0ace:	4b02      	ldr	r3, [pc, #8]	; (80a0ad8 <HAL_USART_Is_Enabled+0xc>)
 80a0ad0:	681b      	ldr	r3, [r3, #0]
 80a0ad2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a0ad4:	9301      	str	r3, [sp, #4]
 80a0ad6:	bd08      	pop	{r3, pc}
 80a0ad8:	080601c4 	.word	0x080601c4

080a0adc <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a0adc:	b508      	push	{r3, lr}
 80a0ade:	4b02      	ldr	r3, [pc, #8]	; (80a0ae8 <HAL_USART_Available_Data_For_Write+0xc>)
 80a0ae0:	681b      	ldr	r3, [r3, #0]
 80a0ae2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a0ae4:	9301      	str	r3, [sp, #4]
 80a0ae6:	bd08      	pop	{r3, pc}
 80a0ae8:	080601c4 	.word	0x080601c4

080a0aec <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a0aec:	b508      	push	{r3, lr}
 80a0aee:	4b02      	ldr	r3, [pc, #8]	; (80a0af8 <HAL_USB_USART_Init+0xc>)
 80a0af0:	681b      	ldr	r3, [r3, #0]
 80a0af2:	681b      	ldr	r3, [r3, #0]
 80a0af4:	9301      	str	r3, [sp, #4]
 80a0af6:	bd08      	pop	{r3, pc}
 80a0af8:	080601d8 	.word	0x080601d8

080a0afc <HAL_USB_USART_Available_Data>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a0afc:	b508      	push	{r3, lr}
 80a0afe:	4b02      	ldr	r3, [pc, #8]	; (80a0b08 <HAL_USB_USART_Available_Data+0xc>)
 80a0b00:	681b      	ldr	r3, [r3, #0]
 80a0b02:	691b      	ldr	r3, [r3, #16]
 80a0b04:	9301      	str	r3, [sp, #4]
 80a0b06:	bd08      	pop	{r3, pc}
 80a0b08:	080601d8 	.word	0x080601d8

080a0b0c <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a0b0c:	b508      	push	{r3, lr}
 80a0b0e:	4b02      	ldr	r3, [pc, #8]	; (80a0b18 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a0b10:	681b      	ldr	r3, [r3, #0]
 80a0b12:	695b      	ldr	r3, [r3, #20]
 80a0b14:	9301      	str	r3, [sp, #4]
 80a0b16:	bd08      	pop	{r3, pc}
 80a0b18:	080601d8 	.word	0x080601d8

080a0b1c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a0b1c:	b508      	push	{r3, lr}
 80a0b1e:	4b02      	ldr	r3, [pc, #8]	; (80a0b28 <HAL_USB_USART_Receive_Data+0xc>)
 80a0b20:	681b      	ldr	r3, [r3, #0]
 80a0b22:	699b      	ldr	r3, [r3, #24]
 80a0b24:	9301      	str	r3, [sp, #4]
 80a0b26:	bd08      	pop	{r3, pc}
 80a0b28:	080601d8 	.word	0x080601d8

080a0b2c <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a0b2c:	b508      	push	{r3, lr}
 80a0b2e:	4b02      	ldr	r3, [pc, #8]	; (80a0b38 <HAL_USB_USART_Send_Data+0xc>)
 80a0b30:	681b      	ldr	r3, [r3, #0]
 80a0b32:	69db      	ldr	r3, [r3, #28]
 80a0b34:	9301      	str	r3, [sp, #4]
 80a0b36:	bd08      	pop	{r3, pc}
 80a0b38:	080601d8 	.word	0x080601d8

080a0b3c <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a0b3c:	b508      	push	{r3, lr}
 80a0b3e:	4b02      	ldr	r3, [pc, #8]	; (80a0b48 <HAL_USB_USART_Flush_Data+0xc>)
 80a0b40:	681b      	ldr	r3, [r3, #0]
 80a0b42:	6a1b      	ldr	r3, [r3, #32]
 80a0b44:	9301      	str	r3, [sp, #4]
 80a0b46:	bd08      	pop	{r3, pc}
 80a0b48:	080601d8 	.word	0x080601d8

080a0b4c <HAL_NET_SetNetWatchDog>:

DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, int(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
 80a0b4c:	b508      	push	{r3, lr}
 80a0b4e:	4b02      	ldr	r3, [pc, #8]	; (80a0b58 <HAL_NET_SetNetWatchDog+0xc>)
 80a0b50:	681b      	ldr	r3, [r3, #0]
 80a0b52:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a0b54:	9301      	str	r3, [sp, #4]
 80a0b56:	bd08      	pop	{r3, pc}
 80a0b58:	080601c0 	.word	0x080601c0

080a0b5c <inet_gethostbyname>:
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a0b5c:	b508      	push	{r3, lr}
 80a0b5e:	4b02      	ldr	r3, [pc, #8]	; (80a0b68 <inet_gethostbyname+0xc>)
 80a0b60:	681b      	ldr	r3, [r3, #0]
 80a0b62:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a0b64:	9301      	str	r3, [sp, #4]
 80a0b66:	bd08      	pop	{r3, pc}
 80a0b68:	080601c0 	.word	0x080601c0

080a0b6c <softap_set_application_page_handler>:
DYNALIB_FN(20, hal_wlan, wlan_select_antenna, int(WLanSelectAntenna_TypeDef))
DYNALIB_FN(21, hal_wlan, wlan_set_ipaddress, void(const HAL_IPAddress*, const HAL_IPAddress*, const HAL_IPAddress*, const HAL_IPAddress*, const HAL_IPAddress*, void*))
DYNALIB_FN(22, hal_wlan, wlan_set_ipaddress_source, void(IPAddressSource, bool, void*))
DYNALIB_FN(23, hal_wlan, wlan_scan, int(wlan_scan_result_t, void*))
DYNALIB_FN(24, hal_wlan, wlan_get_credentials, int(wlan_scan_result_t, void*))
DYNALIB_FN(25, hal_wlan, softap_set_application_page_handler, int(PageProvider* provider, void* reserved))
 80a0b6c:	b508      	push	{r3, lr}
 80a0b6e:	4b02      	ldr	r3, [pc, #8]	; (80a0b78 <softap_set_application_page_handler+0xc>)
 80a0b70:	681b      	ldr	r3, [r3, #0]
 80a0b72:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a0b74:	9301      	str	r3, [sp, #4]
 80a0b76:	bd08      	pop	{r3, pc}
 80a0b78:	080601c0 	.word	0x080601c0

080a0b7c <log_message>:
DYNALIB_FN(16, services, log_print_, void(int, int, const char*, const char*, const char*, ...)) // Deprecated
DYNALIB_FN(17, services, LED_RGB_SetChangeHandler, void(led_update_handler_fn, void*))
DYNALIB_FN(18, services, log_print_direct_, void(int, void*, const char*, ...)) // Deprecated
DYNALIB_FN(19, services, LED_GetColor, uint32_t(uint32_t, void*))

DYNALIB_FN(20, services, log_message, void(int, const char*, LogAttributes*, void*, const char*, ...))
 80a0b7c:	b508      	push	{r3, lr}
 80a0b7e:	4b02      	ldr	r3, [pc, #8]	; (80a0b88 <log_message+0xc>)
 80a0b80:	681b      	ldr	r3, [r3, #0]
 80a0b82:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80a0b84:	9301      	str	r3, [sp, #4]
 80a0b86:	bd08      	pop	{r3, pc}
 80a0b88:	080201a8 	.word	0x080201a8

080a0b8c <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a0b8c:	b508      	push	{r3, lr}
 80a0b8e:	4b02      	ldr	r3, [pc, #8]	; (80a0b98 <set_system_mode+0xc>)
 80a0b90:	681b      	ldr	r3, [r3, #0]
 80a0b92:	685b      	ldr	r3, [r3, #4]
 80a0b94:	9301      	str	r3, [sp, #4]
 80a0b96:	bd08      	pop	{r3, pc}
 80a0b98:	080601a4 	.word	0x080601a4

080a0b9c <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a0b9c:	b508      	push	{r3, lr}
 80a0b9e:	4b02      	ldr	r3, [pc, #8]	; (80a0ba8 <system_delay_ms+0xc>)
 80a0ba0:	681b      	ldr	r3, [r3, #0]
 80a0ba2:	695b      	ldr	r3, [r3, #20]
 80a0ba4:	9301      	str	r3, [sp, #4]
 80a0ba6:	bd08      	pop	{r3, pc}
 80a0ba8:	080601a4 	.word	0x080601a4

080a0bac <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a0bac:	b508      	push	{r3, lr}
 80a0bae:	4b03      	ldr	r3, [pc, #12]	; (80a0bbc <system_ctrl_set_app_request_handler+0x10>)
 80a0bb0:	681b      	ldr	r3, [r3, #0]
 80a0bb2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a0bb6:	9301      	str	r3, [sp, #4]
 80a0bb8:	bd08      	pop	{r3, pc}
 80a0bba:	0000      	.short	0x0000
 80a0bbc:	080601a4 	.word	0x080601a4

080a0bc0 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a0bc0:	b508      	push	{r3, lr}
 80a0bc2:	4b03      	ldr	r3, [pc, #12]	; (80a0bd0 <system_ctrl_set_result+0x10>)
 80a0bc4:	681b      	ldr	r3, [r3, #0]
 80a0bc6:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a0bca:	9301      	str	r3, [sp, #4]
 80a0bcc:	bd08      	pop	{r3, pc}
 80a0bce:	0000      	.short	0x0000
 80a0bd0:	080601a4 	.word	0x080601a4

080a0bd4 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a0bd4:	b508      	push	{r3, lr}
 80a0bd6:	4b02      	ldr	r3, [pc, #8]	; (80a0be0 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a0bd8:	681b      	ldr	r3, [r3, #0]
 80a0bda:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a0bdc:	9301      	str	r3, [sp, #4]
 80a0bde:	bd08      	pop	{r3, pc}
 80a0be0:	080601cc 	.word	0x080601cc

080a0be4 <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
 80a0be4:	b508      	push	{r3, lr}
 80a0be6:	4b02      	ldr	r3, [pc, #8]	; (80a0bf0 <network_connect+0xc>)
 80a0be8:	681b      	ldr	r3, [r3, #0]
 80a0bea:	685b      	ldr	r3, [r3, #4]
 80a0bec:	9301      	str	r3, [sp, #4]
 80a0bee:	bd08      	pop	{r3, pc}
 80a0bf0:	080601c8 	.word	0x080601c8

080a0bf4 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
 80a0bf4:	b508      	push	{r3, lr}
 80a0bf6:	4b02      	ldr	r3, [pc, #8]	; (80a0c00 <network_connecting+0xc>)
 80a0bf8:	681b      	ldr	r3, [r3, #0]
 80a0bfa:	689b      	ldr	r3, [r3, #8]
 80a0bfc:	9301      	str	r3, [sp, #4]
 80a0bfe:	bd08      	pop	{r3, pc}
 80a0c00:	080601c8 	.word	0x080601c8

080a0c04 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
 80a0c04:	b508      	push	{r3, lr}
 80a0c06:	4b02      	ldr	r3, [pc, #8]	; (80a0c10 <network_disconnect+0xc>)
 80a0c08:	681b      	ldr	r3, [r3, #0]
 80a0c0a:	68db      	ldr	r3, [r3, #12]
 80a0c0c:	9301      	str	r3, [sp, #4]
 80a0c0e:	bd08      	pop	{r3, pc}
 80a0c10:	080601c8 	.word	0x080601c8

080a0c14 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a0c14:	b508      	push	{r3, lr}
 80a0c16:	4b02      	ldr	r3, [pc, #8]	; (80a0c20 <network_ready+0xc>)
 80a0c18:	681b      	ldr	r3, [r3, #0]
 80a0c1a:	691b      	ldr	r3, [r3, #16]
 80a0c1c:	9301      	str	r3, [sp, #4]
 80a0c1e:	bd08      	pop	{r3, pc}
 80a0c20:	080601c8 	.word	0x080601c8

080a0c24 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
 80a0c24:	b508      	push	{r3, lr}
 80a0c26:	4b02      	ldr	r3, [pc, #8]	; (80a0c30 <network_on+0xc>)
 80a0c28:	681b      	ldr	r3, [r3, #0]
 80a0c2a:	695b      	ldr	r3, [r3, #20]
 80a0c2c:	9301      	str	r3, [sp, #4]
 80a0c2e:	bd08      	pop	{r3, pc}
 80a0c30:	080601c8 	.word	0x080601c8

080a0c34 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
 80a0c34:	b508      	push	{r3, lr}
 80a0c36:	4b02      	ldr	r3, [pc, #8]	; (80a0c40 <network_off+0xc>)
 80a0c38:	681b      	ldr	r3, [r3, #0]
 80a0c3a:	699b      	ldr	r3, [r3, #24]
 80a0c3c:	9301      	str	r3, [sp, #4]
 80a0c3e:	bd08      	pop	{r3, pc}
 80a0c40:	080601c8 	.word	0x080601c8

080a0c44 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
 80a0c44:	b508      	push	{r3, lr}
 80a0c46:	4b02      	ldr	r3, [pc, #8]	; (80a0c50 <network_listen+0xc>)
 80a0c48:	681b      	ldr	r3, [r3, #0]
 80a0c4a:	69db      	ldr	r3, [r3, #28]
 80a0c4c:	9301      	str	r3, [sp, #4]
 80a0c4e:	bd08      	pop	{r3, pc}
 80a0c50:	080601c8 	.word	0x080601c8

080a0c54 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
 80a0c54:	b508      	push	{r3, lr}
 80a0c56:	4b02      	ldr	r3, [pc, #8]	; (80a0c60 <network_listening+0xc>)
 80a0c58:	681b      	ldr	r3, [r3, #0]
 80a0c5a:	6a1b      	ldr	r3, [r3, #32]
 80a0c5c:	9301      	str	r3, [sp, #4]
 80a0c5e:	bd08      	pop	{r3, pc}
 80a0c60:	080601c8 	.word	0x080601c8

080a0c64 <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
 80a0c64:	b508      	push	{r3, lr}
 80a0c66:	4b02      	ldr	r3, [pc, #8]	; (80a0c70 <network_set_listen_timeout+0xc>)
 80a0c68:	681b      	ldr	r3, [r3, #0]
 80a0c6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0c6c:	9301      	str	r3, [sp, #4]
 80a0c6e:	bd08      	pop	{r3, pc}
 80a0c70:	080601c8 	.word	0x080601c8

080a0c74 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
 80a0c74:	b508      	push	{r3, lr}
 80a0c76:	4b02      	ldr	r3, [pc, #8]	; (80a0c80 <network_get_listen_timeout+0xc>)
 80a0c78:	681b      	ldr	r3, [r3, #0]
 80a0c7a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0c7c:	9301      	str	r3, [sp, #4]
 80a0c7e:	bd08      	pop	{r3, pc}
 80a0c80:	080601c8 	.word	0x080601c8

080a0c84 <malloc>:
#include <assert.h>
#endif

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a0c84:	b508      	push	{r3, lr}
 80a0c86:	4b02      	ldr	r3, [pc, #8]	; (80a0c90 <malloc+0xc>)
 80a0c88:	681b      	ldr	r3, [r3, #0]
 80a0c8a:	681b      	ldr	r3, [r3, #0]
 80a0c8c:	9301      	str	r3, [sp, #4]
 80a0c8e:	bd08      	pop	{r3, pc}
 80a0c90:	080601a0 	.word	0x080601a0

080a0c94 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a0c94:	b508      	push	{r3, lr}
 80a0c96:	4b02      	ldr	r3, [pc, #8]	; (80a0ca0 <free+0xc>)
 80a0c98:	681b      	ldr	r3, [r3, #0]
 80a0c9a:	685b      	ldr	r3, [r3, #4]
 80a0c9c:	9301      	str	r3, [sp, #4]
 80a0c9e:	bd08      	pop	{r3, pc}
 80a0ca0:	080601a0 	.word	0x080601a0

080a0ca4 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a0ca4:	b508      	push	{r3, lr}
 80a0ca6:	4b02      	ldr	r3, [pc, #8]	; (80a0cb0 <realloc+0xc>)
 80a0ca8:	681b      	ldr	r3, [r3, #0]
 80a0caa:	689b      	ldr	r3, [r3, #8]
 80a0cac:	9301      	str	r3, [sp, #4]
 80a0cae:	bd08      	pop	{r3, pc}
 80a0cb0:	080601a0 	.word	0x080601a0

080a0cb4 <vsnprintf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a0cb4:	b508      	push	{r3, lr}
 80a0cb6:	4b02      	ldr	r3, [pc, #8]	; (80a0cc0 <vsnprintf+0xc>)
 80a0cb8:	681b      	ldr	r3, [r3, #0]
 80a0cba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0cbc:	9301      	str	r3, [sp, #4]
 80a0cbe:	bd08      	pop	{r3, pc}
 80a0cc0:	080601a0 	.word	0x080601a0

080a0cc4 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a0cc4:	2100      	movs	r1, #0
 80a0cc6:	f7ff bf69 	b.w	80a0b9c <system_delay_ms>

080a0cca <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0cca:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a0ccc:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0cce:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a0cd0:	b113      	cbz	r3, 80a0cd8 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a0cd2:	2203      	movs	r2, #3
 80a0cd4:	4601      	mov	r1, r0
 80a0cd6:	4798      	blx	r3
    }
 80a0cd8:	4620      	mov	r0, r4
 80a0cda:	bd10      	pop	{r4, pc}

080a0cdc <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a0cdc:	4770      	bx	lr

080a0cde <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a0cde:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0ce0:	4606      	mov	r6, r0
 80a0ce2:	4615      	mov	r5, r2
 80a0ce4:	460c      	mov	r4, r1
 80a0ce6:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a0ce8:	42bc      	cmp	r4, r7
 80a0cea:	d006      	beq.n	80a0cfa <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a0cec:	6833      	ldr	r3, [r6, #0]
 80a0cee:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a0cf2:	689b      	ldr	r3, [r3, #8]
 80a0cf4:	4630      	mov	r0, r6
 80a0cf6:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a0cf8:	e7f6      	b.n	80a0ce8 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a0cfa:	4628      	mov	r0, r5
 80a0cfc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0cfe <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a0cfe:	2200      	movs	r2, #0
 80a0d00:	7c00      	ldrb	r0, [r0, #16]
 80a0d02:	f7ff be29 	b.w	80a0958 <HAL_I2C_Write_Data>

080a0d06 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a0d06:	2100      	movs	r1, #0
 80a0d08:	7c00      	ldrb	r0, [r0, #16]
 80a0d0a:	f7ff be2d 	b.w	80a0968 <HAL_I2C_Available_Data>

080a0d0e <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a0d0e:	2100      	movs	r1, #0
 80a0d10:	7c00      	ldrb	r0, [r0, #16]
 80a0d12:	f7ff be31 	b.w	80a0978 <HAL_I2C_Read_Data>

080a0d16 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a0d16:	2100      	movs	r1, #0
 80a0d18:	7c00      	ldrb	r0, [r0, #16]
 80a0d1a:	f7ff be35 	b.w	80a0988 <HAL_I2C_Peek_Data>

080a0d1e <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a0d1e:	2100      	movs	r1, #0
 80a0d20:	7c00      	ldrb	r0, [r0, #16]
 80a0d22:	f7ff be39 	b.w	80a0998 <HAL_I2C_Flush_Data>

080a0d26 <_ZN7TwoWireD0Ev>:
 80a0d26:	b510      	push	{r4, lr}
 80a0d28:	4604      	mov	r4, r0
 80a0d2a:	2114      	movs	r1, #20
 80a0d2c:	f001 f905 	bl	80a1f3a <_ZdlPvj>
 80a0d30:	4620      	mov	r0, r4
 80a0d32:	bd10      	pop	{r4, pc}

080a0d34 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a0d34:	b510      	push	{r4, lr}
 80a0d36:	4604      	mov	r4, r0
 80a0d38:	4608      	mov	r0, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a0d3a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a0d3e:	60a3      	str	r3, [r4, #8]
 80a0d40:	4b04      	ldr	r3, [pc, #16]	; (80a0d54 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0d42:	2100      	movs	r1, #0
{
  _i2c = i2c;
 80a0d44:	7420      	strb	r0, [r4, #16]
 80a0d46:	6061      	str	r1, [r4, #4]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a0d48:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, NULL);
 80a0d4a:	f7ff fe35 	bl	80a09b8 <HAL_I2C_Init>

}
 80a0d4e:	4620      	mov	r0, r4
 80a0d50:	bd10      	pop	{r4, pc}
 80a0d52:	bf00      	nop
 80a0d54:	080a7810 	.word	0x080a7810

080a0d58 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a0d58:	2100      	movs	r1, #0
 80a0d5a:	7c00      	ldrb	r0, [r0, #16]
 80a0d5c:	f7ff be24 	b.w	80a09a8 <HAL_I2C_Is_Enabled>

080a0d60 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a0d60:	4770      	bx	lr

080a0d62 <_ZN9IPAddressD0Ev>:
 80a0d62:	b510      	push	{r4, lr}
 80a0d64:	4604      	mov	r4, r0
 80a0d66:	2118      	movs	r1, #24
 80a0d68:	f001 f8e7 	bl	80a1f3a <_ZdlPvj>
 80a0d6c:	4620      	mov	r0, r4
 80a0d6e:	bd10      	pop	{r4, pc}

080a0d70 <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a0d70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0d72:	460f      	mov	r7, r1
 80a0d74:	f100 0608 	add.w	r6, r0, #8
 80a0d78:	1d05      	adds	r5, r0, #4
 80a0d7a:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0d7c:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a0d80:	220a      	movs	r2, #10
 80a0d82:	4638      	mov	r0, r7
 80a0d84:	f000 f937 	bl	80a0ff6 <_ZN5Print5printEhi>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0d88:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0d8a:	4404      	add	r4, r0
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0d8c:	d007      	beq.n	80a0d9e <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a0d8e:	2c00      	cmp	r4, #0
 80a0d90:	d0f4      	beq.n	80a0d7c <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a0d92:	212e      	movs	r1, #46	; 0x2e
 80a0d94:	4638      	mov	r0, r7
 80a0d96:	f000 f8eb 	bl	80a0f70 <_ZN5Print5printEc>
 80a0d9a:	4404      	add	r4, r0
 80a0d9c:	e7ee      	b.n	80a0d7c <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a0d9e:	4620      	mov	r0, r4
 80a0da0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080a0da4 <_ZN9IPAddressC1Ev>:

#if HAL_USE_INET_HAL_POSIX
#include <arpa/inet.h>
#endif // HAL_USE_INET_HAL_POSIX

IPAddress::IPAddress()
 80a0da4:	b510      	push	{r4, lr}
 80a0da6:	4604      	mov	r4, r0
 80a0da8:	4b04      	ldr	r3, [pc, #16]	; (80a0dbc <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a0daa:	2211      	movs	r2, #17
 80a0dac:	f840 3b04 	str.w	r3, [r0], #4
 80a0db0:	2100      	movs	r1, #0
 80a0db2:	f001 fa3a 	bl	80a222a <memset>
{
    clear();
}
 80a0db6:	4620      	mov	r0, r4
 80a0db8:	bd10      	pop	{r4, pc}
 80a0dba:	bf00      	nop
 80a0dbc:	080a7838 	.word	0x080a7838

080a0dc0 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:

IPAddress::IPAddress(const HAL_IPAddress& address)
 80a0dc0:	4603      	mov	r3, r0
 80a0dc2:	4a07      	ldr	r2, [pc, #28]	; (80a0de0 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
 80a0dc4:	b510      	push	{r4, lr}
 80a0dc6:	f843 2b04 	str.w	r2, [r3], #4
{
    memcpy(&this->address, &address, sizeof(address));
 80a0dca:	f101 0210 	add.w	r2, r1, #16
 80a0dce:	f851 4b04 	ldr.w	r4, [r1], #4
 80a0dd2:	4291      	cmp	r1, r2
 80a0dd4:	f843 4b04 	str.w	r4, [r3], #4
 80a0dd8:	d1f9      	bne.n	80a0dce <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
 80a0dda:	780a      	ldrb	r2, [r1, #0]
 80a0ddc:	701a      	strb	r2, [r3, #0]
}
 80a0dde:	bd10      	pop	{r4, pc}
 80a0de0:	080a7838 	.word	0x080a7838

080a0de4 <_ZN9IPAddressC1Em>:
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
}

IPAddress::IPAddress(uint32_t address)
 80a0de4:	4a02      	ldr	r2, [pc, #8]	; (80a0df0 <_ZN9IPAddressC1Em+0xc>)
    return *this;
}

IPAddress& IPAddress::operator=(uint32_t ipv4)
{
    address.ipv4 = ipv4;
 80a0de6:	6041      	str	r1, [r0, #4]
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
}

IPAddress::IPAddress(uint32_t address)
 80a0de8:	6002      	str	r2, [r0, #0]
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a0dea:	2204      	movs	r2, #4
 80a0dec:	7502      	strb	r2, [r0, #20]
{
    *this = address;
}
 80a0dee:	4770      	bx	lr
 80a0df0:	080a7838 	.word	0x080a7838

080a0df4 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a0df4:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a0df6:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a0dfa:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a0dfe:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a0e02:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
 80a0e06:	2304      	movs	r3, #4
 80a0e08:	6041      	str	r1, [r0, #4]
 80a0e0a:	7503      	strb	r3, [r0, #20]
 80a0e0c:	bd10      	pop	{r4, pc}
	...

080a0e10 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a0e10:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0e12:	4d04      	ldr	r5, [pc, #16]	; (80a0e24 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a0e14:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a0e16:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a0e1a:	9500      	str	r5, [sp, #0]
 80a0e1c:	f7ff ffea 	bl	80a0df4 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a0e20:	b003      	add	sp, #12
 80a0e22:	bd30      	pop	{r4, r5, pc}
 80a0e24:	080a7838 	.word	0x080a7838

080a0e28 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a0e28:	4a01      	ldr	r2, [pc, #4]	; (80a0e30 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a0e2a:	4b02      	ldr	r3, [pc, #8]	; (80a0e34 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a0e2c:	601a      	str	r2, [r3, #0]
 80a0e2e:	4770      	bx	lr
 80a0e30:	080a78ba 	.word	0x080a78ba
 80a0e34:	200001b0 	.word	0x200001b0

080a0e38 <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
 80a0e38:	2300      	movs	r3, #0
 80a0e3a:	461a      	mov	r2, r3
 80a0e3c:	6840      	ldr	r0, [r0, #4]
 80a0e3e:	f7ff bed1 	b.w	80a0be4 <network_connect>

080a0e42 <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
 80a0e42:	2200      	movs	r2, #0
 80a0e44:	2102      	movs	r1, #2
 80a0e46:	6840      	ldr	r0, [r0, #4]
 80a0e48:	f7ff bedc 	b.w	80a0c04 <network_disconnect>

080a0e4c <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
 80a0e4c:	2200      	movs	r2, #0
 80a0e4e:	4611      	mov	r1, r2
 80a0e50:	6840      	ldr	r0, [r0, #4]
 80a0e52:	f7ff becf 	b.w	80a0bf4 <network_connecting>

080a0e56 <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
 80a0e56:	2200      	movs	r2, #0
 80a0e58:	4611      	mov	r1, r2
 80a0e5a:	6840      	ldr	r0, [r0, #4]
 80a0e5c:	f7ff beda 	b.w	80a0c14 <network_ready>

080a0e60 <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
 80a0e60:	2300      	movs	r3, #0
 80a0e62:	461a      	mov	r2, r3
 80a0e64:	4619      	mov	r1, r3
 80a0e66:	6840      	ldr	r0, [r0, #4]
 80a0e68:	f7ff bedc 	b.w	80a0c24 <network_on>

080a0e6c <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
 80a0e6c:	2300      	movs	r3, #0
 80a0e6e:	461a      	mov	r2, r3
 80a0e70:	4619      	mov	r1, r3
 80a0e72:	6840      	ldr	r0, [r0, #4]
 80a0e74:	f7ff bede 	b.w	80a0c34 <network_off>

080a0e78 <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
 80a0e78:	2200      	movs	r2, #0
 80a0e7a:	f081 0101 	eor.w	r1, r1, #1
 80a0e7e:	6840      	ldr	r0, [r0, #4]
 80a0e80:	f7ff bee0 	b.w	80a0c44 <network_listen>

080a0e84 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
 80a0e84:	2200      	movs	r2, #0
 80a0e86:	6840      	ldr	r0, [r0, #4]
 80a0e88:	f7ff beec 	b.w	80a0c64 <network_set_listen_timeout>

080a0e8c <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
 80a0e8c:	2200      	movs	r2, #0
 80a0e8e:	4611      	mov	r1, r2
 80a0e90:	6840      	ldr	r0, [r0, #4]
 80a0e92:	f7ff beef 	b.w	80a0c74 <network_get_listen_timeout>

080a0e96 <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
 80a0e96:	2200      	movs	r2, #0
 80a0e98:	4611      	mov	r1, r2
 80a0e9a:	6840      	ldr	r0, [r0, #4]
 80a0e9c:	f7ff beda 	b.w	80a0c54 <network_listening>

080a0ea0 <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
 80a0ea0:	b570      	push	{r4, r5, r6, lr}
 80a0ea2:	4616      	mov	r6, r2
 80a0ea4:	b08e      	sub	sp, #56	; 0x38
 80a0ea6:	4604      	mov	r4, r0
    IPAddress addr;
 80a0ea8:	a808      	add	r0, sp, #32
 80a0eaa:	f7ff ff7b 	bl	80a0da4 <_ZN9IPAddressC1Ev>
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
    {
        HAL_IPAddress ip = {};
 80a0eae:	2211      	movs	r2, #17
 80a0eb0:	2100      	movs	r1, #0
 80a0eb2:	a803      	add	r0, sp, #12
 80a0eb4:	f001 f9b9 	bl	80a222a <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a0eb8:	4630      	mov	r0, r6
 80a0eba:	f001 f9f9 	bl	80a22b0 <strlen>
 80a0ebe:	2500      	movs	r5, #0
 80a0ec0:	4b0a      	ldr	r3, [pc, #40]	; (80a0eec <_ZN5spark12NetworkClass7resolveEPKc+0x4c>)
 80a0ec2:	9500      	str	r5, [sp, #0]
 80a0ec4:	b281      	uxth	r1, r0
 80a0ec6:	685b      	ldr	r3, [r3, #4]
 80a0ec8:	aa03      	add	r2, sp, #12
 80a0eca:	4630      	mov	r0, r6
 80a0ecc:	f7ff fe46 	bl	80a0b5c <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a0ed0:	b120      	cbz	r0, 80a0edc <_ZN5spark12NetworkClass7resolveEPKc+0x3c>
 80a0ed2:	4629      	mov	r1, r5
 80a0ed4:	4620      	mov	r0, r4
 80a0ed6:	f7ff ff85 	bl	80a0de4 <_ZN9IPAddressC1Em>
 80a0eda:	e003      	b.n	80a0ee4 <_ZN5spark12NetworkClass7resolveEPKc+0x44>
 80a0edc:	a903      	add	r1, sp, #12
 80a0ede:	4620      	mov	r0, r4
 80a0ee0:	f7ff ff6e 	bl	80a0dc0 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
 80a0ee4:	4620      	mov	r0, r4
 80a0ee6:	b00e      	add	sp, #56	; 0x38
 80a0ee8:	bd70      	pop	{r4, r5, r6, pc}
 80a0eea:	bf00      	nop
 80a0eec:	20000634 	.word	0x20000634

080a0ef0 <_ZN5spark12NetworkClass4fromEm>:
        return Cellular;
#endif
    default:
        return Network;
    }
}
 80a0ef0:	4b03      	ldr	r3, [pc, #12]	; (80a0f00 <_ZN5spark12NetworkClass4fromEm+0x10>)
 80a0ef2:	4a04      	ldr	r2, [pc, #16]	; (80a0f04 <_ZN5spark12NetworkClass4fromEm+0x14>)
 80a0ef4:	2804      	cmp	r0, #4
 80a0ef6:	bf0c      	ite	eq
 80a0ef8:	4610      	moveq	r0, r2
 80a0efa:	4618      	movne	r0, r3
 80a0efc:	4770      	bx	lr
 80a0efe:	bf00      	nop
 80a0f00:	200001b4 	.word	0x200001b4
 80a0f04:	20000634 	.word	0x20000634

080a0f08 <_GLOBAL__sub_I__ZN5spark7NetworkE>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
 80a0f08:	4b02      	ldr	r3, [pc, #8]	; (80a0f14 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
 80a0f0a:	4a03      	ldr	r2, [pc, #12]	; (80a0f18 <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
 80a0f0c:	601a      	str	r2, [r3, #0]
 80a0f0e:	2200      	movs	r2, #0
 80a0f10:	605a      	str	r2, [r3, #4]
 80a0f12:	4770      	bx	lr
 80a0f14:	200001b4 	.word	0x200001b4
 80a0f18:	080a7928 	.word	0x080a7928

080a0f1c <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a0f1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0f1e:	4606      	mov	r6, r0
 80a0f20:	460d      	mov	r5, r1
 80a0f22:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a0f24:	2400      	movs	r4, #0
  while (size--) {
 80a0f26:	42bd      	cmp	r5, r7
 80a0f28:	d00c      	beq.n	80a0f44 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a0f2a:	6833      	ldr	r3, [r6, #0]
 80a0f2c:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a0f30:	689b      	ldr	r3, [r3, #8]
 80a0f32:	4630      	mov	r0, r6
 80a0f34:	4798      	blx	r3
     if (chunk>=0)
 80a0f36:	2800      	cmp	r0, #0
 80a0f38:	db01      	blt.n	80a0f3e <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a0f3a:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a0f3c:	e7f3      	b.n	80a0f26 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a0f3e:	2c00      	cmp	r4, #0
 80a0f40:	bf08      	it	eq
 80a0f42:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a0f44:	4620      	mov	r0, r4
 80a0f46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0f48 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a0f48:	b570      	push	{r4, r5, r6, lr}
 80a0f4a:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a0f4c:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a0f4e:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a0f50:	b149      	cbz	r1, 80a0f66 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a0f52:	f001 f9ad 	bl	80a22b0 <strlen>
 80a0f56:	682b      	ldr	r3, [r5, #0]
 80a0f58:	4602      	mov	r2, r0
 80a0f5a:	4621      	mov	r1, r4
 80a0f5c:	4628      	mov	r0, r5
    }
 80a0f5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a0f62:	68db      	ldr	r3, [r3, #12]
 80a0f64:	4718      	bx	r3
    }
 80a0f66:	bd70      	pop	{r4, r5, r6, pc}

080a0f68 <_ZN5Print5printEPKc>:
 80a0f68:	b508      	push	{r3, lr}
 80a0f6a:	f7ff ffed 	bl	80a0f48 <_ZN5Print5writeEPKc>
 80a0f6e:	bd08      	pop	{r3, pc}

080a0f70 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a0f70:	6803      	ldr	r3, [r0, #0]
 80a0f72:	689b      	ldr	r3, [r3, #8]
 80a0f74:	4718      	bx	r3

080a0f76 <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a0f76:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a0f78:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a0f7a:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a0f7c:	f7ff fff8 	bl	80a0f70 <_ZN5Print5printEc>
  n += print('\n');
 80a0f80:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a0f82:	4604      	mov	r4, r0
  n += print('\n');
 80a0f84:	4628      	mov	r0, r5
 80a0f86:	f7ff fff3 	bl	80a0f70 <_ZN5Print5printEc>
  return n;
}
 80a0f8a:	4420      	add	r0, r4
 80a0f8c:	bd38      	pop	{r3, r4, r5, pc}

080a0f8e <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a0f8e:	b538      	push	{r3, r4, r5, lr}
 80a0f90:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a0f92:	f7ff ffd9 	bl	80a0f48 <_ZN5Print5writeEPKc>
 80a0f96:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a0f98:	4628      	mov	r0, r5
 80a0f9a:	f7ff ffec 	bl	80a0f76 <_ZN5Print7printlnEv>
  return n;
}
 80a0f9e:	4420      	add	r0, r4
 80a0fa0:	bd38      	pop	{r3, r4, r5, pc}

080a0fa2 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a0fa2:	2a01      	cmp	r2, #1
 80a0fa4:	bf98      	it	ls
 80a0fa6:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a0fa8:	b530      	push	{r4, r5, lr}
 80a0faa:	460b      	mov	r3, r1
 80a0fac:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a0fae:	2100      	movs	r1, #0
 80a0fb0:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a0fb4:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a0fb8:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a0fbc:	fb05 3312 	mls	r3, r5, r2, r3
 80a0fc0:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a0fc2:	2b09      	cmp	r3, #9
 80a0fc4:	bf94      	ite	ls
 80a0fc6:	3330      	addls	r3, #48	; 0x30
 80a0fc8:	3337      	addhi	r3, #55	; 0x37
 80a0fca:	b2db      	uxtb	r3, r3
 80a0fcc:	4621      	mov	r1, r4
 80a0fce:	f804 3901 	strb.w	r3, [r4], #-1
 80a0fd2:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a0fd4:	2d00      	cmp	r5, #0
 80a0fd6:	d1ef      	bne.n	80a0fb8 <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a0fd8:	f7ff ffb6 	bl	80a0f48 <_ZN5Print5writeEPKc>
}
 80a0fdc:	b00b      	add	sp, #44	; 0x2c
 80a0fde:	bd30      	pop	{r4, r5, pc}

080a0fe0 <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a0fe0:	b410      	push	{r4}
  if (base == 0) return write(n);
 80a0fe2:	b922      	cbnz	r2, 80a0fee <_ZN5Print5printEmi+0xe>
 80a0fe4:	6803      	ldr	r3, [r0, #0]
 80a0fe6:	b2c9      	uxtb	r1, r1
 80a0fe8:	689b      	ldr	r3, [r3, #8]
  else return printNumber(n, base);
}
 80a0fea:	bc10      	pop	{r4}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a0fec:	4718      	bx	r3
  else return printNumber(n, base);
 80a0fee:	b2d2      	uxtb	r2, r2
}
 80a0ff0:	bc10      	pop	{r4}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a0ff2:	f7ff bfd6 	b.w	80a0fa2 <_ZN5Print11printNumberEmh>

080a0ff6 <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a0ff6:	f7ff bff3 	b.w	80a0fe0 <_ZN5Print5printEmi>

080a0ffa <_ZN5Print7printlnEji>:
  n += println();
  return n;
}

size_t Print::println(unsigned int num, int base)
{
 80a0ffa:	b538      	push	{r3, r4, r5, lr}
 80a0ffc:	4605      	mov	r5, r0
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base)
{
  return print((unsigned long) n, base);
 80a0ffe:	f7ff ffef 	bl	80a0fe0 <_ZN5Print5printEmi>
 80a1002:	4604      	mov	r4, r0
}

size_t Print::println(unsigned int num, int base)
{
  size_t n = print(num, base);
  n += println();
 80a1004:	4628      	mov	r0, r5
 80a1006:	f7ff ffb6 	bl	80a0f76 <_ZN5Print7printlnEv>
  return n;
}
 80a100a:	4420      	add	r0, r4
 80a100c:	bd38      	pop	{r3, r4, r5, pc}

080a100e <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
 80a100e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a1012:	4607      	mov	r7, r0
 80a1014:	460e      	mov	r6, r1
  if (base == 0) {
 80a1016:	4615      	mov	r5, r2
 80a1018:	b92a      	cbnz	r2, 80a1026 <_ZN5Print5printEli+0x18>
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 80a101a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
 80a101e:	6803      	ldr	r3, [r0, #0]
 80a1020:	b2c9      	uxtb	r1, r1
 80a1022:	689b      	ldr	r3, [r3, #8]
 80a1024:	4718      	bx	r3
  } else if (base == 10) {
 80a1026:	2a0a      	cmp	r2, #10
 80a1028:	d102      	bne.n	80a1030 <_ZN5Print5printEli+0x22>
    if (n < 0) {
 80a102a:	2900      	cmp	r1, #0
 80a102c:	da01      	bge.n	80a1032 <_ZN5Print5printEli+0x24>
 80a102e:	e004      	b.n	80a103a <_ZN5Print5printEli+0x2c>
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
 80a1030:	b2d2      	uxtb	r2, r2
  }
}
 80a1032:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
 80a1036:	f7ff bfb4 	b.w	80a0fa2 <_ZN5Print11printNumberEmh>
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
 80a103a:	212d      	movs	r1, #45	; 0x2d
 80a103c:	f7ff ff98 	bl	80a0f70 <_ZN5Print5printEc>
      n = -n;
      return printNumber(n, 10) + t;
 80a1040:	462a      	mov	r2, r5
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
 80a1042:	4604      	mov	r4, r0
      n = -n;
      return printNumber(n, 10) + t;
 80a1044:	4271      	negs	r1, r6
 80a1046:	4638      	mov	r0, r7
 80a1048:	f7ff ffab 	bl	80a0fa2 <_ZN5Print11printNumberEmh>
 80a104c:	4420      	add	r0, r4
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 80a104e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a1052 <_ZN5Print7printlnEli>:
  n += println();
  return n;
}

size_t Print::println(long num, int base)
{
 80a1052:	b538      	push	{r3, r4, r5, lr}
 80a1054:	4605      	mov	r5, r0
  size_t n = print(num, base);
 80a1056:	f7ff ffda 	bl	80a100e <_ZN5Print5printEli>
 80a105a:	4604      	mov	r4, r0
  n += println();
 80a105c:	4628      	mov	r0, r5
 80a105e:	f7ff ff8a 	bl	80a0f76 <_ZN5Print7printlnEv>
  return n;
}
 80a1062:	4420      	add	r0, r4
 80a1064:	bd38      	pop	{r3, r4, r5, pc}

080a1066 <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a1066:	b40c      	push	{r2, r3}
 80a1068:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a106c:	b087      	sub	sp, #28
 80a106e:	af00      	add	r7, sp, #0
 80a1070:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a1074:	f854 9b04 	ldr.w	r9, [r4], #4
 80a1078:	4605      	mov	r5, r0
 80a107a:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a107c:	4623      	mov	r3, r4
 80a107e:	464a      	mov	r2, r9
 80a1080:	2114      	movs	r1, #20
 80a1082:	1d38      	adds	r0, r7, #4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a1084:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a1086:	f7ff fe15 	bl	80a0cb4 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a108a:	2813      	cmp	r0, #19
 80a108c:	d805      	bhi.n	80a109a <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a108e:	1d39      	adds	r1, r7, #4
 80a1090:	4628      	mov	r0, r5
 80a1092:	f7ff ff59 	bl	80a0f48 <_ZN5Print5writeEPKc>
 80a1096:	4604      	mov	r4, r0
 80a1098:	e013      	b.n	80a10c2 <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a109a:	f100 0308 	add.w	r3, r0, #8
 80a109e:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
 80a10a2:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a10a4:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a10a8:	1c41      	adds	r1, r0, #1
 80a10aa:	4623      	mov	r3, r4
 80a10ac:	464a      	mov	r2, r9
 80a10ae:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a10b0:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a10b2:	f7ff fdff 	bl	80a0cb4 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a10b6:	4669      	mov	r1, sp
 80a10b8:	4628      	mov	r0, r5
 80a10ba:	f7ff ff45 	bl	80a0f48 <_ZN5Print5writeEPKc>
 80a10be:	4604      	mov	r4, r0
 80a10c0:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a10c2:	b11e      	cbz	r6, 80a10cc <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
 80a10c4:	4628      	mov	r0, r5
 80a10c6:	f7ff ff56 	bl	80a0f76 <_ZN5Print7printlnEv>
 80a10ca:	4404      	add	r4, r0
    return n;
}
 80a10cc:	4620      	mov	r0, r4
 80a10ce:	371c      	adds	r7, #28
 80a10d0:	46bd      	mov	sp, r7
 80a10d2:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a10d6:	b002      	add	sp, #8
 80a10d8:	4770      	bx	lr

080a10da <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a10da:	b510      	push	{r4, lr}
 80a10dc:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a10de:	f7ff fdf4 	bl	80a0cca <_ZNSt14_Function_baseD1Ev>
 80a10e2:	4620      	mov	r0, r4
 80a10e4:	bd10      	pop	{r4, pc}
	...

080a10e8 <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a10e8:	4803      	ldr	r0, [pc, #12]	; (80a10f8 <_GLOBAL__sub_I_RGB+0x10>)
 80a10ea:	2300      	movs	r3, #0
 80a10ec:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a10ee:	4a03      	ldr	r2, [pc, #12]	; (80a10fc <_GLOBAL__sub_I_RGB+0x14>)
 80a10f0:	4903      	ldr	r1, [pc, #12]	; (80a1100 <_GLOBAL__sub_I_RGB+0x18>)
 80a10f2:	f000 bf1d 	b.w	80a1f30 <__aeabi_atexit>
 80a10f6:	bf00      	nop
 80a10f8:	200001bc 	.word	0x200001bc
 80a10fc:	20000140 	.word	0x20000140
 80a1100:	080a10db 	.word	0x080a10db

080a1104 <_ZN8SPIClassD1Ev>:
  Mutex mutex_;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a1104:	4770      	bx	lr

080a1106 <_ZN8SPIClassD0Ev>:
 80a1106:	b510      	push	{r4, lr}
 80a1108:	4604      	mov	r4, r0
 80a110a:	2110      	movs	r1, #16
 80a110c:	f000 ff15 	bl	80a1f3a <_ZdlPvj>
 80a1110:	4620      	mov	r0, r4
 80a1112:	bd10      	pop	{r4, pc}

080a1114 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
  if (!info->enabled || info->default_settings)
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a1114:	b570      	push	{r4, r5, r6, lr}
 80a1116:	4604      	mov	r4, r0
 80a1118:	460e      	mov	r6, r1
 80a111a:	4b07      	ldr	r3, [pc, #28]	; (80a1138 <_ZN8SPIClassC1E17HAL_SPI_Interface+0x24>)
    Mutex(os_mutex_t handle) : handle_(handle) {}

    /**
     * Creates a new mutex.
     */
    Mutex() : handle_(nullptr)
 80a111c:	2500      	movs	r5, #0
 80a111e:	6003      	str	r3, [r0, #0]
 80a1120:	f840 5f0c 	str.w	r5, [r0, #12]!
    {
        os_mutex_create(&handle_);
 80a1124:	f7ff fba0 	bl	80a0868 <os_mutex_create>
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a1128:	4630      	mov	r0, r6
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
  _spi = spi;
 80a112a:	7126      	strb	r6, [r4, #4]
  HAL_SPI_Init(_spi);
 80a112c:	f7ff fc8e 	bl	80a0a4c <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a1130:	60a5      	str	r5, [r4, #8]
}
 80a1132:	4620      	mov	r0, r4
 80a1134:	bd70      	pop	{r4, r5, r6, pc}
 80a1136:	bf00      	nop
 80a1138:	080a795c 	.word	0x080a795c

080a113c <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a113c:	7900      	ldrb	r0, [r0, #4]
 80a113e:	f7ff bc8d 	b.w	80a0a5c <HAL_SPI_Is_Enabled>

080a1142 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a1142:	b510      	push	{r4, lr}
 80a1144:	4604      	mov	r4, r0
{
	free(buffer);
 80a1146:	6800      	ldr	r0, [r0, #0]
 80a1148:	f7ff fda4 	bl	80a0c94 <free>
}
 80a114c:	4620      	mov	r0, r4
 80a114e:	bd10      	pop	{r4, pc}

080a1150 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a1150:	b510      	push	{r4, lr}
 80a1152:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a1154:	6800      	ldr	r0, [r0, #0]
 80a1156:	b108      	cbz	r0, 80a115c <_ZN6String10invalidateEv+0xc>
 80a1158:	f7ff fd9c 	bl	80a0c94 <free>
	buffer = NULL;
 80a115c:	2300      	movs	r3, #0
 80a115e:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a1160:	60a3      	str	r3, [r4, #8]
 80a1162:	6063      	str	r3, [r4, #4]
 80a1164:	bd10      	pop	{r4, pc}

080a1166 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a1166:	b538      	push	{r3, r4, r5, lr}
 80a1168:	4604      	mov	r4, r0
 80a116a:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a116c:	6800      	ldr	r0, [r0, #0]
 80a116e:	3101      	adds	r1, #1
 80a1170:	f7ff fd98 	bl	80a0ca4 <realloc>
	if (newbuffer) {
 80a1174:	b110      	cbz	r0, 80a117c <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a1176:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a117a:	2001      	movs	r0, #1
	}
	return 0;
}
 80a117c:	bd38      	pop	{r3, r4, r5, pc}

080a117e <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a117e:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a1180:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a1182:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a1184:	b113      	cbz	r3, 80a118c <_ZN6String7reserveEj+0xe>
 80a1186:	6843      	ldr	r3, [r0, #4]
 80a1188:	428b      	cmp	r3, r1
 80a118a:	d207      	bcs.n	80a119c <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a118c:	4620      	mov	r0, r4
 80a118e:	f7ff ffea 	bl	80a1166 <_ZN6String12changeBufferEj>
 80a1192:	b120      	cbz	r0, 80a119e <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a1194:	68a3      	ldr	r3, [r4, #8]
 80a1196:	b90b      	cbnz	r3, 80a119c <_ZN6String7reserveEj+0x1e>
 80a1198:	6822      	ldr	r2, [r4, #0]
 80a119a:	7013      	strb	r3, [r2, #0]
 80a119c:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a119e:	bd10      	pop	{r4, pc}

080a11a0 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a11a0:	b570      	push	{r4, r5, r6, lr}
 80a11a2:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a11a4:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a11a6:	4604      	mov	r4, r0
 80a11a8:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a11aa:	f7ff ffe8 	bl	80a117e <_ZN6String7reserveEj>
 80a11ae:	b918      	cbnz	r0, 80a11b8 <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a11b0:	4620      	mov	r0, r4
 80a11b2:	f7ff ffcd 	bl	80a1150 <_ZN6String10invalidateEv>
		return *this;
 80a11b6:	e009      	b.n	80a11cc <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a11b8:	462a      	mov	r2, r5
 80a11ba:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a11bc:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a11be:	6820      	ldr	r0, [r4, #0]
 80a11c0:	f001 f828 	bl	80a2214 <memcpy>
	buffer[len] = 0;
 80a11c4:	6822      	ldr	r2, [r4, #0]
 80a11c6:	68a3      	ldr	r3, [r4, #8]
 80a11c8:	2100      	movs	r1, #0
 80a11ca:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a11cc:	4620      	mov	r0, r4
 80a11ce:	bd70      	pop	{r4, r5, r6, pc}

080a11d0 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a11d0:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a11d2:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a11d4:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a11d6:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a11d8:	6043      	str	r3, [r0, #4]
	len = 0;
 80a11da:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a11dc:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a11de:	460d      	mov	r5, r1
 80a11e0:	b139      	cbz	r1, 80a11f2 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a11e2:	4608      	mov	r0, r1
 80a11e4:	f001 f864 	bl	80a22b0 <strlen>
 80a11e8:	4629      	mov	r1, r5
 80a11ea:	4602      	mov	r2, r0
 80a11ec:	4620      	mov	r0, r4
 80a11ee:	f7ff ffd7 	bl	80a11a0 <_ZN6String4copyEPKcj>
}
 80a11f2:	4620      	mov	r0, r4
 80a11f4:	bd38      	pop	{r3, r4, r5, pc}

080a11f6 <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
 80a11f6:	b538      	push	{r3, r4, r5, lr}
 80a11f8:	4605      	mov	r5, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a11fa:	460c      	mov	r4, r1
 80a11fc:	b141      	cbz	r1, 80a1210 <_ZN6StringaSEPKc+0x1a>
 80a11fe:	4608      	mov	r0, r1
 80a1200:	f001 f856 	bl	80a22b0 <strlen>
 80a1204:	4621      	mov	r1, r4
 80a1206:	4602      	mov	r2, r0
 80a1208:	4628      	mov	r0, r5
 80a120a:	f7ff ffc9 	bl	80a11a0 <_ZN6String4copyEPKcj>
 80a120e:	e001      	b.n	80a1214 <_ZN6StringaSEPKc+0x1e>
	else invalidate();
 80a1210:	f7ff ff9e 	bl	80a1150 <_ZN6String10invalidateEv>

	return *this;
}
 80a1214:	4628      	mov	r0, r5
 80a1216:	bd38      	pop	{r3, r4, r5, pc}

080a1218 <_ZN6StringC1Elh>:
	char buf[33];
	utoa(value, buf, base);
	*this = buf;
}

String::String(long value, unsigned char base)
 80a1218:	b510      	push	{r4, lr}
 80a121a:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a121c:	2300      	movs	r3, #0
	char buf[33];
	utoa(value, buf, base);
	*this = buf;
}

String::String(long value, unsigned char base)
 80a121e:	b08a      	sub	sp, #40	; 0x28
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a1220:	6023      	str	r3, [r4, #0]
	capacity = 0;
 80a1222:	6063      	str	r3, [r4, #4]
	len = 0;
 80a1224:	60a3      	str	r3, [r4, #8]
	flags = 0;
 80a1226:	7323      	strb	r3, [r4, #12]
	char buf[33];
	utoa(value, buf, base);
	*this = buf;
}

String::String(long value, unsigned char base)
 80a1228:	4608      	mov	r0, r1
{
	init();
	char buf[34];
	ltoa(value, buf, base);
 80a122a:	a901      	add	r1, sp, #4
 80a122c:	f000 fcaf 	bl	80a1b8e <ltoa>
	*this = buf;
 80a1230:	a901      	add	r1, sp, #4
 80a1232:	4620      	mov	r0, r4
 80a1234:	f7ff ffdf 	bl	80a11f6 <_ZN6StringaSEPKc>
}
 80a1238:	4620      	mov	r0, r4
 80a123a:	b00a      	add	sp, #40	; 0x28
 80a123c:	bd10      	pop	{r4, pc}

080a123e <_ZN6StringC1Emh>:

String::String(unsigned long value, unsigned char base)
 80a123e:	b510      	push	{r4, lr}
 80a1240:	4604      	mov	r4, r0
 80a1242:	b08a      	sub	sp, #40	; 0x28
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a1244:	2300      	movs	r3, #0
 80a1246:	6023      	str	r3, [r4, #0]
	capacity = 0;
 80a1248:	6063      	str	r3, [r4, #4]
	len = 0;
 80a124a:	60a3      	str	r3, [r4, #8]
	flags = 0;
 80a124c:	7323      	strb	r3, [r4, #12]
	char buf[34];
	ltoa(value, buf, base);
	*this = buf;
}

String::String(unsigned long value, unsigned char base)
 80a124e:	4608      	mov	r0, r1
{
	init();
	char buf[33];
	ultoa(value, buf, base);
 80a1250:	2301      	movs	r3, #1
 80a1252:	a901      	add	r1, sp, #4
 80a1254:	f000 fcd9 	bl	80a1c0a <ultoa>
	*this = buf;
 80a1258:	a901      	add	r1, sp, #4
 80a125a:	4620      	mov	r0, r4
 80a125c:	f7ff ffcb 	bl	80a11f6 <_ZN6StringaSEPKc>
}
 80a1260:	4620      	mov	r0, r4
 80a1262:	b00a      	add	sp, #40	; 0x28
 80a1264:	bd10      	pop	{r4, pc}

080a1266 <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
 80a1266:	b570      	push	{r4, r5, r6, lr}
 80a1268:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
	if (!cstr) return 0;
 80a126a:	460e      	mov	r6, r1
 80a126c:	b909      	cbnz	r1, 80a1272 <_ZN6String6concatEPKcj+0xc>
 80a126e:	2000      	movs	r0, #0
 80a1270:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
 80a1272:	b16a      	cbz	r2, 80a1290 <_ZN6String6concatEPKcj+0x2a>
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
 80a1274:	6883      	ldr	r3, [r0, #8]
 80a1276:	18d5      	adds	r5, r2, r3
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
 80a1278:	4629      	mov	r1, r5
 80a127a:	f7ff ff80 	bl	80a117e <_ZN6String7reserveEj>
 80a127e:	2800      	cmp	r0, #0
 80a1280:	d0f5      	beq.n	80a126e <_ZN6String6concatEPKcj+0x8>
	strcpy(buffer + len, cstr);
 80a1282:	6820      	ldr	r0, [r4, #0]
 80a1284:	68a3      	ldr	r3, [r4, #8]
 80a1286:	4631      	mov	r1, r6
 80a1288:	4418      	add	r0, r3
 80a128a:	f001 f809 	bl	80a22a0 <strcpy>
	len = newlen;
 80a128e:	60a5      	str	r5, [r4, #8]

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
 80a1290:	2001      	movs	r0, #1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
 80a1292:	bd70      	pop	{r4, r5, r6, pc}

080a1294 <_ZN6String6concatERKS_>:
/*  concat                                   */
/*********************************************/

unsigned char String::concat(const String &s)
{
	return concat(s.buffer, s.len);
 80a1294:	688a      	ldr	r2, [r1, #8]
 80a1296:	6809      	ldr	r1, [r1, #0]
 80a1298:	f7ff bfe5 	b.w	80a1266 <_ZN6String6concatEPKcj>

080a129c <_ZN6String6concatEPKc>:
	len = newlen;
	return 1;
}

unsigned char String::concat(const char *cstr)
{
 80a129c:	b538      	push	{r3, r4, r5, lr}
 80a129e:	4605      	mov	r5, r0
	if (!cstr) return 0;
 80a12a0:	460c      	mov	r4, r1
	return concat(cstr, strlen(cstr));
}
 80a12a2:	4608      	mov	r0, r1
	return 1;
}

unsigned char String::concat(const char *cstr)
{
	if (!cstr) return 0;
 80a12a4:	b141      	cbz	r1, 80a12b8 <_ZN6String6concatEPKc+0x1c>
	return concat(cstr, strlen(cstr));
 80a12a6:	f001 f803 	bl	80a22b0 <strlen>
 80a12aa:	4621      	mov	r1, r4
 80a12ac:	4602      	mov	r2, r0
 80a12ae:	4628      	mov	r0, r5
}
 80a12b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
}

unsigned char String::concat(const char *cstr)
{
	if (!cstr) return 0;
	return concat(cstr, strlen(cstr));
 80a12b4:	f7ff bfd7 	b.w	80a1266 <_ZN6String6concatEPKcj>
}
 80a12b8:	bd38      	pop	{r3, r4, r5, pc}

080a12ba <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a12ba:	b510      	push	{r4, lr}
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a12bc:	688a      	ldr	r2, [r1, #8]
 80a12be:	6809      	ldr	r1, [r1, #0]
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a12c0:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a12c2:	f7ff ffd0 	bl	80a1266 <_ZN6String6concatEPKcj>
 80a12c6:	b910      	cbnz	r0, 80a12ce <_ZplRK15StringSumHelperRK6String+0x14>
 80a12c8:	4620      	mov	r0, r4
 80a12ca:	f7ff ff41 	bl	80a1150 <_ZN6String10invalidateEv>
	return a;
}
 80a12ce:	4620      	mov	r0, r4
 80a12d0:	bd10      	pop	{r4, pc}

080a12d2 <_ZplRK15StringSumHelperPKc>:

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
 80a12d2:	b538      	push	{r3, r4, r5, lr}
 80a12d4:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
 80a12d6:	460d      	mov	r5, r1
 80a12d8:	b141      	cbz	r1, 80a12ec <_ZplRK15StringSumHelperPKc+0x1a>
 80a12da:	4608      	mov	r0, r1
 80a12dc:	f000 ffe8 	bl	80a22b0 <strlen>
 80a12e0:	4629      	mov	r1, r5
 80a12e2:	4602      	mov	r2, r0
 80a12e4:	4620      	mov	r0, r4
 80a12e6:	f7ff ffbe 	bl	80a1266 <_ZN6String6concatEPKcj>
 80a12ea:	b910      	cbnz	r0, 80a12f2 <_ZplRK15StringSumHelperPKc+0x20>
 80a12ec:	4620      	mov	r0, r4
 80a12ee:	f7ff ff2f 	bl	80a1150 <_ZN6String10invalidateEv>
	return a;
}
 80a12f2:	4620      	mov	r0, r4
 80a12f4:	bd38      	pop	{r3, r4, r5, pc}
	...

080a12f8 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a12f8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80a12fc:	4b03      	ldr	r3, [pc, #12]	; (80a130c <_GLOBAL__sub_I_System+0x14>)
 80a12fe:	2000      	movs	r0, #0
 80a1300:	7018      	strb	r0, [r3, #0]
 80a1302:	8058      	strh	r0, [r3, #2]
 80a1304:	809a      	strh	r2, [r3, #4]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a1306:	f7ff bc41 	b.w	80a0b8c <set_system_mode>
 80a130a:	bf00      	nop
 80a130c:	200001cc 	.word	0x200001cc

080a1310 <_ZN9TCPClient5writeEh>:
        }
        return connected;
}

size_t TCPClient::write(uint8_t b)
{
 80a1310:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1312:	ac02      	add	r4, sp, #8
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a1314:	6803      	ldr	r3, [r0, #0]
        }
        return connected;
}

size_t TCPClient::write(uint8_t b)
{
 80a1316:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a131a:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 80a131c:	2201      	movs	r2, #1
 80a131e:	f247 5330 	movw	r3, #30000	; 0x7530
 80a1322:	4621      	mov	r1, r4
 80a1324:	47a8      	blx	r5
}
 80a1326:	b003      	add	sp, #12
 80a1328:	bd30      	pop	{r4, r5, pc}

080a132a <_ZN9TCPClient5writeEPKhj>:

size_t TCPClient::write(const uint8_t *buffer, size_t size)
{
 80a132a:	b410      	push	{r4}
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a132c:	6803      	ldr	r3, [r0, #0]
 80a132e:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 80a1330:	f247 5330 	movw	r3, #30000	; 0x7530
 80a1334:	46a4      	mov	ip, r4
}
 80a1336:	bc10      	pop	{r4}
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size)
{
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a1338:	4760      	bx	ip

080a133a <_ZN9TCPClient5writeEhm>:
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout)
{
 80a133a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a133c:	ac02      	add	r4, sp, #8
    return write(&b, 1, timeout);
 80a133e:	6803      	ldr	r3, [r0, #0]
{
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout)
{
 80a1340:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, timeout);
 80a1344:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 80a1346:	4621      	mov	r1, r4
 80a1348:	4613      	mov	r3, r2
 80a134a:	2201      	movs	r2, #1
 80a134c:	47a8      	blx	r5
}
 80a134e:	b003      	add	sp, #12
 80a1350:	bd30      	pop	{r4, r5, pc}

080a1352 <_ZN9TCPClient5flushEv>:
  d_->offset = 0;
  d_->total = 0;
}

void TCPClient::flush()
{
 80a1352:	4770      	bx	lr

080a1354 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED1Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
 80a1354:	4770      	bx	lr

080a1356 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE14_M_get_deleterERKSt9type_info>:
	  ? std::__addressof(_M_impl._M_del())
	  : nullptr;
#else
        return nullptr;
#endif
      }
 80a1356:	2000      	movs	r0, #0
 80a1358:	4770      	bx	lr

080a135a <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED0Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
 80a135a:	b510      	push	{r4, lr}
 80a135c:	4604      	mov	r4, r0
 80a135e:	2114      	movs	r1, #20
 80a1360:	f000 fdeb 	bl	80a1f3a <_ZdlPvj>
 80a1364:	4620      	mov	r0, r4
 80a1366:	bd10      	pop	{r4, pc}

080a1368 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_destroyEv>:
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
 80a1368:	f7fe be99 	b.w	80a009e <_ZdlPv>

080a136c <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.29>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
 80a136c:	b510      	push	{r4, lr}
 80a136e:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
 80a1370:	6803      	ldr	r3, [r0, #0]
 80a1372:	689b      	ldr	r3, [r3, #8]
 80a1374:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a1376:	68a3      	ldr	r3, [r4, #8]
 80a1378:	3b01      	subs	r3, #1
 80a137a:	60a3      	str	r3, [r4, #8]
 80a137c:	b92b      	cbnz	r3, 80a138a <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.29+0x1e>
            _M_destroy();
 80a137e:	6823      	ldr	r3, [r4, #0]
 80a1380:	4620      	mov	r0, r4
        }
    }
 80a1382:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
 80a1386:	68db      	ldr	r3, [r3, #12]
 80a1388:	4718      	bx	r3
 80a138a:	bd10      	pop	{r4, pc}

080a138c <_ZN9TCPClient8remoteIPEv>:
{
   return (status()!=0);
}

IPAddress TCPClient::remoteIP()
{
 80a138c:	b570      	push	{r4, r5, r6, lr}

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a138e:	4604      	mov	r4, r0
 80a1390:	4606      	mov	r6, r0
 80a1392:	694d      	ldr	r5, [r1, #20]
 80a1394:	4b04      	ldr	r3, [pc, #16]	; (80a13a8 <_ZN9TCPClient8remoteIPEv+0x1c>)
 80a1396:	358c      	adds	r5, #140	; 0x8c
 80a1398:	f844 3b04 	str.w	r3, [r4], #4
 80a139c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a139e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a13a0:	682b      	ldr	r3, [r5, #0]
    return d_->remoteIP;
}
 80a13a2:	4630      	mov	r0, r6
 80a13a4:	7023      	strb	r3, [r4, #0]
 80a13a6:	bd70      	pop	{r4, r5, r6, pc}
 80a13a8:	080a7838 	.word	0x080a7838

080a13ac <_ZN9TCPClient4peekEv>:
        }
        return read;
}

int TCPClient::peek()
{
 80a13ac:	b510      	push	{r4, lr}
 80a13ae:	6943      	ldr	r3, [r0, #20]
 80a13b0:	4604      	mov	r4, r0
  return  (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
 80a13b2:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a13b6:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
 80a13ba:	429a      	cmp	r2, r3
 80a13bc:	d005      	beq.n	80a13ca <_ZN9TCPClient4peekEv+0x1e>
 80a13be:	6962      	ldr	r2, [r4, #20]
 80a13c0:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a13c4:	4413      	add	r3, r2
 80a13c6:	7918      	ldrb	r0, [r3, #4]
 80a13c8:	bd10      	pop	{r4, pc}
 80a13ca:	6803      	ldr	r3, [r0, #0]
 80a13cc:	691b      	ldr	r3, [r3, #16]
 80a13ce:	4798      	blx	r3
 80a13d0:	2800      	cmp	r0, #0
 80a13d2:	d1f4      	bne.n	80a13be <_ZN9TCPClient4peekEv+0x12>
 80a13d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80a13d8:	bd10      	pop	{r4, pc}

080a13da <_ZN9TCPClient4readEv>:
    avail = bufferCount();
    return avail;
}

int TCPClient::read()
{
 80a13da:	b510      	push	{r4, lr}
 80a13dc:	6943      	ldr	r3, [r0, #20]
 80a13de:	4604      	mov	r4, r0
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
 80a13e0:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a13e4:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
 80a13e8:	429a      	cmp	r2, r3
 80a13ea:	d008      	beq.n	80a13fe <_ZN9TCPClient4readEv+0x24>
 80a13ec:	6962      	ldr	r2, [r4, #20]
 80a13ee:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a13f2:	1c59      	adds	r1, r3, #1
 80a13f4:	f8a2 1084 	strh.w	r1, [r2, #132]	; 0x84
 80a13f8:	4413      	add	r3, r2
 80a13fa:	7918      	ldrb	r0, [r3, #4]
 80a13fc:	bd10      	pop	{r4, pc}
 80a13fe:	6803      	ldr	r3, [r0, #0]
 80a1400:	691b      	ldr	r3, [r3, #16]
 80a1402:	4798      	blx	r3
 80a1404:	2800      	cmp	r0, #0
 80a1406:	d1f1      	bne.n	80a13ec <_ZN9TCPClient4readEv+0x12>
 80a1408:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80a140c:	bd10      	pop	{r4, pc}

080a140e <_ZN9TCPClient4readEPhj>:

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a140e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1410:	6943      	ldr	r3, [r0, #20]
 80a1412:	4617      	mov	r7, r2
        int read = -1;
        if (bufferCount() || available())
 80a1414:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a1418:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
{
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a141c:	4605      	mov	r5, r0
        int read = -1;
        if (bufferCount() || available())
 80a141e:	429a      	cmp	r2, r3
{
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a1420:	460e      	mov	r6, r1
        int read = -1;
        if (bufferCount() || available())
 80a1422:	d106      	bne.n	80a1432 <_ZN9TCPClient4readEPhj+0x24>
 80a1424:	6803      	ldr	r3, [r0, #0]
 80a1426:	691b      	ldr	r3, [r3, #16]
 80a1428:	4798      	blx	r3
 80a142a:	b910      	cbnz	r0, 80a1432 <_ZN9TCPClient4readEPhj+0x24>
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
        int read = -1;
 80a142c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80a1430:	e014      	b.n	80a145c <_ZN9TCPClient4readEPhj+0x4e>
 80a1432:	6969      	ldr	r1, [r5, #20]
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a1434:	4630      	mov	r0, r6
    return ret;
}

int TCPClient::bufferCount()
{
  return d_->total - d_->offset;
 80a1436:	f8b1 3084 	ldrh.w	r3, [r1, #132]	; 0x84
 80a143a:	f8b1 4086 	ldrh.w	r4, [r1, #134]	; 0x86
{
        int read = -1;
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a143e:	4419      	add	r1, r3
    return ret;
}

int TCPClient::bufferCount()
{
  return d_->total - d_->offset;
 80a1440:	1ae4      	subs	r4, r4, r3
int TCPClient::read(uint8_t *buffer, size_t size)
{
        int read = -1;
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
 80a1442:	42bc      	cmp	r4, r7
 80a1444:	bf28      	it	cs
 80a1446:	463c      	movcs	r4, r7
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a1448:	3104      	adds	r1, #4
 80a144a:	4622      	mov	r2, r4
 80a144c:	f000 fee2 	bl	80a2214 <memcpy>
 80a1450:	696a      	ldr	r2, [r5, #20]
          d_->offset += read;
 80a1452:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a1456:	4423      	add	r3, r4
 80a1458:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
        }
        return read;
}
 80a145c:	4620      	mov	r0, r4
 80a145e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1460 <_ZN9TCPClient12flush_bufferEv>:
{
  return  (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
}

void TCPClient::flush_buffer()
{
 80a1460:	6942      	ldr	r2, [r0, #20]
  d_->offset = 0;
 80a1462:	2300      	movs	r3, #0
 80a1464:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
 80a1468:	6942      	ldr	r2, [r0, #20]
  d_->total = 0;
 80a146a:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
 80a146e:	4770      	bx	lr

080a1470 <_ZN9TCPClient9availableEv>:
{
  return d_->total - d_->offset;
}

int TCPClient::available()
{
 80a1470:	b538      	push	{r3, r4, r5, lr}
 80a1472:	6942      	ldr	r2, [r0, #20]
 80a1474:	4604      	mov	r4, r0
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total))
 80a1476:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a147a:	b11b      	cbz	r3, 80a1484 <_ZN9TCPClient9availableEv+0x14>
 80a147c:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
 80a1480:	429a      	cmp	r2, r3
 80a1482:	d00c      	beq.n	80a149e <_ZN9TCPClient9availableEv+0x2e>
    {
        flush_buffer();
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
 80a1484:	6920      	ldr	r0, [r4, #16]
 80a1486:	f7ff fd33 	bl	80a0ef0 <_ZN5spark12NetworkClass4fromEm>
 80a148a:	6803      	ldr	r3, [r0, #0]
 80a148c:	68db      	ldr	r3, [r3, #12]
 80a148e:	4798      	blx	r3
 80a1490:	b318      	cbz	r0, 80a14da <_ZN9TCPClient9availableEv+0x6a>
 80a1492:	6963      	ldr	r3, [r4, #20]

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a1494:	6818      	ldr	r0, [r3, #0]
 80a1496:	f7ff faa1 	bl	80a09dc <socket_handle_valid>
    if (d_->total && (d_->offset == d_->total))
    {
        flush_buffer();
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
 80a149a:	b918      	cbnz	r0, 80a14a4 <_ZN9TCPClient9availableEv+0x34>
 80a149c:	e01d      	b.n	80a14da <_ZN9TCPClient9availableEv+0x6a>
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total))
    {
        flush_buffer();
 80a149e:	f7ff ffdf 	bl	80a1460 <_ZN9TCPClient12flush_bufferEv>
 80a14a2:	e7ef      	b.n	80a1484 <_ZN9TCPClient9availableEv+0x14>
 80a14a4:	6960      	ldr	r0, [r4, #20]
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
    {
        // Have room
        if ( d_->total < arraySize(d_->buffer))
 80a14a6:	f8b0 1086 	ldrh.w	r1, [r0, #134]	; 0x86
 80a14aa:	297f      	cmp	r1, #127	; 0x7f
 80a14ac:	d815      	bhi.n	80a14da <_ZN9TCPClient9availableEv+0x6a>
        {
            int ret = socket_receive(d_->sock, d_->buffer + d_->total , arraySize(d_->buffer)-d_->total, 0);
 80a14ae:	1d05      	adds	r5, r0, #4
 80a14b0:	f1c1 0280 	rsb	r2, r1, #128	; 0x80
 80a14b4:	2300      	movs	r3, #0
 80a14b6:	4429      	add	r1, r5
 80a14b8:	6800      	ldr	r0, [r0, #0]
 80a14ba:	f7ff faa7 	bl	80a0a0c <socket_receive>
            if (ret > 0)
 80a14be:	2800      	cmp	r0, #0
 80a14c0:	dd0b      	ble.n	80a14da <_ZN9TCPClient9availableEv+0x6a>
 80a14c2:	6963      	ldr	r3, [r4, #20]
            {
                DEBUG("recv(=%d)",ret);
                if (d_->total == 0) d_->offset = 0;
 80a14c4:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a14c8:	b90a      	cbnz	r2, 80a14ce <_ZN9TCPClient9availableEv+0x5e>
 80a14ca:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
 80a14ce:	6962      	ldr	r2, [r4, #20]
                d_->total += ret;
 80a14d0:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a14d4:	4418      	add	r0, r3
 80a14d6:	f8a2 0086 	strh.w	r0, [r2, #134]	; 0x86
 80a14da:	6962      	ldr	r2, [r4, #20]
            }
        } // Have Space
    } // WiFi.ready() && isOpen(d_->sock)
    avail = bufferCount();
    return avail;
 80a14dc:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a14e0:	f8b2 0084 	ldrh.w	r0, [r2, #132]	; 0x84
 80a14e4:	1a18      	subs	r0, r3, r0
}
 80a14e6:	bd38      	pop	{r3, r4, r5, pc}

080a14e8 <_ZN9TCPClient4stopEv>:
{
}


void TCPClient::stop()
{
 80a14e8:	b538      	push	{r3, r4, r5, lr}
  // This log line pollutes the log too much
  // DEBUG("sock %d closesocket", d_->sock);

  if (isOpen(d_->sock))
 80a14ea:	6943      	ldr	r3, [r0, #20]
{
}


void TCPClient::stop()
{
 80a14ec:	4604      	mov	r4, r0

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a14ee:	6818      	ldr	r0, [r3, #0]
 80a14f0:	f7ff fa74 	bl	80a09dc <socket_handle_valid>
void TCPClient::stop()
{
  // This log line pollutes the log too much
  // DEBUG("sock %d closesocket", d_->sock);

  if (isOpen(d_->sock))
 80a14f4:	b118      	cbz	r0, 80a14fe <_ZN9TCPClient4stopEv+0x16>
      socket_close(d_->sock);
 80a14f6:	6963      	ldr	r3, [r4, #20]
 80a14f8:	6818      	ldr	r0, [r3, #0]
 80a14fa:	f7ff fa8f 	bl	80a0a1c <socket_close>
 80a14fe:	6965      	ldr	r5, [r4, #20]
  d_->sock = socket_handle_invalid();
 80a1500:	f7ff fa94 	bl	80a0a2c <socket_handle_invalid>
 80a1504:	6028      	str	r0, [r5, #0]
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a1506:	6960      	ldr	r0, [r4, #20]
 80a1508:	2211      	movs	r2, #17
 80a150a:	2100      	movs	r1, #0
 80a150c:	308c      	adds	r0, #140	; 0x8c
 80a150e:	f000 fe8c 	bl	80a222a <memset>
  d_->remoteIP.clear();
  flush_buffer();
 80a1512:	4620      	mov	r0, r4
}
 80a1514:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  if (isOpen(d_->sock))
      socket_close(d_->sock);
  d_->sock = socket_handle_invalid();
  d_->remoteIP.clear();
  flush_buffer();
 80a1518:	f7ff bfa2 	b.w	80a1460 <_ZN9TCPClient12flush_bufferEv>

080a151c <_ZN9TCPClient7connectE9IPAddresstm>:
    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a151c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a1520:	461f      	mov	r7, r3
    stop();
 80a1522:	6803      	ldr	r3, [r0, #0]
    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a1524:	b08a      	sub	sp, #40	; 0x28
    stop();
 80a1526:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a1528:	4606      	mov	r6, r0
 80a152a:	460c      	mov	r4, r1
 80a152c:	4615      	mov	r5, r2
    stop();
 80a152e:	4798      	blx	r3
        int connected = 0;
        if(Network.from(nif).ready())
 80a1530:	4638      	mov	r0, r7
 80a1532:	f7ff fcdd 	bl	80a0ef0 <_ZN5spark12NetworkClass4fromEm>
 80a1536:	6803      	ldr	r3, [r0, #0]
 80a1538:	68db      	ldr	r3, [r3, #12]
 80a153a:	4798      	blx	r3
 80a153c:	2800      	cmp	r0, #0
 80a153e:	d056      	beq.n	80a15ee <_ZN9TCPClient7connectE9IPAddresstm+0xd2>
        {
          sockaddr_t tSocketAddr;
          d_->sock = socket_create(AF_INET, SOCK_STREAM, IPPROTO_TCP, port, nif);
 80a1540:	9700      	str	r7, [sp, #0]
 80a1542:	462b      	mov	r3, r5
 80a1544:	2206      	movs	r2, #6
 80a1546:	2101      	movs	r1, #1
 80a1548:	2002      	movs	r0, #2
 80a154a:	f8d6 8014 	ldr.w	r8, [r6, #20]
 80a154e:	f7ff fa4d 	bl	80a09ec <socket_create>
          LOG(TRACE, "TCPClient socket=%x", d_->sock);
 80a1552:	2320      	movs	r3, #32
    stop();
        int connected = 0;
        if(Network.from(nif).ready())
        {
          sockaddr_t tSocketAddr;
          d_->sock = socket_create(AF_INET, SOCK_STREAM, IPPROTO_TCP, port, nif);
 80a1554:	f8c8 0000 	str.w	r0, [r8]
          LOG(TRACE, "TCPClient socket=%x", d_->sock);
 80a1558:	2700      	movs	r7, #0
 80a155a:	9302      	str	r3, [sp, #8]
 80a155c:	6973      	ldr	r3, [r6, #20]
 80a155e:	9703      	str	r7, [sp, #12]
 80a1560:	681b      	ldr	r3, [r3, #0]
 80a1562:	2001      	movs	r0, #1
 80a1564:	9301      	str	r3, [sp, #4]
 80a1566:	4b23      	ldr	r3, [pc, #140]	; (80a15f4 <_ZN9TCPClient7connectE9IPAddresstm+0xd8>)
 80a1568:	aa02      	add	r2, sp, #8
 80a156a:	9300      	str	r3, [sp, #0]
 80a156c:	4922      	ldr	r1, [pc, #136]	; (80a15f8 <_ZN9TCPClient7connectE9IPAddresstm+0xdc>)
 80a156e:	463b      	mov	r3, r7
 80a1570:	f7ff fb04 	bl	80a0b7c <log_message>

          if (socket_handle_valid(d_->sock))
 80a1574:	6973      	ldr	r3, [r6, #20]
 80a1576:	6818      	ldr	r0, [r3, #0]
 80a1578:	f7ff fa30 	bl	80a09dc <socket_handle_valid>
 80a157c:	2800      	cmp	r0, #0
 80a157e:	d036      	beq.n	80a15ee <_ZN9TCPClient7connectE9IPAddresstm+0xd2>
          {
            flush_buffer();
 80a1580:	4630      	mov	r0, r6
 80a1582:	f7ff ff6d 	bl	80a1460 <_ZN9TCPClient12flush_bufferEv>

            tSocketAddr.sa_family = AF_INET;
 80a1586:	2302      	movs	r3, #2
 80a1588:	f8ad 3008 	strh.w	r3, [sp, #8]

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
 80a158c:	0a2b      	lsrs	r3, r5, #8
 80a158e:	f88d 300a 	strb.w	r3, [sp, #10]
            tSocketAddr.sa_data[1] = (port & 0x00FF);

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
 80a1592:	79e3      	ldrb	r3, [r4, #7]
            tSocketAddr.sa_data[3] = ip[1];
            tSocketAddr.sa_data[4] = ip[2];
            tSocketAddr.sa_data[5] = ip[3];


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a1594:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
            tSocketAddr.sa_family = AF_INET;

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
            tSocketAddr.sa_data[1] = (port & 0x00FF);

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
 80a1598:	f88d 300c 	strb.w	r3, [sp, #12]
            tSocketAddr.sa_data[3] = ip[1];
 80a159c:	79a3      	ldrb	r3, [r4, #6]
            flush_buffer();

            tSocketAddr.sa_family = AF_INET;

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
            tSocketAddr.sa_data[1] = (port & 0x00FF);
 80a159e:	f88d 500b 	strb.w	r5, [sp, #11]

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
            tSocketAddr.sa_data[3] = ip[1];
 80a15a2:	f88d 300d 	strb.w	r3, [sp, #13]
            tSocketAddr.sa_data[4] = ip[2];
 80a15a6:	7963      	ldrb	r3, [r4, #5]
 80a15a8:	f88d 300e 	strb.w	r3, [sp, #14]
            tSocketAddr.sa_data[5] = ip[3];
 80a15ac:	f814 3f04 	ldrb.w	r3, [r4, #4]!
 80a15b0:	f88d 300f 	strb.w	r3, [sp, #15]


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a15b4:	f7ff faca 	bl	80a0b4c <HAL_NET_SetNetWatchDog>
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
 80a15b8:	6973      	ldr	r3, [r6, #20]
            tSocketAddr.sa_data[3] = ip[1];
            tSocketAddr.sa_data[4] = ip[2];
            tSocketAddr.sa_data[5] = ip[3];


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a15ba:	4605      	mov	r5, r0
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
 80a15bc:	2210      	movs	r2, #16
 80a15be:	a902      	add	r1, sp, #8
 80a15c0:	6818      	ldr	r0, [r3, #0]
 80a15c2:	f7ff fa1b 	bl	80a09fc <socket_connect>
 80a15c6:	4680      	mov	r8, r0
            DEBUG("sock %d connected=%d",d_->sock, connected);
            HAL_NET_SetNetWatchDog(ot);
 80a15c8:	4628      	mov	r0, r5
 80a15ca:	f7ff fabf 	bl	80a0b4c <HAL_NET_SetNetWatchDog>

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a15ce:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a15d0:	6975      	ldr	r5, [r6, #20]
 80a15d2:	358c      	adds	r5, #140	; 0x8c
 80a15d4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a15d6:	6823      	ldr	r3, [r4, #0]
 80a15d8:	702b      	strb	r3, [r5, #0]
            d_->remoteIP = ip;
            if(!connected)
 80a15da:	f1b8 0f00 	cmp.w	r8, #0
 80a15de:	d005      	beq.n	80a15ec <_ZN9TCPClient7connectE9IPAddresstm+0xd0>
            {
                stop();
 80a15e0:	6833      	ldr	r3, [r6, #0]
 80a15e2:	4630      	mov	r0, r6
 80a15e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a15e6:	4798      	blx	r3
 80a15e8:	4638      	mov	r0, r7
 80a15ea:	e000      	b.n	80a15ee <_ZN9TCPClient7connectE9IPAddresstm+0xd2>
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
            DEBUG("sock %d connected=%d",d_->sock, connected);
            HAL_NET_SetNetWatchDog(ot);
            d_->remoteIP = ip;
            if(!connected)
 80a15ec:	2001      	movs	r0, #1
                stop();
            }
          }
        }
        return connected;
}
 80a15ee:	b00a      	add	sp, #40	; 0x28
 80a15f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a15f4:	080a79d3 	.word	0x080a79d3
 80a15f8:	080a79cc 	.word	0x080a79cc

080a15fc <_ZN9TCPClient6statusEv>:
  }
  return rv;
}

uint8_t TCPClient::status()
{
 80a15fc:	b510      	push	{r4, lr}
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
 80a15fe:	6943      	ldr	r3, [r0, #20]
  }
  return rv;
}

uint8_t TCPClient::status()
{
 80a1600:	4604      	mov	r4, r0

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a1602:	6818      	ldr	r0, [r3, #0]
 80a1604:	f7ff f9ea 	bl	80a09dc <socket_handle_valid>
  return rv;
}

uint8_t TCPClient::status()
{
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
 80a1608:	b908      	cbnz	r0, 80a160e <_ZN9TCPClient6statusEv+0x12>
 80a160a:	2000      	movs	r0, #0
 80a160c:	bd10      	pop	{r4, pc}
 80a160e:	6920      	ldr	r0, [r4, #16]
 80a1610:	f7ff fc6e 	bl	80a0ef0 <_ZN5spark12NetworkClass4fromEm>
 80a1614:	6803      	ldr	r3, [r0, #0]
 80a1616:	68db      	ldr	r3, [r3, #12]
 80a1618:	4798      	blx	r3
 80a161a:	2800      	cmp	r0, #0
 80a161c:	d0f5      	beq.n	80a160a <_ZN9TCPClient6statusEv+0xe>
 80a161e:	6963      	ldr	r3, [r4, #20]
 80a1620:	6818      	ldr	r0, [r3, #0]
 80a1622:	f7ff f9d3 	bl	80a09cc <socket_active_status>
 80a1626:	fab0 f080 	clz	r0, r0
 80a162a:	0940      	lsrs	r0, r0, #5
}
 80a162c:	bd10      	pop	{r4, pc}

080a162e <_ZN9TCPClient5writeEPKhjm>:
{
    return write(&b, 1, timeout);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout)
{
 80a162e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
 80a1632:	2500      	movs	r5, #0
 80a1634:	6045      	str	r5, [r0, #4]
 80a1636:	4604      	mov	r4, r0
 80a1638:	460e      	mov	r6, r1
 80a163a:	4617      	mov	r7, r2
 80a163c:	4698      	mov	r8, r3
    clearWriteError();
    int ret = status() ? socket_send_ex(d_->sock, buffer, size, 0, timeout, nullptr) : -1;
 80a163e:	f7ff ffdd 	bl	80a15fc <_ZN9TCPClient6statusEv>
 80a1642:	b160      	cbz	r0, 80a165e <_ZN9TCPClient5writeEPKhjm+0x30>
 80a1644:	6960      	ldr	r0, [r4, #20]
 80a1646:	9501      	str	r5, [sp, #4]
 80a1648:	f8cd 8000 	str.w	r8, [sp]
 80a164c:	462b      	mov	r3, r5
 80a164e:	463a      	mov	r2, r7
 80a1650:	4631      	mov	r1, r6
 80a1652:	6800      	ldr	r0, [r0, #0]
 80a1654:	f7ff f9f2 	bl	80a0a3c <socket_send_ex>
    if (ret < 0) {
 80a1658:	2800      	cmp	r0, #0
 80a165a:	da03      	bge.n	80a1664 <_ZN9TCPClient5writeEPKhjm+0x36>
 80a165c:	e001      	b.n	80a1662 <_ZN9TCPClient5writeEPKhjm+0x34>
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout)
{
    clearWriteError();
    int ret = status() ? socket_send_ex(d_->sock, buffer, size, 0, timeout, nullptr) : -1;
 80a165e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a1662:	6060      	str	r0, [r4, #4]

    /*
     * FIXME: We should not be returning negative numbers here
     */
    return ret;
}
 80a1664:	b002      	add	sp, #8
 80a1666:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a166a <_ZN9TCPClient9connectedEv>:
  d_->remoteIP.clear();
  flush_buffer();
}

uint8_t TCPClient::connected()
{
 80a166a:	b538      	push	{r3, r4, r5, lr}
 80a166c:	4604      	mov	r4, r0
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
 80a166e:	f7ff ffc5 	bl	80a15fc <_ZN9TCPClient6statusEv>
 80a1672:	bb00      	cbnz	r0, 80a16b6 <_ZN9TCPClient9connectedEv+0x4c>
 80a1674:	6963      	ldr	r3, [r4, #20]
 80a1676:	f8b3 1086 	ldrh.w	r1, [r3, #134]	; 0x86
 80a167a:	f8b3 2084 	ldrh.w	r2, [r3, #132]	; 0x84
 80a167e:	4291      	cmp	r1, r2
 80a1680:	d119      	bne.n	80a16b6 <_ZN9TCPClient9connectedEv+0x4c>

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a1682:	6818      	ldr	r0, [r3, #0]
 80a1684:	f7ff f9aa 	bl	80a09dc <socket_handle_valid>
uint8_t TCPClient::connected()
{
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
  // no data in the local buffer, Socket open but my be in CLOSE_WAIT yet the CC3000 may have data in its buffer
  if(!rv && isOpen(d_->sock) && (SOCKET_STATUS_INACTIVE == socket_active_status(d_->sock)))
 80a1688:	b128      	cbz	r0, 80a1696 <_ZN9TCPClient9connectedEv+0x2c>
 80a168a:	6963      	ldr	r3, [r4, #20]
 80a168c:	6818      	ldr	r0, [r3, #0]
 80a168e:	f7ff f99d 	bl	80a09cc <socket_active_status>
 80a1692:	2801      	cmp	r0, #1
 80a1694:	d001      	beq.n	80a169a <_ZN9TCPClient9connectedEv+0x30>
}

uint8_t TCPClient::connected()
{
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
 80a1696:	2500      	movs	r5, #0
 80a1698:	e00e      	b.n	80a16b8 <_ZN9TCPClient9connectedEv+0x4e>
  // no data in the local buffer, Socket open but my be in CLOSE_WAIT yet the CC3000 may have data in its buffer
  if(!rv && isOpen(d_->sock) && (SOCKET_STATUS_INACTIVE == socket_active_status(d_->sock)))
    {
      rv = available(); // Try CC3000
 80a169a:	6823      	ldr	r3, [r4, #0]
 80a169c:	4620      	mov	r0, r4
 80a169e:	691b      	ldr	r3, [r3, #16]
 80a16a0:	4798      	blx	r3
 80a16a2:	2800      	cmp	r0, #0
 80a16a4:	bf14      	ite	ne
 80a16a6:	2501      	movne	r5, #1
 80a16a8:	2500      	moveq	r5, #0
      if (!rv) {        // No more Data and CLOSE_WAIT
 80a16aa:	d105      	bne.n	80a16b8 <_ZN9TCPClient9connectedEv+0x4e>
          DEBUG("calling .stop(), no more data, in CLOSE_WAIT");
          stop();       // Close our side
 80a16ac:	6823      	ldr	r3, [r4, #0]
 80a16ae:	4620      	mov	r0, r4
 80a16b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a16b2:	4798      	blx	r3
 80a16b4:	e000      	b.n	80a16b8 <_ZN9TCPClient9connectedEv+0x4e>
 80a16b6:	2501      	movs	r5, #1
      }
  }
  return rv;
}
 80a16b8:	4628      	mov	r0, r5
 80a16ba:	bd38      	pop	{r3, r4, r5, pc}

080a16bc <_ZN9TCPClientcvbEv>:
{
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
}

TCPClient::operator bool()
{
 80a16bc:	b508      	push	{r3, lr}
   return (status()!=0);
 80a16be:	f7ff ff9d 	bl	80a15fc <_ZN9TCPClient6statusEv>
}
 80a16c2:	3000      	adds	r0, #0
 80a16c4:	bf18      	it	ne
 80a16c6:	2001      	movne	r0, #1
 80a16c8:	bd08      	pop	{r3, pc}

080a16ca <_ZN9TCPClient4DataC1Em>:
IPAddress TCPClient::remoteIP()
{
    return d_->remoteIP;
}

TCPClient::Data::Data(sock_handle_t sock)
 80a16ca:	b510      	push	{r4, lr}
 80a16cc:	4604      	mov	r4, r0
        : sock(sock),
          offset(0),
          total(0) {
 80a16ce:	2300      	movs	r3, #0
 80a16d0:	6001      	str	r1, [r0, #0]
 80a16d2:	f8a0 3084 	strh.w	r3, [r0, #132]	; 0x84
 80a16d6:	f8a0 3086 	strh.w	r3, [r0, #134]	; 0x86
 80a16da:	3088      	adds	r0, #136	; 0x88
 80a16dc:	f7ff fb62 	bl	80a0da4 <_ZN9IPAddressC1Ev>
}
 80a16e0:	4620      	mov	r0, r4
 80a16e2:	bd10      	pop	{r4, pc}

080a16e4 <_ZN9TCPClientC1Em>:
 80a16e4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
{
}

TCPClient::TCPClient(sock_handle_t sock) :
 80a16e8:	b570      	push	{r4, r5, r6, lr}
 80a16ea:	6082      	str	r2, [r0, #8]
        d_(std::make_shared<Data>(sock))
 80a16ec:	4a14      	ldr	r2, [pc, #80]	; (80a1740 <_ZN9TCPClientC1Em+0x5c>)
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a16ee:	2300      	movs	r3, #0
 80a16f0:	6043      	str	r3, [r0, #4]
 80a16f2:	6002      	str	r2, [r0, #0]
        };

      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
		     _Args&&... __args)
	: _M_ptr(), _M_refcount()
 80a16f4:	6143      	str	r3, [r0, #20]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a16f6:	6183      	str	r3, [r0, #24]

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
{
}

TCPClient::TCPClient(sock_handle_t sock) :
 80a16f8:	4604      	mov	r4, r0
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 80a16fa:	20a0      	movs	r0, #160	; 0xa0
 80a16fc:	460e      	mov	r6, r1
 80a16fe:	f7fe fccc 	bl	80a009a <_Znwj>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 80a1702:	4605      	mov	r5, r0
 80a1704:	b110      	cbz	r0, 80a170c <_ZN9TCPClientC1Em+0x28>
 80a1706:	4631      	mov	r1, r6
 80a1708:	f7ff ffdf 	bl	80a16ca <_ZN9TCPClient4DataC1Em>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 80a170c:	2014      	movs	r0, #20
 80a170e:	f7fe fcc4 	bl	80a009a <_Znwj>
	  __try
	    {
	      typename _Sp_cd_type::__allocator_type __a2(__a);
	      auto __guard = std::__allocate_guarded(__a2);
	      _Sp_cd_type* __mem = __guard.get();
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
 80a1712:	4603      	mov	r3, r0
 80a1714:	b128      	cbz	r0, 80a1722 <_ZN9TCPClientC1Em+0x3e>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
 80a1716:	2201      	movs	r2, #1
 80a1718:	6042      	str	r2, [r0, #4]
 80a171a:	6082      	str	r2, [r0, #8]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
 80a171c:	4a09      	ldr	r2, [pc, #36]	; (80a1744 <_ZN9TCPClientC1Em+0x60>)
	typedef _Sp_ebo_helper<0, _Deleter>	_Del_base;
	typedef _Sp_ebo_helper<1, _Alloc>	_Alloc_base;

      public:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
	: _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
 80a171e:	6105      	str	r5, [r0, #16]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
 80a1720:	6002      	str	r2, [r0, #0]

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
 80a1722:	69a0      	ldr	r0, [r4, #24]
	  __traits::construct(__del._M_alloc, __ptr,
			      std::forward<_Args>(__args)...);
	  __guard = nullptr;
	  __shared_count<_Lp> __count(__ptr, __del, __del._M_alloc);
	  _M_refcount._M_swap(__count);
	  _M_ptr = __ptr;
 80a1724:	6165      	str	r5, [r4, #20]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
 80a1726:	61a3      	str	r3, [r4, #24]
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a1728:	b128      	cbz	r0, 80a1736 <_ZN9TCPClientC1Em+0x52>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a172a:	6843      	ldr	r3, [r0, #4]
 80a172c:	3b01      	subs	r3, #1
 80a172e:	6043      	str	r3, [r0, #4]
 80a1730:	b90b      	cbnz	r3, 80a1736 <_ZN9TCPClientC1Em+0x52>
 80a1732:	f7ff fe1b 	bl	80a136c <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.29>
        d_(std::make_shared<Data>(sock))
{
  flush_buffer();
 80a1736:	4620      	mov	r0, r4
 80a1738:	f7ff fe92 	bl	80a1460 <_ZN9TCPClient12flush_bufferEv>
}
 80a173c:	4620      	mov	r0, r4
 80a173e:	bd70      	pop	{r4, r5, r6, pc}
 80a1740:	080a7988 	.word	0x080a7988
 80a1744:	080a796c 	.word	0x080a796c

080a1748 <_ZN9TCPClientC1Ev>:
static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
}

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
 80a1748:	b510      	push	{r4, lr}
 80a174a:	4604      	mov	r4, r0
 80a174c:	f7ff f96e 	bl	80a0a2c <socket_handle_invalid>
 80a1750:	4601      	mov	r1, r0
 80a1752:	4620      	mov	r0, r4
 80a1754:	f7ff ffc6 	bl	80a16e4 <_ZN9TCPClientC1Em>
{
}
 80a1758:	4620      	mov	r0, r4
 80a175a:	bd10      	pop	{r4, pc}

080a175c <_ZN9TCPClient4DataD1Ev>:
        : sock(sock),
          offset(0),
          total(0) {
}

TCPClient::Data::~Data() {
 80a175c:	b510      	push	{r4, lr}
 80a175e:	4604      	mov	r4, r0
    if (socket_handle_valid(sock)) {
 80a1760:	6800      	ldr	r0, [r0, #0]
 80a1762:	f7ff f93b 	bl	80a09dc <socket_handle_valid>
 80a1766:	b110      	cbz	r0, 80a176e <_ZN9TCPClient4DataD1Ev+0x12>
        socket_close(sock);
 80a1768:	6820      	ldr	r0, [r4, #0]
 80a176a:	f7ff f957 	bl	80a0a1c <socket_close>
    }
}
 80a176e:	4620      	mov	r0, r4
 80a1770:	bd10      	pop	{r4, pc}

080a1772 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv>:
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
 80a1772:	b510      	push	{r4, lr}
      { _M_impl._M_del()(_M_impl._M_ptr); }
 80a1774:	6904      	ldr	r4, [r0, #16]
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void 
        destroy(_Up* __p) { __p->~_Up(); }
 80a1776:	4620      	mov	r0, r4
 80a1778:	f7ff fff0 	bl	80a175c <_ZN9TCPClient4DataD1Ev>
      { __gd._M_ptr = nullptr; }

      /// Deallocate the owned pointer
      ~__allocated_ptr()
      {
	if (_M_ptr != nullptr)
 80a177c:	b124      	cbz	r4, 80a1788 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv+0x16>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
 80a177e:	4620      	mov	r0, r4
 80a1780:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a1784:	f7fe bc8b 	b.w	80a009e <_ZdlPv>
 80a1788:	bd10      	pop	{r4, pc}
	...

080a178c <_ZN9TCPClient7connectEPKctm>:
  flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a178c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a1790:	461f      	mov	r7, r3
    stop();
 80a1792:	6803      	ldr	r3, [r0, #0]
  flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a1794:	b08f      	sub	sp, #60	; 0x3c
    stop();
 80a1796:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a1798:	4606      	mov	r6, r0
 80a179a:	460d      	mov	r5, r1
 80a179c:	4690      	mov	r8, r2
    stop();
 80a179e:	4798      	blx	r3
    if (Network.ready())
 80a17a0:	4813      	ldr	r0, [pc, #76]	; (80a17f0 <_ZN9TCPClient7connectEPKctm+0x64>)
 80a17a2:	f7ff fb58 	bl	80a0e56 <_ZN5spark12NetworkClass5readyEv>
 80a17a6:	b300      	cbz	r0, 80a17ea <_ZN9TCPClient7connectEPKctm+0x5e>
    {
        IPAddress ip_addr;
 80a17a8:	a802      	add	r0, sp, #8
 80a17aa:	f7ff fafb 	bl	80a0da4 <_ZN9IPAddressC1Ev>
        if (inet_gethostbyname(host, strlen(host), ip_addr, nif, NULL) == 0) {
 80a17ae:	4628      	mov	r0, r5
 80a17b0:	f000 fd7e 	bl	80a22b0 <strlen>
 80a17b4:	2400      	movs	r4, #0
 80a17b6:	b281      	uxth	r1, r0
 80a17b8:	9400      	str	r4, [sp, #0]
 80a17ba:	463b      	mov	r3, r7
 80a17bc:	aa03      	add	r2, sp, #12
 80a17be:	4628      	mov	r0, r5
 80a17c0:	f7ff f9cc 	bl	80a0b5c <inet_gethostbyname>
 80a17c4:	b980      	cbnz	r0, 80a17e8 <_ZN9TCPClient7connectEPKctm+0x5c>
            return connect(ip_addr, port, nif);
 80a17c6:	6833      	ldr	r3, [r6, #0]
 80a17c8:	ad09      	add	r5, sp, #36	; 0x24
 80a17ca:	f8d3 9020 	ldr.w	r9, [r3, #32]
 80a17ce:	4b09      	ldr	r3, [pc, #36]	; (80a17f4 <_ZN9TCPClient7connectEPKctm+0x68>)
 80a17d0:	ac03      	add	r4, sp, #12
 80a17d2:	9308      	str	r3, [sp, #32]
 80a17d4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a17d6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a17d8:	6823      	ldr	r3, [r4, #0]
 80a17da:	4642      	mov	r2, r8
 80a17dc:	702b      	strb	r3, [r5, #0]
 80a17de:	a908      	add	r1, sp, #32
 80a17e0:	463b      	mov	r3, r7
 80a17e2:	4630      	mov	r0, r6
 80a17e4:	47c8      	blx	r9
 80a17e6:	e000      	b.n	80a17ea <_ZN9TCPClient7connectEPKctm+0x5e>
        } else {
            DEBUG("unable to get IP for hostname");
        }
    }

    return 0; // error, could not connect
 80a17e8:	4620      	mov	r0, r4
}
 80a17ea:	b00f      	add	sp, #60	; 0x3c
 80a17ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a17f0:	200001b4 	.word	0x200001b4
 80a17f4:	080a7838 	.word	0x080a7838

080a17f8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a17f8:	4b02      	ldr	r3, [pc, #8]	; (80a1804 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a17fa:	681a      	ldr	r2, [r3, #0]
 80a17fc:	4b02      	ldr	r3, [pc, #8]	; (80a1808 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a17fe:	601a      	str	r2, [r3, #0]
 80a1800:	4770      	bx	lr
 80a1802:	bf00      	nop
 80a1804:	200000d8 	.word	0x200000d8
 80a1808:	200001d4 	.word	0x200001d4

080a180c <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a180c:	4770      	bx	lr

080a180e <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a180e:	7441      	strb	r1, [r0, #17]
 80a1810:	4770      	bx	lr

080a1812 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
 80a1812:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data_For_Write(_serial));
 80a1814:	7c00      	ldrb	r0, [r0, #16]
 80a1816:	f7ff f961 	bl	80a0adc <HAL_USART_Available_Data_For_Write>
}
 80a181a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a181e:	bd08      	pop	{r3, pc}

080a1820 <_ZN11USARTSerial9availableEv>:

int USARTSerial::available(void)
{
 80a1820:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data(_serial));
 80a1822:	7c00      	ldrb	r0, [r0, #16]
 80a1824:	f7ff f932 	bl	80a0a8c <HAL_USART_Available_Data>
}
 80a1828:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a182c:	bd08      	pop	{r3, pc}

080a182e <_ZN11USARTSerial4peekEv>:

int USARTSerial::peek(void)
{
 80a182e:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Peek_Data(_serial));
 80a1830:	7c00      	ldrb	r0, [r0, #16]
 80a1832:	f7ff f93b 	bl	80a0aac <HAL_USART_Peek_Data>
}
 80a1836:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a183a:	bf28      	it	cs
 80a183c:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
 80a1840:	bd08      	pop	{r3, pc}

080a1842 <_ZN11USARTSerial4readEv>:

int USARTSerial::read(void)
{
 80a1842:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Read_Data(_serial));
 80a1844:	7c00      	ldrb	r0, [r0, #16]
 80a1846:	f7ff f929 	bl	80a0a9c <HAL_USART_Read_Data>
}
 80a184a:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a184e:	bf28      	it	cs
 80a1850:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
 80a1854:	bd08      	pop	{r3, pc}

080a1856 <_ZN11USARTSerial5flushEv>:

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a1856:	7c00      	ldrb	r0, [r0, #16]
 80a1858:	f7ff b930 	b.w	80a0abc <HAL_USART_Flush_Data>

080a185c <_ZN11USARTSerialD0Ev>:
 80a185c:	b510      	push	{r4, lr}
 80a185e:	4604      	mov	r4, r0
 80a1860:	2114      	movs	r1, #20
 80a1862:	f000 fb6a 	bl	80a1f3a <_ZdlPvj>
 80a1866:	4620      	mov	r0, r4
 80a1868:	bd10      	pop	{r4, pc}

080a186a <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a186a:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a186c:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a186e:	4604      	mov	r4, r0
 80a1870:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a1872:	b925      	cbnz	r5, 80a187e <_ZN11USARTSerial5writeEh+0x14>
 80a1874:	7c00      	ldrb	r0, [r0, #16]
 80a1876:	f7ff f931 	bl	80a0adc <HAL_USART_Available_Data_For_Write>
 80a187a:	2800      	cmp	r0, #0
 80a187c:	dd05      	ble.n	80a188a <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a187e:	4631      	mov	r1, r6
 80a1880:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a1882:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a1886:	f7ff b8f9 	b.w	80a0a7c <HAL_USART_Write_Data>
  }
  return 0;
}
 80a188a:	4628      	mov	r0, r5
 80a188c:	bd70      	pop	{r4, r5, r6, pc}
	...

080a1890 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a1890:	b510      	push	{r4, lr}
 80a1892:	4604      	mov	r4, r0
 80a1894:	4608      	mov	r0, r1
 80a1896:	4611      	mov	r1, r2
 80a1898:	2200      	movs	r2, #0
 80a189a:	6062      	str	r2, [r4, #4]
 80a189c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a18a0:	60a2      	str	r2, [r4, #8]
 80a18a2:	4a05      	ldr	r2, [pc, #20]	; (80a18b8 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a18a4:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a18a6:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a18a8:	2201      	movs	r2, #1
 80a18aa:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a18ac:	461a      	mov	r2, r3
 80a18ae:	f7ff f8dd 	bl	80a0a6c <HAL_USART_Init>
}
 80a18b2:	4620      	mov	r0, r4
 80a18b4:	bd10      	pop	{r4, pc}
 80a18b6:	bf00      	nop
 80a18b8:	080a7a18 	.word	0x080a7a18

080a18bc <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a18bc:	7c00      	ldrb	r0, [r0, #16]
 80a18be:	f7ff b905 	b.w	80a0acc <HAL_USART_Is_Enabled>
	...

080a18c4 <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a18c4:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a18c6:	4d0c      	ldr	r5, [pc, #48]	; (80a18f8 <_Z22__fetch_global_Serial1v+0x34>)
 80a18c8:	6829      	ldr	r1, [r5, #0]
 80a18ca:	f011 0401 	ands.w	r4, r1, #1
 80a18ce:	d111      	bne.n	80a18f4 <_Z22__fetch_global_Serial1v+0x30>
 80a18d0:	4628      	mov	r0, r5
 80a18d2:	f7fe fbe6 	bl	80a00a2 <__cxa_guard_acquire>
 80a18d6:	b168      	cbz	r0, 80a18f4 <_Z22__fetch_global_Serial1v+0x30>
 80a18d8:	4a08      	ldr	r2, [pc, #32]	; (80a18fc <_Z22__fetch_global_Serial1v+0x38>)
 80a18da:	4621      	mov	r1, r4
 80a18dc:	4b08      	ldr	r3, [pc, #32]	; (80a1900 <_Z22__fetch_global_Serial1v+0x3c>)
 80a18de:	4809      	ldr	r0, [pc, #36]	; (80a1904 <_Z22__fetch_global_Serial1v+0x40>)
 80a18e0:	f7ff ffd6 	bl	80a1890 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a18e4:	4628      	mov	r0, r5
 80a18e6:	f7fe fbe1 	bl	80a00ac <__cxa_guard_release>
 80a18ea:	4a07      	ldr	r2, [pc, #28]	; (80a1908 <_Z22__fetch_global_Serial1v+0x44>)
 80a18ec:	4907      	ldr	r1, [pc, #28]	; (80a190c <_Z22__fetch_global_Serial1v+0x48>)
 80a18ee:	4805      	ldr	r0, [pc, #20]	; (80a1904 <_Z22__fetch_global_Serial1v+0x40>)
 80a18f0:	f000 fb1e 	bl	80a1f30 <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a18f4:	4803      	ldr	r0, [pc, #12]	; (80a1904 <_Z22__fetch_global_Serial1v+0x40>)
 80a18f6:	bd38      	pop	{r3, r4, r5, pc}
 80a18f8:	20000270 	.word	0x20000270
 80a18fc:	20000274 	.word	0x20000274
 80a1900:	200001ec 	.word	0x200001ec
 80a1904:	200001d8 	.word	0x200001d8
 80a1908:	20000140 	.word	0x20000140
 80a190c:	080a180d 	.word	0x080a180d

080a1910 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a1910:	7441      	strb	r1, [r0, #17]
 80a1912:	4770      	bx	lr

080a1914 <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
 80a1914:	4770      	bx	lr

080a1916 <_ZN9USBSerial4readEv>:
}


// Read data from buffer
int USBSerial::read()
{
 80a1916:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
 80a1918:	2100      	movs	r1, #0
 80a191a:	7c00      	ldrb	r0, [r0, #16]
 80a191c:	f7ff f8fe 	bl	80a0b1c <HAL_USB_USART_Receive_Data>
}
 80a1920:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a1924:	bf28      	it	cs
 80a1926:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
 80a192a:	bd08      	pop	{r3, pc}

080a192c <_ZN9USBSerial4peekEv>:
{
  _blocking = block;
}

int USBSerial::peek()
{
 80a192c:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
 80a192e:	2101      	movs	r1, #1
 80a1930:	7c00      	ldrb	r0, [r0, #16]
 80a1932:	f7ff f8f3 	bl	80a0b1c <HAL_USB_USART_Receive_Data>
}
 80a1936:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a193a:	bf28      	it	cs
 80a193c:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
 80a1940:	bd08      	pop	{r3, pc}

080a1942 <_ZN9USBSerial17availableForWriteEv>:
{
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
}

int USBSerial::availableForWrite()
{
 80a1942:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
 80a1944:	7c00      	ldrb	r0, [r0, #16]
 80a1946:	f7ff f8e1 	bl	80a0b0c <HAL_USB_USART_Available_Data_For_Write>
}
 80a194a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a194e:	bd08      	pop	{r3, pc}

080a1950 <_ZN9USBSerial9availableEv>:

int USBSerial::available()
{
 80a1950:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
 80a1952:	7c00      	ldrb	r0, [r0, #16]
 80a1954:	f7ff f8d2 	bl	80a0afc <HAL_USB_USART_Available_Data>
}
 80a1958:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a195c:	bd08      	pop	{r3, pc}

080a195e <_ZN9USBSerial5flushEv>:
  return 0;
}

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a195e:	7c00      	ldrb	r0, [r0, #16]
 80a1960:	f7ff b8ec 	b.w	80a0b3c <HAL_USB_USART_Flush_Data>

080a1964 <_ZN9USBSerialD0Ev>:
 80a1964:	b510      	push	{r4, lr}
 80a1966:	4604      	mov	r4, r0
 80a1968:	2114      	movs	r1, #20
 80a196a:	f000 fae6 	bl	80a1f3a <_ZdlPvj>
 80a196e:	4620      	mov	r0, r4
 80a1970:	bd10      	pop	{r4, pc}

080a1972 <_ZN9USBSerial5writeEh>:
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
 80a1972:	b538      	push	{r3, r4, r5, lr}
 80a1974:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a1976:	7c00      	ldrb	r0, [r0, #16]
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
 80a1978:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a197a:	f7ff f8c7 	bl	80a0b0c <HAL_USB_USART_Available_Data_For_Write>
 80a197e:	2800      	cmp	r0, #0
 80a1980:	dc01      	bgt.n	80a1986 <_ZN9USBSerial5writeEh+0x14>
 80a1982:	7c60      	ldrb	r0, [r4, #17]
 80a1984:	b128      	cbz	r0, 80a1992 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
 80a1986:	4629      	mov	r1, r5
 80a1988:	7c20      	ldrb	r0, [r4, #16]
 80a198a:	f7ff f8cf 	bl	80a0b2c <HAL_USB_USART_Send_Data>
 80a198e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  }
  return 0;
}
 80a1992:	bd38      	pop	{r3, r4, r5, pc}

080a1994 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a1994:	b510      	push	{r4, lr}
 80a1996:	4604      	mov	r4, r0
 80a1998:	2300      	movs	r3, #0
 80a199a:	6063      	str	r3, [r4, #4]
 80a199c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a19a0:	60a3      	str	r3, [r4, #8]
 80a19a2:	4b05      	ldr	r3, [pc, #20]	; (80a19b8 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a19a4:	4608      	mov	r0, r1
 80a19a6:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a19a8:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a19aa:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a19ac:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a19ae:	4611      	mov	r1, r2
 80a19b0:	f7ff f89c 	bl	80a0aec <HAL_USB_USART_Init>
}
 80a19b4:	4620      	mov	r0, r4
 80a19b6:	bd10      	pop	{r4, pc}
 80a19b8:	080a7a48 	.word	0x080a7a48

080a19bc <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a19bc:	b510      	push	{r4, lr}
 80a19be:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a19c0:	2214      	movs	r2, #20
 80a19c2:	2100      	movs	r1, #0
 80a19c4:	f000 fc31 	bl	80a222a <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a19c8:	4b05      	ldr	r3, [pc, #20]	; (80a19e0 <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a19ca:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a19cc:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a19ce:	4b05      	ldr	r3, [pc, #20]	; (80a19e4 <_Z19acquireSerialBufferv+0x28>)
 80a19d0:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a19d2:	f240 1301 	movw	r3, #257	; 0x101
 80a19d6:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a19d8:	2381      	movs	r3, #129	; 0x81
 80a19da:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a19dc:	bd10      	pop	{r4, pc}
 80a19de:	bf00      	nop
 80a19e0:	2000037d 	.word	0x2000037d
 80a19e4:	200002fc 	.word	0x200002fc

080a19e8 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a19e8:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a19ea:	4d0e      	ldr	r5, [pc, #56]	; (80a1a24 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a19ec:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a19ee:	a801      	add	r0, sp, #4
 80a19f0:	f7ff ffe4 	bl	80a19bc <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a19f4:	6829      	ldr	r1, [r5, #0]
 80a19f6:	f011 0401 	ands.w	r4, r1, #1
 80a19fa:	d110      	bne.n	80a1a1e <_Z16_fetch_usbserialv+0x36>
 80a19fc:	4628      	mov	r0, r5
 80a19fe:	f7fe fb50 	bl	80a00a2 <__cxa_guard_acquire>
 80a1a02:	b160      	cbz	r0, 80a1a1e <_Z16_fetch_usbserialv+0x36>
 80a1a04:	aa01      	add	r2, sp, #4
 80a1a06:	4621      	mov	r1, r4
 80a1a08:	4807      	ldr	r0, [pc, #28]	; (80a1a28 <_Z16_fetch_usbserialv+0x40>)
 80a1a0a:	f7ff ffc3 	bl	80a1994 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a1a0e:	4628      	mov	r0, r5
 80a1a10:	f7fe fb4c 	bl	80a00ac <__cxa_guard_release>
 80a1a14:	4a05      	ldr	r2, [pc, #20]	; (80a1a2c <_Z16_fetch_usbserialv+0x44>)
 80a1a16:	4906      	ldr	r1, [pc, #24]	; (80a1a30 <_Z16_fetch_usbserialv+0x48>)
 80a1a18:	4803      	ldr	r0, [pc, #12]	; (80a1a28 <_Z16_fetch_usbserialv+0x40>)
 80a1a1a:	f000 fa89 	bl	80a1f30 <__aeabi_atexit>
	return _usbserial;
}
 80a1a1e:	4802      	ldr	r0, [pc, #8]	; (80a1a28 <_Z16_fetch_usbserialv+0x40>)
 80a1a20:	b007      	add	sp, #28
 80a1a22:	bd30      	pop	{r4, r5, pc}
 80a1a24:	200002f8 	.word	0x200002f8
 80a1a28:	20000480 	.word	0x20000480
 80a1a2c:	20000140 	.word	0x20000140
 80a1a30:	080a1915 	.word	0x080a1915

080a1a34 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a1a34:	b510      	push	{r4, lr}
 80a1a36:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a1a38:	2214      	movs	r2, #20
 80a1a3a:	2100      	movs	r1, #0
 80a1a3c:	f000 fbf5 	bl	80a222a <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a1a40:	4b05      	ldr	r3, [pc, #20]	; (80a1a58 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a1a42:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a1a44:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a1a46:	4b05      	ldr	r3, [pc, #20]	; (80a1a5c <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a1a48:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a1a4a:	f240 1301 	movw	r3, #257	; 0x101
 80a1a4e:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a1a50:	2381      	movs	r3, #129	; 0x81
 80a1a52:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a1a54:	bd10      	pop	{r4, pc}
 80a1a56:	bf00      	nop
 80a1a58:	20000530 	.word	0x20000530
 80a1a5c:	20000498 	.word	0x20000498

080a1a60 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a1a60:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a1a62:	4c0e      	ldr	r4, [pc, #56]	; (80a1a9c <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a1a64:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a1a66:	a801      	add	r0, sp, #4
 80a1a68:	f7ff ffe4 	bl	80a1a34 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a1a6c:	6823      	ldr	r3, [r4, #0]
 80a1a6e:	07db      	lsls	r3, r3, #31
 80a1a70:	d410      	bmi.n	80a1a94 <_Z17_fetch_usbserial1v+0x34>
 80a1a72:	4620      	mov	r0, r4
 80a1a74:	f7fe fb15 	bl	80a00a2 <__cxa_guard_acquire>
 80a1a78:	b160      	cbz	r0, 80a1a94 <_Z17_fetch_usbserial1v+0x34>
 80a1a7a:	aa01      	add	r2, sp, #4
 80a1a7c:	2101      	movs	r1, #1
 80a1a7e:	4808      	ldr	r0, [pc, #32]	; (80a1aa0 <_Z17_fetch_usbserial1v+0x40>)
 80a1a80:	f7ff ff88 	bl	80a1994 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a1a84:	4620      	mov	r0, r4
 80a1a86:	f7fe fb11 	bl	80a00ac <__cxa_guard_release>
 80a1a8a:	4a06      	ldr	r2, [pc, #24]	; (80a1aa4 <_Z17_fetch_usbserial1v+0x44>)
 80a1a8c:	4906      	ldr	r1, [pc, #24]	; (80a1aa8 <_Z17_fetch_usbserial1v+0x48>)
 80a1a8e:	4804      	ldr	r0, [pc, #16]	; (80a1aa0 <_Z17_fetch_usbserial1v+0x40>)
 80a1a90:	f000 fa4e 	bl	80a1f30 <__aeabi_atexit>
  return _usbserial1;
}
 80a1a94:	4802      	ldr	r0, [pc, #8]	; (80a1aa0 <_Z17_fetch_usbserial1v+0x40>)
 80a1a96:	b006      	add	sp, #24
 80a1a98:	bd10      	pop	{r4, pc}
 80a1a9a:	bf00      	nop
 80a1a9c:	20000494 	.word	0x20000494
 80a1aa0:	2000051c 	.word	0x2000051c
 80a1aa4:	20000140 	.word	0x20000140
 80a1aa8:	080a1915 	.word	0x080a1915

080a1aac <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a1aac:	2200      	movs	r2, #0
 80a1aae:	4611      	mov	r1, r2
 80a1ab0:	6840      	ldr	r0, [r0, #4]
 80a1ab2:	f7ff b8af 	b.w	80a0c14 <network_ready>

080a1ab6 <_ZN5spark9WiFiClass7resolveEPKc>:
    WLanSelectAntenna_TypeDef getAntenna() {
        return wlan_get_antenna(nullptr);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a1ab6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a1ab8:	4616      	mov	r6, r2
 80a1aba:	b089      	sub	sp, #36	; 0x24
    {
        HAL_IPAddress ip = {};
 80a1abc:	2211      	movs	r2, #17
    WLanSelectAntenna_TypeDef getAntenna() {
        return wlan_get_antenna(nullptr);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a1abe:	460f      	mov	r7, r1
 80a1ac0:	4604      	mov	r4, r0
    {
        HAL_IPAddress ip = {};
 80a1ac2:	2100      	movs	r1, #0
 80a1ac4:	a803      	add	r0, sp, #12
 80a1ac6:	f000 fbb0 	bl	80a222a <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a1aca:	4630      	mov	r0, r6
 80a1acc:	f000 fbf0 	bl	80a22b0 <strlen>
 80a1ad0:	2500      	movs	r5, #0
 80a1ad2:	9500      	str	r5, [sp, #0]
 80a1ad4:	b281      	uxth	r1, r0
 80a1ad6:	687b      	ldr	r3, [r7, #4]
 80a1ad8:	aa03      	add	r2, sp, #12
 80a1ada:	4630      	mov	r0, r6
 80a1adc:	f7ff f83e 	bl	80a0b5c <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a1ae0:	b120      	cbz	r0, 80a1aec <_ZN5spark9WiFiClass7resolveEPKc+0x36>
 80a1ae2:	4629      	mov	r1, r5
 80a1ae4:	4620      	mov	r0, r4
 80a1ae6:	f7ff f97d 	bl	80a0de4 <_ZN9IPAddressC1Em>
 80a1aea:	e003      	b.n	80a1af4 <_ZN5spark9WiFiClass7resolveEPKc+0x3e>
 80a1aec:	a903      	add	r1, sp, #12
 80a1aee:	4620      	mov	r0, r4
 80a1af0:	f7ff f966 	bl	80a0dc0 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    }
 80a1af4:	4620      	mov	r0, r4
 80a1af6:	b009      	add	sp, #36	; 0x24
 80a1af8:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a1afa <_ZN5spark9WiFiClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
 80a1afa:	2200      	movs	r2, #0
 80a1afc:	4611      	mov	r1, r2
 80a1afe:	6840      	ldr	r0, [r0, #4]
 80a1b00:	f7ff b8a8 	b.w	80a0c54 <network_listening>

080a1b04 <_ZN5spark9WiFiClass16getListenTimeoutEv>:
    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
    }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
 80a1b04:	2200      	movs	r2, #0
 80a1b06:	4611      	mov	r1, r2
 80a1b08:	6840      	ldr	r0, [r0, #4]
 80a1b0a:	f7ff b8b3 	b.w	80a0c74 <network_get_listen_timeout>

080a1b0e <_ZN5spark9WiFiClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
 80a1b0e:	2200      	movs	r2, #0
 80a1b10:	6840      	ldr	r0, [r0, #4]
 80a1b12:	f7ff b8a7 	b.w	80a0c64 <network_set_listen_timeout>

080a1b16 <_ZN5spark9WiFiClass6listenEb>:
    void off(void) {
        network_off(*this, 0, 0, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
 80a1b16:	2200      	movs	r2, #0
 80a1b18:	f081 0101 	eor.w	r1, r1, #1
 80a1b1c:	6840      	ldr	r0, [r0, #4]
 80a1b1e:	f7ff b891 	b.w	80a0c44 <network_listen>

080a1b22 <_ZN5spark9WiFiClass3offEv>:
    void on(void) {
        network_on(*this, 0, 0, NULL);
    }

    void off(void) {
        network_off(*this, 0, 0, NULL);
 80a1b22:	2300      	movs	r3, #0
 80a1b24:	461a      	mov	r2, r3
 80a1b26:	4619      	mov	r1, r3
 80a1b28:	6840      	ldr	r0, [r0, #4]
 80a1b2a:	f7ff b883 	b.w	80a0c34 <network_off>

080a1b2e <_ZN5spark9WiFiClass2onEv>:
    bool ready(void) {
        return network_ready(*this, 0, NULL);
    }

    void on(void) {
        network_on(*this, 0, 0, NULL);
 80a1b2e:	2300      	movs	r3, #0
 80a1b30:	461a      	mov	r2, r3
 80a1b32:	4619      	mov	r1, r3
 80a1b34:	6840      	ldr	r0, [r0, #4]
 80a1b36:	f7ff b875 	b.w	80a0c24 <network_on>

080a1b3a <_ZN5spark9WiFiClass10connectingEv>:
    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
    }

    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
 80a1b3a:	2200      	movs	r2, #0
 80a1b3c:	4611      	mov	r1, r2
 80a1b3e:	6840      	ldr	r0, [r0, #4]
 80a1b40:	f7ff b858 	b.w	80a0bf4 <network_connecting>

080a1b44 <_ZN5spark9WiFiClass10disconnectEv>:
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a1b44:	2200      	movs	r2, #0
 80a1b46:	2102      	movs	r1, #2
 80a1b48:	6840      	ldr	r0, [r0, #4]
 80a1b4a:	f7ff b85b 	b.w	80a0c04 <network_disconnect>

080a1b4e <_ZN5spark9WiFiClass7connectEj>:
    uint32_t ping(IPAddress remoteIP, uint8_t nTries) {
        return inet_ping(&remoteIP.raw(), *this, nTries, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
 80a1b4e:	2300      	movs	r3, #0
 80a1b50:	461a      	mov	r2, r3
 80a1b52:	6840      	ldr	r0, [r0, #4]
 80a1b54:	f7ff b846 	b.w	80a0be4 <network_connect>

080a1b58 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
 80a1b58:	4b02      	ldr	r3, [pc, #8]	; (80a1b64 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0xc>)
 80a1b5a:	2204      	movs	r2, #4
 80a1b5c:	605a      	str	r2, [r3, #4]
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() :
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
 80a1b5e:	4a02      	ldr	r2, [pc, #8]	; (80a1b68 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a1b60:	601a      	str	r2, [r3, #0]
 80a1b62:	4770      	bx	lr
 80a1b64:	20000634 	.word	0x20000634
 80a1b68:	080a7a78 	.word	0x080a7a78

080a1b6c <_Z11str_reversePc>:

//------------------------------------------------------------------------------------------
#define BUFSIZE (sizeof(long) * 8 + 1)

//utility function used by ultoa()
__attribute__((weak)) void str_reverse(char* buffer){
 80a1b6c:	b510      	push	{r4, lr}
 80a1b6e:	4604      	mov	r4, r0
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
 80a1b70:	f000 fb9e 	bl	80a22b0 <strlen>
 80a1b74:	3801      	subs	r0, #1
 80a1b76:	1823      	adds	r3, r4, r0
 80a1b78:	4620      	mov	r0, r4
	while(i<j){
 80a1b7a:	4298      	cmp	r0, r3
 80a1b7c:	d206      	bcs.n	80a1b8c <_Z11str_reversePc+0x20>
		c = *i;
 80a1b7e:	7802      	ldrb	r2, [r0, #0]
		*i = *j;
 80a1b80:	7819      	ldrb	r1, [r3, #0]
 80a1b82:	f800 1b01 	strb.w	r1, [r0], #1
		*j = c;
 80a1b86:	f803 2901 	strb.w	r2, [r3], #-1
__attribute__((weak)) void str_reverse(char* buffer){
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
	while(i<j){
 80a1b8a:	e7f6      	b.n	80a1b7a <_Z11str_reversePc+0xe>
 80a1b8c:	bd10      	pop	{r4, pc}

080a1b8e <ltoa>:
{
      int i = 2;
      long uarg;
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
 80a1b8e:	1e93      	subs	r3, r2, #2
            base = 10;                    /* can only use 0-9, A-Z        */
 80a1b90:	2b23      	cmp	r3, #35	; 0x23



//convert long to string
__attribute__((weak)) char *ltoa(long N, char *str, int base)
{
 80a1b92:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a1b96:	4615      	mov	r5, r2
      int i = 2;
      long uarg;
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
            base = 10;                    /* can only use 0-9, A-Z        */
 80a1b98:	bf34      	ite	cc
 80a1b9a:	4615      	movcc	r5, r2
 80a1b9c:	250a      	movcs	r5, #10



//convert long to string
__attribute__((weak)) char *ltoa(long N, char *str, int base)
{
 80a1b9e:	b08c      	sub	sp, #48	; 0x30
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
            base = 10;                    /* can only use 0-9, A-Z        */
      tail = &buf[BUFSIZE - 1];           /* last character position      */
      *tail-- = '\0';
 80a1ba0:	2300      	movs	r3, #0

      if (10 == base && N < 0L)
 80a1ba2:	2d0a      	cmp	r5, #10



//convert long to string
__attribute__((weak)) char *ltoa(long N, char *str, int base)
{
 80a1ba4:	460c      	mov	r4, r1
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
            base = 10;                    /* can only use 0-9, A-Z        */
      tail = &buf[BUFSIZE - 1];           /* last character position      */
      *tail-- = '\0';
 80a1ba6:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c

      if (10 == base && N < 0L)
 80a1baa:	d107      	bne.n	80a1bbc <ltoa+0x2e>
 80a1bac:	4298      	cmp	r0, r3
 80a1bae:	da05      	bge.n	80a1bbc <ltoa+0x2e>
      {
            *head++ = '-';
 80a1bb0:	232d      	movs	r3, #45	; 0x2d
 80a1bb2:	f101 0801 	add.w	r8, r1, #1
 80a1bb6:	700b      	strb	r3, [r1, #0]
            uarg    = -N;
 80a1bb8:	4240      	negs	r0, r0
 80a1bba:	e001      	b.n	80a1bc0 <ltoa+0x32>
      }
      else  uarg = N;

      if (uarg)
 80a1bbc:	b1a8      	cbz	r0, 80a1bea <ltoa+0x5c>
 80a1bbe:	46a0      	mov	r8, r4
 80a1bc0:	f10d 062b 	add.w	r6, sp, #43	; 0x2b
 80a1bc4:	2701      	movs	r7, #1
      {
            for (i = 1; uarg; ++i)
            {
                  ldiv_t r;

                  r       = ldiv(uarg, base);
 80a1bc6:	462a      	mov	r2, r5
 80a1bc8:	4601      	mov	r1, r0
 80a1bca:	a801      	add	r0, sp, #4
 80a1bcc:	f000 fb0e 	bl	80a21ec <ldiv>
 80a1bd0:	9a02      	ldr	r2, [sp, #8]
                  *tail-- = (char)(r.rem + ((9L < r.rem) ?
                                  ('A' - 10L) : '0'));
                  uarg    = r.quot;
 80a1bd2:	9801      	ldr	r0, [sp, #4]
            {
                  ldiv_t r;

                  r       = ldiv(uarg, base);
                  *tail-- = (char)(r.rem + ((9L < r.rem) ?
                                  ('A' - 10L) : '0'));
 80a1bd4:	2a09      	cmp	r2, #9
 80a1bd6:	bfcc      	ite	gt
 80a1bd8:	2337      	movgt	r3, #55	; 0x37
 80a1bda:	2330      	movle	r3, #48	; 0x30
 80a1bdc:	4413      	add	r3, r2
 80a1bde:	f806 3901 	strb.w	r3, [r6], #-1
      }
      else  uarg = N;

      if (uarg)
      {
            for (i = 1; uarg; ++i)
 80a1be2:	3701      	adds	r7, #1
 80a1be4:	2800      	cmp	r0, #0
 80a1be6:	d1ee      	bne.n	80a1bc6 <ltoa+0x38>
 80a1be8:	e006      	b.n	80a1bf8 <ltoa+0x6a>
                  *tail-- = (char)(r.rem + ((9L < r.rem) ?
                                  ('A' - 10L) : '0'));
                  uarg    = r.quot;
            }
      }
      else  *tail-- = '0';
 80a1bea:	46a0      	mov	r8, r4
 80a1bec:	2330      	movs	r3, #48	; 0x30
 80a1bee:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
 80a1bf2:	f10d 062a 	add.w	r6, sp, #42	; 0x2a


//convert long to string
__attribute__((weak)) char *ltoa(long N, char *str, int base)
{
      int i = 2;
 80a1bf6:	2702      	movs	r7, #2
                  uarg    = r.quot;
            }
      }
      else  *tail-- = '0';

      memcpy(head, ++tail, i);
 80a1bf8:	463a      	mov	r2, r7
 80a1bfa:	1c71      	adds	r1, r6, #1
 80a1bfc:	4640      	mov	r0, r8
 80a1bfe:	f000 fb09 	bl	80a2214 <memcpy>
      return str;
}
 80a1c02:	4620      	mov	r0, r4
 80a1c04:	b00c      	add	sp, #48	; 0x30
 80a1c06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a1c0a <ultoa>:

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
 80a1c0a:	b570      	push	{r4, r5, r6, lr}
 80a1c0c:	460c      	mov	r4, r1
	if(radix<2 || radix>36){
 80a1c0e:	1e91      	subs	r1, r2, #2
 80a1c10:	2922      	cmp	r1, #34	; 0x22
 80a1c12:	d820      	bhi.n	80a1c56 <ultoa+0x4c>
 80a1c14:	4625      	mov	r5, r4
 80a1c16:	4629      	mov	r1, r5
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
 80a1c18:	b910      	cbnz	r0, 80a1c20 <ultoa+0x16>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a1c1a:	4423      	add	r3, r4
            *ptr++ = '0';
 80a1c1c:	2230      	movs	r2, #48	; 0x30
 80a1c1e:	e00e      	b.n	80a1c3e <ultoa+0x34>
	div_t result;
	while(a){
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
 80a1c20:	fbb0 f6f2 	udiv	r6, r0, r2
            result.rem = a%radix;
 80a1c24:	fb02 0016 	mls	r0, r2, r6, r0
            *ptr = result.rem;
 80a1c28:	b2c1      	uxtb	r1, r0
            if(result.rem<10){
 80a1c2a:	2809      	cmp	r0, #9
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
            result.rem = a%radix;
            *ptr = result.rem;
 80a1c2c:	f805 1b01 	strb.w	r1, [r5], #1
            if(result.rem<10){
                *ptr += '0';
 80a1c30:	bf94      	ite	ls
 80a1c32:	3130      	addls	r1, #48	; 0x30
            }else{
                *ptr += 'a'-10;
 80a1c34:	3157      	addhi	r1, #87	; 0x57
 80a1c36:	f805 1c01 	strb.w	r1, [r5, #-1]
            }
            ++ptr;
            a = result.quot;
 80a1c3a:	4630      	mov	r0, r6
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
 80a1c3c:	e7eb      	b.n	80a1c16 <ultoa+0xc>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a1c3e:	4299      	cmp	r1, r3
 80a1c40:	d202      	bcs.n	80a1c48 <ultoa+0x3e>
            *ptr++ = '0';
 80a1c42:	f801 2b01 	strb.w	r2, [r1], #1
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a1c46:	e7fa      	b.n	80a1c3e <ultoa+0x34>
            *ptr++ = '0';

	*ptr = '\0';
 80a1c48:	2300      	movs	r3, #0
	str_reverse(buffer);
 80a1c4a:	4620      	mov	r0, r4
            a = result.quot;
	}
        while (ptr < buffer+pad)
            *ptr++ = '0';

	*ptr = '\0';
 80a1c4c:	700b      	strb	r3, [r1, #0]
	str_reverse(buffer);
 80a1c4e:	f7ff ff8d 	bl	80a1b6c <_Z11str_reversePc>
	return buffer;
 80a1c52:	4620      	mov	r0, r4
 80a1c54:	bd70      	pop	{r4, r5, r6, pc}
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
	if(radix<2 || radix>36){
		return NULL;
 80a1c56:	2000      	movs	r0, #0
            *ptr++ = '0';

	*ptr = '\0';
	str_reverse(buffer);
	return buffer;
}
 80a1c58:	bd70      	pop	{r4, r5, r6, pc}
	...

080a1c5c <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a1c5c:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a1c5e:	4b14      	ldr	r3, [pc, #80]	; (80a1cb0 <serialEventRun+0x54>)
 80a1c60:	b133      	cbz	r3, 80a1c70 <serialEventRun+0x14>
 80a1c62:	f7ff fec1 	bl	80a19e8 <_Z16_fetch_usbserialv>
 80a1c66:	6803      	ldr	r3, [r0, #0]
 80a1c68:	691b      	ldr	r3, [r3, #16]
 80a1c6a:	4798      	blx	r3
 80a1c6c:	2800      	cmp	r0, #0
 80a1c6e:	dc16      	bgt.n	80a1c9e <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a1c70:	4b10      	ldr	r3, [pc, #64]	; (80a1cb4 <serialEventRun+0x58>)
 80a1c72:	b133      	cbz	r3, 80a1c82 <serialEventRun+0x26>
 80a1c74:	f7ff fe26 	bl	80a18c4 <_Z22__fetch_global_Serial1v>
 80a1c78:	6803      	ldr	r3, [r0, #0]
 80a1c7a:	691b      	ldr	r3, [r3, #16]
 80a1c7c:	4798      	blx	r3
 80a1c7e:	2800      	cmp	r0, #0
 80a1c80:	dc10      	bgt.n	80a1ca4 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a1c82:	4b0d      	ldr	r3, [pc, #52]	; (80a1cb8 <serialEventRun+0x5c>)
 80a1c84:	b10b      	cbz	r3, 80a1c8a <serialEventRun+0x2e>
 80a1c86:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a1c8a:	4b0c      	ldr	r3, [pc, #48]	; (80a1cbc <serialEventRun+0x60>)
 80a1c8c:	b17b      	cbz	r3, 80a1cae <serialEventRun+0x52>
 80a1c8e:	f7ff fee7 	bl	80a1a60 <_Z17_fetch_usbserial1v>
 80a1c92:	6803      	ldr	r3, [r0, #0]
 80a1c94:	691b      	ldr	r3, [r3, #16]
 80a1c96:	4798      	blx	r3
 80a1c98:	2800      	cmp	r0, #0
 80a1c9a:	dc06      	bgt.n	80a1caa <serialEventRun+0x4e>
 80a1c9c:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a1c9e:	f3af 8000 	nop.w
 80a1ca2:	e7e5      	b.n	80a1c70 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a1ca4:	f3af 8000 	nop.w
 80a1ca8:	e7eb      	b.n	80a1c82 <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a1caa:	f3af 8000 	nop.w
 80a1cae:	bd08      	pop	{r3, pc}
	...

080a1cc0 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a1cc0:	b508      	push	{r3, lr}
	serialEventRun();
 80a1cc2:	f7ff ffcb 	bl	80a1c5c <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a1cc6:	f7fe fde7 	bl	80a0898 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a1cca:	4b01      	ldr	r3, [pc, #4]	; (80a1cd0 <_post_loop+0x10>)
 80a1ccc:	6018      	str	r0, [r3, #0]
 80a1cce:	bd08      	pop	{r3, pc}
 80a1cd0:	20000644 	.word	0x20000644

080a1cd4 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a1cd4:	4802      	ldr	r0, [pc, #8]	; (80a1ce0 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a1cd6:	4a03      	ldr	r2, [pc, #12]	; (80a1ce4 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a1cd8:	4903      	ldr	r1, [pc, #12]	; (80a1ce8 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a1cda:	1a12      	subs	r2, r2, r0
 80a1cdc:	f000 ba9a 	b.w	80a2214 <memcpy>
 80a1ce0:	40024000 	.word	0x40024000
 80a1ce4:	400244b8 	.word	0x400244b8
 80a1ce8:	080a7b50 	.word	0x080a7b50

080a1cec <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a1cec:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1cee:	2300      	movs	r3, #0
 80a1cf0:	9300      	str	r3, [sp, #0]
 80a1cf2:	461a      	mov	r2, r3
 80a1cf4:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a1cf8:	f7fe ff62 	bl	80a0bc0 <system_ctrl_set_result>
}
 80a1cfc:	b003      	add	sp, #12
 80a1cfe:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a1d04 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a1d04:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a1d06:	8843      	ldrh	r3, [r0, #2]
 80a1d08:	2b0a      	cmp	r3, #10
 80a1d0a:	d008      	beq.n	80a1d1e <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a1d0c:	2b50      	cmp	r3, #80	; 0x50
 80a1d0e:	d109      	bne.n	80a1d24 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a1d10:	4b09      	ldr	r3, [pc, #36]	; (80a1d38 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a1d12:	681b      	ldr	r3, [r3, #0]
 80a1d14:	b13b      	cbz	r3, 80a1d26 <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a1d16:	b003      	add	sp, #12
 80a1d18:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a1d1c:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a1d1e:	f7ff ffe5 	bl	80a1cec <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a1d22:	e006      	b.n	80a1d32 <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1d24:	2300      	movs	r3, #0
 80a1d26:	9300      	str	r3, [sp, #0]
 80a1d28:	461a      	mov	r2, r3
 80a1d2a:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a1d2e:	f7fe ff47 	bl	80a0bc0 <system_ctrl_set_result>
        break;
    }
}
 80a1d32:	b003      	add	sp, #12
 80a1d34:	f85d fb04 	ldr.w	pc, [sp], #4
 80a1d38:	2000063c 	.word	0x2000063c

080a1d3c <module_user_init_hook>:

void module_user_init_hook()
{
 80a1d3c:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a1d3e:	4c10      	ldr	r4, [pc, #64]	; (80a1d80 <module_user_init_hook+0x44>)
 80a1d40:	4d10      	ldr	r5, [pc, #64]	; (80a1d84 <module_user_init_hook+0x48>)
 80a1d42:	6823      	ldr	r3, [r4, #0]
 80a1d44:	42ab      	cmp	r3, r5
 80a1d46:	4b10      	ldr	r3, [pc, #64]	; (80a1d88 <module_user_init_hook+0x4c>)
 80a1d48:	bf0c      	ite	eq
 80a1d4a:	2201      	moveq	r2, #1
 80a1d4c:	2200      	movne	r2, #0
 80a1d4e:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a1d50:	d002      	beq.n	80a1d58 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a1d52:	f7ff ffbf 	bl	80a1cd4 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a1d56:	6025      	str	r5, [r4, #0]
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
 80a1d58:	f7fe fd96 	bl	80a0888 <HAL_RNG_GetRandomNumber>
 80a1d5c:	4604      	mov	r4, r0
    srand(seed);
 80a1d5e:	f000 fa6d 	bl	80a223c <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a1d62:	4b0a      	ldr	r3, [pc, #40]	; (80a1d8c <module_user_init_hook+0x50>)
 80a1d64:	b113      	cbz	r3, 80a1d6c <module_user_init_hook+0x30>
        random_seed_from_cloud(seed);
 80a1d66:	4620      	mov	r0, r4
 80a1d68:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a1d6c:	2100      	movs	r1, #0
 80a1d6e:	4807      	ldr	r0, [pc, #28]	; (80a1d8c <module_user_init_hook+0x50>)
 80a1d70:	f7fe ff30 	bl	80a0bd4 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a1d74:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a1d78:	2100      	movs	r1, #0
 80a1d7a:	4805      	ldr	r0, [pc, #20]	; (80a1d90 <module_user_init_hook+0x54>)
 80a1d7c:	f7fe bf16 	b.w	80a0bac <system_ctrl_set_app_request_handler>
 80a1d80:	400244b4 	.word	0x400244b4
 80a1d84:	9a271c1e 	.word	0x9a271c1e
 80a1d88:	20000640 	.word	0x20000640
 80a1d8c:	00000000 	.word	0x00000000
 80a1d90:	080a1d05 	.word	0x080a1d05

080a1d94 <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a1d94:	b510      	push	{r4, lr}
 80a1d96:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a1d98:	480f      	ldr	r0, [pc, #60]	; (80a1dd8 <pinAvailable+0x44>)
 80a1d9a:	f7ff f9cf 	bl	80a113c <_ZN8SPIClass9isEnabledEv>
 80a1d9e:	b128      	cbz	r0, 80a1dac <pinAvailable+0x18>
 80a1da0:	f1a4 030d 	sub.w	r3, r4, #13
 80a1da4:	2b02      	cmp	r3, #2
 80a1da6:	d801      	bhi.n	80a1dac <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a1da8:	2000      	movs	r0, #0
 80a1daa:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a1dac:	f000 f866 	bl	80a1e7c <_Z19__fetch_global_Wirev>
 80a1db0:	f7fe ffd2 	bl	80a0d58 <_ZN7TwoWire9isEnabledEv>
 80a1db4:	b108      	cbz	r0, 80a1dba <pinAvailable+0x26>
 80a1db6:	2c01      	cmp	r4, #1
 80a1db8:	d9f6      	bls.n	80a1da8 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a1dba:	f7ff fd83 	bl	80a18c4 <_Z22__fetch_global_Serial1v>
 80a1dbe:	f7ff fd7d 	bl	80a18bc <_ZN11USARTSerial9isEnabledEv>
 80a1dc2:	b118      	cbz	r0, 80a1dcc <pinAvailable+0x38>
 80a1dc4:	f1a4 0312 	sub.w	r3, r4, #18
 80a1dc8:	2b01      	cmp	r3, #1
 80a1dca:	d9ed      	bls.n	80a1da8 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a1dcc:	2c17      	cmp	r4, #23
 80a1dce:	bf8c      	ite	hi
 80a1dd0:	2000      	movhi	r0, #0
 80a1dd2:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a1dd4:	bd10      	pop	{r4, pc}
 80a1dd6:	bf00      	nop
 80a1dd8:	20000680 	.word	0x20000680

080a1ddc <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a1ddc:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a1dde:	b538      	push	{r3, r4, r5, lr}
 80a1de0:	4604      	mov	r4, r0
 80a1de2:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a1de4:	d80a      	bhi.n	80a1dfc <pinMode+0x20>
 80a1de6:	29ff      	cmp	r1, #255	; 0xff
 80a1de8:	d008      	beq.n	80a1dfc <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a1dea:	f7ff ffd3 	bl	80a1d94 <pinAvailable>
 80a1dee:	b128      	cbz	r0, 80a1dfc <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a1df0:	4629      	mov	r1, r5
 80a1df2:	4620      	mov	r0, r4
}
 80a1df4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a1df8:	f7fe bd8e 	b.w	80a0918 <HAL_Pin_Mode>
 80a1dfc:	bd38      	pop	{r3, r4, r5, pc}

080a1dfe <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
 80a1dfe:	b510      	push	{r4, lr}
 80a1e00:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a1e02:	f7fe fd91 	bl	80a0928 <HAL_Get_Pin_Mode>
    if (is_af_output_mode(mode))
 80a1e06:	3804      	subs	r0, #4
 80a1e08:	b2c0      	uxtb	r0, r0
 80a1e0a:	2801      	cmp	r0, #1
 80a1e0c:	d908      	bls.n	80a1e20 <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
 80a1e0e:	4620      	mov	r0, r4
 80a1e10:	f7ff ffc0 	bl	80a1d94 <pinAvailable>
 80a1e14:	b120      	cbz	r0, 80a1e20 <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a1e16:	4620      	mov	r0, r4
}
 80a1e18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    // Safety check
    if( !pinAvailable(pin) ) {
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a1e1c:	f7fe bd8c 	b.w	80a0938 <HAL_GPIO_Read>
}
 80a1e20:	2000      	movs	r0, #0
 80a1e22:	bd10      	pop	{r4, pc}

080a1e24 <analogRead>:
 * @brief Read the analog value of a pin.
 * Should return a 16-bit value, 0-65536 (0 = LOW, 65536 = HIGH)
 * Note: ADC is 12-bit. Currently it returns 0-4095
 */
int32_t analogRead(pin_t pin)
{
 80a1e24:	b510      	push	{r4, lr}
 80a1e26:	4604      	mov	r4, r0
  // Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
  if(pin < FIRST_ANALOG_PIN)
 80a1e28:	2809      	cmp	r0, #9
  {
    pin = pin + FIRST_ANALOG_PIN;
 80a1e2a:	bf9c      	itt	ls
 80a1e2c:	340a      	addls	r4, #10
 80a1e2e:	b2a4      	uxthls	r4, r4
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a1e30:	4620      	mov	r0, r4
 80a1e32:	f7ff ffaf 	bl	80a1d94 <pinAvailable>
 80a1e36:	b150      	cbz	r0, 80a1e4e <analogRead+0x2a>
    return LOW;
  }

  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
 80a1e38:	2103      	movs	r1, #3
 80a1e3a:	4620      	mov	r0, r4
 80a1e3c:	f7fe fd64 	bl	80a0908 <HAL_Validate_Pin_Function>
 80a1e40:	2803      	cmp	r0, #3
 80a1e42:	d104      	bne.n	80a1e4e <analogRead+0x2a>
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a1e44:	4620      	mov	r0, r4
}
 80a1e46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a1e4a:	f7fe bd7d 	b.w	80a0948 <HAL_ADC_Read>
}
 80a1e4e:	2000      	movs	r0, #0
 80a1e50:	bd10      	pop	{r4, pc}
	...

080a1e54 <_Z21__fetch_global_EEPROMv>:

// we don't use this global instance since there's no actual instance data
// Having this keeps the unoptimized build happy

EEPROMClass& __fetch_global_EEPROM()
{
 80a1e54:	b510      	push	{r4, lr}
	static EEPROMClass eeprom;
 80a1e56:	4c07      	ldr	r4, [pc, #28]	; (80a1e74 <_Z21__fetch_global_EEPROMv+0x20>)
 80a1e58:	6823      	ldr	r3, [r4, #0]
 80a1e5a:	07db      	lsls	r3, r3, #31
 80a1e5c:	d408      	bmi.n	80a1e70 <_Z21__fetch_global_EEPROMv+0x1c>
 80a1e5e:	4620      	mov	r0, r4
 80a1e60:	f7fe f91f 	bl	80a00a2 <__cxa_guard_acquire>
 80a1e64:	b120      	cbz	r0, 80a1e70 <_Z21__fetch_global_EEPROMv+0x1c>

struct EEPROMClass{

	EEPROMClass()
    {
    		HAL_EEPROM_Init();
 80a1e66:	f7fe fd1f 	bl	80a08a8 <HAL_EEPROM_Init>
 80a1e6a:	4620      	mov	r0, r4
 80a1e6c:	f7fe f91e 	bl	80a00ac <__cxa_guard_release>
	return eeprom;
}
 80a1e70:	4801      	ldr	r0, [pc, #4]	; (80a1e78 <_Z21__fetch_global_EEPROMv+0x24>)
 80a1e72:	bd10      	pop	{r4, pc}
 80a1e74:	20000648 	.word	0x20000648
 80a1e78:	2000064c 	.word	0x2000064c

080a1e7c <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a1e7c:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a1e7e:	4d0b      	ldr	r5, [pc, #44]	; (80a1eac <_Z19__fetch_global_Wirev+0x30>)
 80a1e80:	6829      	ldr	r1, [r5, #0]
 80a1e82:	f011 0401 	ands.w	r4, r1, #1
 80a1e86:	d10f      	bne.n	80a1ea8 <_Z19__fetch_global_Wirev+0x2c>
 80a1e88:	4628      	mov	r0, r5
 80a1e8a:	f7fe f90a 	bl	80a00a2 <__cxa_guard_acquire>
 80a1e8e:	b158      	cbz	r0, 80a1ea8 <_Z19__fetch_global_Wirev+0x2c>
 80a1e90:	4621      	mov	r1, r4
 80a1e92:	4807      	ldr	r0, [pc, #28]	; (80a1eb0 <_Z19__fetch_global_Wirev+0x34>)
 80a1e94:	f7fe ff4e 	bl	80a0d34 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a1e98:	4628      	mov	r0, r5
 80a1e9a:	f7fe f907 	bl	80a00ac <__cxa_guard_release>
 80a1e9e:	4a05      	ldr	r2, [pc, #20]	; (80a1eb4 <_Z19__fetch_global_Wirev+0x38>)
 80a1ea0:	4905      	ldr	r1, [pc, #20]	; (80a1eb8 <_Z19__fetch_global_Wirev+0x3c>)
 80a1ea2:	4803      	ldr	r0, [pc, #12]	; (80a1eb0 <_Z19__fetch_global_Wirev+0x34>)
 80a1ea4:	f000 f844 	bl	80a1f30 <__aeabi_atexit>
	return wire;
}
 80a1ea8:	4801      	ldr	r0, [pc, #4]	; (80a1eb0 <_Z19__fetch_global_Wirev+0x34>)
 80a1eaa:	bd38      	pop	{r3, r4, r5, pc}
 80a1eac:	20000650 	.word	0x20000650
 80a1eb0:	20000654 	.word	0x20000654
 80a1eb4:	20000140 	.word	0x20000140
 80a1eb8:	080a0cdd 	.word	0x080a0cdd

080a1ebc <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

#if !HAL_USE_SOCKET_HAL_POSIX
const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a1ebc:	b513      	push	{r0, r1, r4, lr}
 80a1ebe:	4c08      	ldr	r4, [pc, #32]	; (80a1ee0 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a1ec0:	2300      	movs	r3, #0
 80a1ec2:	461a      	mov	r2, r3
 80a1ec4:	4619      	mov	r1, r3
 80a1ec6:	9300      	str	r3, [sp, #0]
 80a1ec8:	4620      	mov	r0, r4
 80a1eca:	f7fe ffa1 	bl	80a0e10 <_ZN9IPAddressC1Ehhhh>
 80a1ece:	4620      	mov	r0, r4
 80a1ed0:	4a04      	ldr	r2, [pc, #16]	; (80a1ee4 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a1ed2:	4905      	ldr	r1, [pc, #20]	; (80a1ee8 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a1ed4:	b002      	add	sp, #8
 80a1ed6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a1eda:	f000 b829 	b.w	80a1f30 <__aeabi_atexit>
 80a1ede:	bf00      	nop
 80a1ee0:	20000668 	.word	0x20000668
 80a1ee4:	20000140 	.word	0x20000140
 80a1ee8:	080a0d61 	.word	0x080a0d61

080a1eec <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a1eec:	b570      	push	{r4, r5, r6, lr}
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a1eee:	4c0c      	ldr	r4, [pc, #48]	; (80a1f20 <_GLOBAL__sub_I_SPI+0x34>)
 80a1ef0:	4e0c      	ldr	r6, [pc, #48]	; (80a1f24 <_GLOBAL__sub_I_SPI+0x38>)
 80a1ef2:	4d0d      	ldr	r5, [pc, #52]	; (80a1f28 <_GLOBAL__sub_I_SPI+0x3c>)
 80a1ef4:	2100      	movs	r1, #0
 80a1ef6:	4620      	mov	r0, r4
 80a1ef8:	f7ff f90c 	bl	80a1114 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a1efc:	4620      	mov	r0, r4

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a1efe:	4c0b      	ldr	r4, [pc, #44]	; (80a1f2c <_GLOBAL__sub_I_SPI+0x40>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a1f00:	4632      	mov	r2, r6
 80a1f02:	4629      	mov	r1, r5
 80a1f04:	f000 f814 	bl	80a1f30 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a1f08:	2101      	movs	r1, #1
 80a1f0a:	4620      	mov	r0, r4
 80a1f0c:	f7ff f902 	bl	80a1114 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a1f10:	4632      	mov	r2, r6
 80a1f12:	4629      	mov	r1, r5
 80a1f14:	4620      	mov	r0, r4
 80a1f16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a1f1a:	f000 b809 	b.w	80a1f30 <__aeabi_atexit>
 80a1f1e:	bf00      	nop
 80a1f20:	20000680 	.word	0x20000680
 80a1f24:	20000140 	.word	0x20000140
 80a1f28:	080a1105 	.word	0x080a1105
 80a1f2c:	20000690 	.word	0x20000690

080a1f30 <__aeabi_atexit>:
 80a1f30:	460b      	mov	r3, r1
 80a1f32:	4601      	mov	r1, r0
 80a1f34:	4618      	mov	r0, r3
 80a1f36:	f000 b94b 	b.w	80a21d0 <__cxa_atexit>

080a1f3a <_ZdlPvj>:
 80a1f3a:	f7fe b8b0 	b.w	80a009e <_ZdlPv>
	...

080a1f40 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a1f40:	4b24      	ldr	r3, [pc, #144]	; (80a1fd4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a1f42:	681a      	ldr	r2, [r3, #0]
 80a1f44:	07d0      	lsls	r0, r2, #31
 80a1f46:	bf5c      	itt	pl
 80a1f48:	2201      	movpl	r2, #1
 80a1f4a:	601a      	strpl	r2, [r3, #0]
 80a1f4c:	4b22      	ldr	r3, [pc, #136]	; (80a1fd8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a1f4e:	681a      	ldr	r2, [r3, #0]
 80a1f50:	07d1      	lsls	r1, r2, #31
 80a1f52:	bf5c      	itt	pl
 80a1f54:	2201      	movpl	r2, #1
 80a1f56:	601a      	strpl	r2, [r3, #0]
 80a1f58:	4b20      	ldr	r3, [pc, #128]	; (80a1fdc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a1f5a:	681a      	ldr	r2, [r3, #0]
 80a1f5c:	07d2      	lsls	r2, r2, #31
 80a1f5e:	bf5c      	itt	pl
 80a1f60:	2201      	movpl	r2, #1
 80a1f62:	601a      	strpl	r2, [r3, #0]
 80a1f64:	4b1e      	ldr	r3, [pc, #120]	; (80a1fe0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a1f66:	681a      	ldr	r2, [r3, #0]
 80a1f68:	07d0      	lsls	r0, r2, #31
 80a1f6a:	bf5c      	itt	pl
 80a1f6c:	2201      	movpl	r2, #1
 80a1f6e:	601a      	strpl	r2, [r3, #0]
 80a1f70:	4b1c      	ldr	r3, [pc, #112]	; (80a1fe4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a1f72:	681a      	ldr	r2, [r3, #0]
 80a1f74:	07d1      	lsls	r1, r2, #31
 80a1f76:	bf5c      	itt	pl
 80a1f78:	2201      	movpl	r2, #1
 80a1f7a:	601a      	strpl	r2, [r3, #0]
 80a1f7c:	4b1a      	ldr	r3, [pc, #104]	; (80a1fe8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a1f7e:	681a      	ldr	r2, [r3, #0]
 80a1f80:	07d2      	lsls	r2, r2, #31
 80a1f82:	bf5c      	itt	pl
 80a1f84:	2201      	movpl	r2, #1
 80a1f86:	601a      	strpl	r2, [r3, #0]
 80a1f88:	4b18      	ldr	r3, [pc, #96]	; (80a1fec <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a1f8a:	681a      	ldr	r2, [r3, #0]
 80a1f8c:	07d0      	lsls	r0, r2, #31
 80a1f8e:	bf5c      	itt	pl
 80a1f90:	2201      	movpl	r2, #1
 80a1f92:	601a      	strpl	r2, [r3, #0]
 80a1f94:	4b16      	ldr	r3, [pc, #88]	; (80a1ff0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a1f96:	681a      	ldr	r2, [r3, #0]
 80a1f98:	07d1      	lsls	r1, r2, #31
 80a1f9a:	bf5c      	itt	pl
 80a1f9c:	2201      	movpl	r2, #1
 80a1f9e:	601a      	strpl	r2, [r3, #0]
 80a1fa0:	4b14      	ldr	r3, [pc, #80]	; (80a1ff4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a1fa2:	681a      	ldr	r2, [r3, #0]
 80a1fa4:	07d2      	lsls	r2, r2, #31
 80a1fa6:	bf5c      	itt	pl
 80a1fa8:	2201      	movpl	r2, #1
 80a1faa:	601a      	strpl	r2, [r3, #0]
 80a1fac:	4b12      	ldr	r3, [pc, #72]	; (80a1ff8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a1fae:	681a      	ldr	r2, [r3, #0]
 80a1fb0:	07d0      	lsls	r0, r2, #31
 80a1fb2:	bf5c      	itt	pl
 80a1fb4:	2201      	movpl	r2, #1
 80a1fb6:	601a      	strpl	r2, [r3, #0]
 80a1fb8:	4b10      	ldr	r3, [pc, #64]	; (80a1ffc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a1fba:	681a      	ldr	r2, [r3, #0]
 80a1fbc:	07d1      	lsls	r1, r2, #31
 80a1fbe:	bf5c      	itt	pl
 80a1fc0:	2201      	movpl	r2, #1
 80a1fc2:	601a      	strpl	r2, [r3, #0]
 80a1fc4:	4b0e      	ldr	r3, [pc, #56]	; (80a2000 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a1fc6:	681a      	ldr	r2, [r3, #0]
 80a1fc8:	07d2      	lsls	r2, r2, #31
 80a1fca:	bf5c      	itt	pl
 80a1fcc:	2201      	movpl	r2, #1
 80a1fce:	601a      	strpl	r2, [r3, #0]
 80a1fd0:	4770      	bx	lr
 80a1fd2:	bf00      	nop
 80a1fd4:	200006cc 	.word	0x200006cc
 80a1fd8:	200006c8 	.word	0x200006c8
 80a1fdc:	200006c4 	.word	0x200006c4
 80a1fe0:	200006c0 	.word	0x200006c0
 80a1fe4:	200006bc 	.word	0x200006bc
 80a1fe8:	200006b8 	.word	0x200006b8
 80a1fec:	200006b4 	.word	0x200006b4
 80a1ff0:	200006b0 	.word	0x200006b0
 80a1ff4:	200006ac 	.word	0x200006ac
 80a1ff8:	200006a8 	.word	0x200006a8
 80a1ffc:	200006a4 	.word	0x200006a4
 80a2000:	200006a0 	.word	0x200006a0

080a2004 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a2004:	4b18      	ldr	r3, [pc, #96]	; (80a2068 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a2006:	681a      	ldr	r2, [r3, #0]
 80a2008:	07d1      	lsls	r1, r2, #31
 80a200a:	bf5c      	itt	pl
 80a200c:	2201      	movpl	r2, #1
 80a200e:	601a      	strpl	r2, [r3, #0]
 80a2010:	4b16      	ldr	r3, [pc, #88]	; (80a206c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a2012:	681a      	ldr	r2, [r3, #0]
 80a2014:	07d2      	lsls	r2, r2, #31
 80a2016:	bf5c      	itt	pl
 80a2018:	2201      	movpl	r2, #1
 80a201a:	601a      	strpl	r2, [r3, #0]
 80a201c:	4b14      	ldr	r3, [pc, #80]	; (80a2070 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a201e:	681a      	ldr	r2, [r3, #0]
 80a2020:	07d0      	lsls	r0, r2, #31
 80a2022:	bf5c      	itt	pl
 80a2024:	2201      	movpl	r2, #1
 80a2026:	601a      	strpl	r2, [r3, #0]
 80a2028:	4b12      	ldr	r3, [pc, #72]	; (80a2074 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a202a:	681a      	ldr	r2, [r3, #0]
 80a202c:	07d1      	lsls	r1, r2, #31
 80a202e:	bf5c      	itt	pl
 80a2030:	2201      	movpl	r2, #1
 80a2032:	601a      	strpl	r2, [r3, #0]
 80a2034:	4b10      	ldr	r3, [pc, #64]	; (80a2078 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a2036:	681a      	ldr	r2, [r3, #0]
 80a2038:	07d2      	lsls	r2, r2, #31
 80a203a:	bf5c      	itt	pl
 80a203c:	2201      	movpl	r2, #1
 80a203e:	601a      	strpl	r2, [r3, #0]
 80a2040:	4b0e      	ldr	r3, [pc, #56]	; (80a207c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a2042:	681a      	ldr	r2, [r3, #0]
 80a2044:	07d0      	lsls	r0, r2, #31
 80a2046:	bf5c      	itt	pl
 80a2048:	2201      	movpl	r2, #1
 80a204a:	601a      	strpl	r2, [r3, #0]
 80a204c:	4b0c      	ldr	r3, [pc, #48]	; (80a2080 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a204e:	681a      	ldr	r2, [r3, #0]
 80a2050:	07d1      	lsls	r1, r2, #31
 80a2052:	bf5c      	itt	pl
 80a2054:	2201      	movpl	r2, #1
 80a2056:	601a      	strpl	r2, [r3, #0]
 80a2058:	4b0a      	ldr	r3, [pc, #40]	; (80a2084 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a205a:	681a      	ldr	r2, [r3, #0]
 80a205c:	07d2      	lsls	r2, r2, #31
 80a205e:	bf5c      	itt	pl
 80a2060:	2201      	movpl	r2, #1
 80a2062:	601a      	strpl	r2, [r3, #0]
 80a2064:	4770      	bx	lr
 80a2066:	bf00      	nop
 80a2068:	200006ec 	.word	0x200006ec
 80a206c:	200006e8 	.word	0x200006e8
 80a2070:	200006e4 	.word	0x200006e4
 80a2074:	200006e0 	.word	0x200006e0
 80a2078:	200006dc 	.word	0x200006dc
 80a207c:	200006d8 	.word	0x200006d8
 80a2080:	200006d4 	.word	0x200006d4
 80a2084:	200006d0 	.word	0x200006d0

080a2088 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a2088:	4b18      	ldr	r3, [pc, #96]	; (80a20ec <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a208a:	681a      	ldr	r2, [r3, #0]
 80a208c:	07d1      	lsls	r1, r2, #31
 80a208e:	bf5c      	itt	pl
 80a2090:	2201      	movpl	r2, #1
 80a2092:	601a      	strpl	r2, [r3, #0]
 80a2094:	4b16      	ldr	r3, [pc, #88]	; (80a20f0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a2096:	681a      	ldr	r2, [r3, #0]
 80a2098:	07d2      	lsls	r2, r2, #31
 80a209a:	bf5c      	itt	pl
 80a209c:	2201      	movpl	r2, #1
 80a209e:	601a      	strpl	r2, [r3, #0]
 80a20a0:	4b14      	ldr	r3, [pc, #80]	; (80a20f4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a20a2:	681a      	ldr	r2, [r3, #0]
 80a20a4:	07d0      	lsls	r0, r2, #31
 80a20a6:	bf5c      	itt	pl
 80a20a8:	2201      	movpl	r2, #1
 80a20aa:	601a      	strpl	r2, [r3, #0]
 80a20ac:	4b12      	ldr	r3, [pc, #72]	; (80a20f8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a20ae:	681a      	ldr	r2, [r3, #0]
 80a20b0:	07d1      	lsls	r1, r2, #31
 80a20b2:	bf5c      	itt	pl
 80a20b4:	2201      	movpl	r2, #1
 80a20b6:	601a      	strpl	r2, [r3, #0]
 80a20b8:	4b10      	ldr	r3, [pc, #64]	; (80a20fc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a20ba:	681a      	ldr	r2, [r3, #0]
 80a20bc:	07d2      	lsls	r2, r2, #31
 80a20be:	bf5c      	itt	pl
 80a20c0:	2201      	movpl	r2, #1
 80a20c2:	601a      	strpl	r2, [r3, #0]
 80a20c4:	4b0e      	ldr	r3, [pc, #56]	; (80a2100 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a20c6:	681a      	ldr	r2, [r3, #0]
 80a20c8:	07d0      	lsls	r0, r2, #31
 80a20ca:	bf5c      	itt	pl
 80a20cc:	2201      	movpl	r2, #1
 80a20ce:	601a      	strpl	r2, [r3, #0]
 80a20d0:	4b0c      	ldr	r3, [pc, #48]	; (80a2104 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a20d2:	681a      	ldr	r2, [r3, #0]
 80a20d4:	07d1      	lsls	r1, r2, #31
 80a20d6:	bf5c      	itt	pl
 80a20d8:	2201      	movpl	r2, #1
 80a20da:	601a      	strpl	r2, [r3, #0]
 80a20dc:	4b0a      	ldr	r3, [pc, #40]	; (80a2108 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a20de:	681a      	ldr	r2, [r3, #0]
 80a20e0:	07d2      	lsls	r2, r2, #31
 80a20e2:	bf5c      	itt	pl
 80a20e4:	2201      	movpl	r2, #1
 80a20e6:	601a      	strpl	r2, [r3, #0]
 80a20e8:	4770      	bx	lr
 80a20ea:	bf00      	nop
 80a20ec:	2000070c 	.word	0x2000070c
 80a20f0:	20000708 	.word	0x20000708
 80a20f4:	20000704 	.word	0x20000704
 80a20f8:	20000700 	.word	0x20000700
 80a20fc:	200006fc 	.word	0x200006fc
 80a2100:	200006f8 	.word	0x200006f8
 80a2104:	200006f4 	.word	0x200006f4
 80a2108:	200006f0 	.word	0x200006f0

080a210c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a210c:	4b24      	ldr	r3, [pc, #144]	; (80a21a0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a210e:	681a      	ldr	r2, [r3, #0]
 80a2110:	07d0      	lsls	r0, r2, #31
 80a2112:	bf5c      	itt	pl
 80a2114:	2201      	movpl	r2, #1
 80a2116:	601a      	strpl	r2, [r3, #0]
 80a2118:	4b22      	ldr	r3, [pc, #136]	; (80a21a4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a211a:	681a      	ldr	r2, [r3, #0]
 80a211c:	07d1      	lsls	r1, r2, #31
 80a211e:	bf5c      	itt	pl
 80a2120:	2201      	movpl	r2, #1
 80a2122:	601a      	strpl	r2, [r3, #0]
 80a2124:	4b20      	ldr	r3, [pc, #128]	; (80a21a8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a2126:	681a      	ldr	r2, [r3, #0]
 80a2128:	07d2      	lsls	r2, r2, #31
 80a212a:	bf5c      	itt	pl
 80a212c:	2201      	movpl	r2, #1
 80a212e:	601a      	strpl	r2, [r3, #0]
 80a2130:	4b1e      	ldr	r3, [pc, #120]	; (80a21ac <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a2132:	681a      	ldr	r2, [r3, #0]
 80a2134:	07d0      	lsls	r0, r2, #31
 80a2136:	bf5c      	itt	pl
 80a2138:	2201      	movpl	r2, #1
 80a213a:	601a      	strpl	r2, [r3, #0]
 80a213c:	4b1c      	ldr	r3, [pc, #112]	; (80a21b0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a213e:	681a      	ldr	r2, [r3, #0]
 80a2140:	07d1      	lsls	r1, r2, #31
 80a2142:	bf5c      	itt	pl
 80a2144:	2201      	movpl	r2, #1
 80a2146:	601a      	strpl	r2, [r3, #0]
 80a2148:	4b1a      	ldr	r3, [pc, #104]	; (80a21b4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a214a:	681a      	ldr	r2, [r3, #0]
 80a214c:	07d2      	lsls	r2, r2, #31
 80a214e:	bf5c      	itt	pl
 80a2150:	2201      	movpl	r2, #1
 80a2152:	601a      	strpl	r2, [r3, #0]
 80a2154:	4b18      	ldr	r3, [pc, #96]	; (80a21b8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a2156:	681a      	ldr	r2, [r3, #0]
 80a2158:	07d0      	lsls	r0, r2, #31
 80a215a:	bf5c      	itt	pl
 80a215c:	2201      	movpl	r2, #1
 80a215e:	601a      	strpl	r2, [r3, #0]
 80a2160:	4b16      	ldr	r3, [pc, #88]	; (80a21bc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a2162:	681a      	ldr	r2, [r3, #0]
 80a2164:	07d1      	lsls	r1, r2, #31
 80a2166:	bf5c      	itt	pl
 80a2168:	2201      	movpl	r2, #1
 80a216a:	601a      	strpl	r2, [r3, #0]
 80a216c:	4b14      	ldr	r3, [pc, #80]	; (80a21c0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a216e:	681a      	ldr	r2, [r3, #0]
 80a2170:	07d2      	lsls	r2, r2, #31
 80a2172:	bf5c      	itt	pl
 80a2174:	2201      	movpl	r2, #1
 80a2176:	601a      	strpl	r2, [r3, #0]
 80a2178:	4b12      	ldr	r3, [pc, #72]	; (80a21c4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a217a:	681a      	ldr	r2, [r3, #0]
 80a217c:	07d0      	lsls	r0, r2, #31
 80a217e:	bf5c      	itt	pl
 80a2180:	2201      	movpl	r2, #1
 80a2182:	601a      	strpl	r2, [r3, #0]
 80a2184:	4b10      	ldr	r3, [pc, #64]	; (80a21c8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a2186:	681a      	ldr	r2, [r3, #0]
 80a2188:	07d1      	lsls	r1, r2, #31
 80a218a:	bf5c      	itt	pl
 80a218c:	2201      	movpl	r2, #1
 80a218e:	601a      	strpl	r2, [r3, #0]
 80a2190:	4b0e      	ldr	r3, [pc, #56]	; (80a21cc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a2192:	681a      	ldr	r2, [r3, #0]
 80a2194:	07d2      	lsls	r2, r2, #31
 80a2196:	bf5c      	itt	pl
 80a2198:	2201      	movpl	r2, #1
 80a219a:	601a      	strpl	r2, [r3, #0]
 80a219c:	4770      	bx	lr
 80a219e:	bf00      	nop
 80a21a0:	2000073c 	.word	0x2000073c
 80a21a4:	20000738 	.word	0x20000738
 80a21a8:	20000734 	.word	0x20000734
 80a21ac:	20000730 	.word	0x20000730
 80a21b0:	2000072c 	.word	0x2000072c
 80a21b4:	20000728 	.word	0x20000728
 80a21b8:	20000724 	.word	0x20000724
 80a21bc:	20000720 	.word	0x20000720
 80a21c0:	2000071c 	.word	0x2000071c
 80a21c4:	20000718 	.word	0x20000718
 80a21c8:	20000714 	.word	0x20000714
 80a21cc:	20000710 	.word	0x20000710

080a21d0 <__cxa_atexit>:
 80a21d0:	b510      	push	{r4, lr}
 80a21d2:	4c05      	ldr	r4, [pc, #20]	; (80a21e8 <__cxa_atexit+0x18>)
 80a21d4:	4613      	mov	r3, r2
 80a21d6:	b12c      	cbz	r4, 80a21e4 <__cxa_atexit+0x14>
 80a21d8:	460a      	mov	r2, r1
 80a21da:	4601      	mov	r1, r0
 80a21dc:	2002      	movs	r0, #2
 80a21de:	f3af 8000 	nop.w
 80a21e2:	bd10      	pop	{r4, pc}
 80a21e4:	4620      	mov	r0, r4
 80a21e6:	bd10      	pop	{r4, pc}
 80a21e8:	00000000 	.word	0x00000000

080a21ec <ldiv>:
 80a21ec:	b510      	push	{r4, lr}
 80a21ee:	fb91 f4f2 	sdiv	r4, r1, r2
 80a21f2:	2900      	cmp	r1, #0
 80a21f4:	fb02 1314 	mls	r3, r2, r4, r1
 80a21f8:	db04      	blt.n	80a2204 <ldiv+0x18>
 80a21fa:	2b00      	cmp	r3, #0
 80a21fc:	da07      	bge.n	80a220e <ldiv+0x22>
 80a21fe:	3401      	adds	r4, #1
 80a2200:	1a9b      	subs	r3, r3, r2
 80a2202:	e004      	b.n	80a220e <ldiv+0x22>
 80a2204:	2b00      	cmp	r3, #0
 80a2206:	bfc4      	itt	gt
 80a2208:	f104 34ff 	addgt.w	r4, r4, #4294967295	; 0xffffffff
 80a220c:	189b      	addgt	r3, r3, r2
 80a220e:	6004      	str	r4, [r0, #0]
 80a2210:	6043      	str	r3, [r0, #4]
 80a2212:	bd10      	pop	{r4, pc}

080a2214 <memcpy>:
 80a2214:	b510      	push	{r4, lr}
 80a2216:	1e43      	subs	r3, r0, #1
 80a2218:	440a      	add	r2, r1
 80a221a:	4291      	cmp	r1, r2
 80a221c:	d004      	beq.n	80a2228 <memcpy+0x14>
 80a221e:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a2222:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a2226:	e7f8      	b.n	80a221a <memcpy+0x6>
 80a2228:	bd10      	pop	{r4, pc}

080a222a <memset>:
 80a222a:	4603      	mov	r3, r0
 80a222c:	4402      	add	r2, r0
 80a222e:	4293      	cmp	r3, r2
 80a2230:	d002      	beq.n	80a2238 <memset+0xe>
 80a2232:	f803 1b01 	strb.w	r1, [r3], #1
 80a2236:	e7fa      	b.n	80a222e <memset+0x4>
 80a2238:	4770      	bx	lr
	...

080a223c <srand>:
 80a223c:	b538      	push	{r3, r4, r5, lr}
 80a223e:	4b12      	ldr	r3, [pc, #72]	; (80a2288 <srand+0x4c>)
 80a2240:	4605      	mov	r5, r0
 80a2242:	681c      	ldr	r4, [r3, #0]
 80a2244:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a2246:	b9d3      	cbnz	r3, 80a227e <srand+0x42>
 80a2248:	2018      	movs	r0, #24
 80a224a:	f7fe fd1b 	bl	80a0c84 <malloc>
 80a224e:	f243 330e 	movw	r3, #13070	; 0x330e
 80a2252:	63a0      	str	r0, [r4, #56]	; 0x38
 80a2254:	8003      	strh	r3, [r0, #0]
 80a2256:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a225a:	8043      	strh	r3, [r0, #2]
 80a225c:	f241 2334 	movw	r3, #4660	; 0x1234
 80a2260:	8083      	strh	r3, [r0, #4]
 80a2262:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a2266:	80c3      	strh	r3, [r0, #6]
 80a2268:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a226c:	8103      	strh	r3, [r0, #8]
 80a226e:	2305      	movs	r3, #5
 80a2270:	8143      	strh	r3, [r0, #10]
 80a2272:	230b      	movs	r3, #11
 80a2274:	8183      	strh	r3, [r0, #12]
 80a2276:	2201      	movs	r2, #1
 80a2278:	2300      	movs	r3, #0
 80a227a:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a227e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a2280:	2200      	movs	r2, #0
 80a2282:	611d      	str	r5, [r3, #16]
 80a2284:	615a      	str	r2, [r3, #20]
 80a2286:	bd38      	pop	{r3, r4, r5, pc}
 80a2288:	2000013c 	.word	0x2000013c

080a228c <strcmp>:
 80a228c:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a2290:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a2294:	2a01      	cmp	r2, #1
 80a2296:	bf28      	it	cs
 80a2298:	429a      	cmpcs	r2, r3
 80a229a:	d0f7      	beq.n	80a228c <strcmp>
 80a229c:	1ad0      	subs	r0, r2, r3
 80a229e:	4770      	bx	lr

080a22a0 <strcpy>:
 80a22a0:	4603      	mov	r3, r0
 80a22a2:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a22a6:	f803 2b01 	strb.w	r2, [r3], #1
 80a22aa:	2a00      	cmp	r2, #0
 80a22ac:	d1f9      	bne.n	80a22a2 <strcpy+0x2>
 80a22ae:	4770      	bx	lr

080a22b0 <strlen>:
 80a22b0:	4603      	mov	r3, r0
 80a22b2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a22b6:	2a00      	cmp	r2, #0
 80a22b8:	d1fb      	bne.n	80a22b2 <strlen+0x2>
 80a22ba:	1a18      	subs	r0, r3, r0
 80a22bc:	3801      	subs	r0, #1
 80a22be:	4770      	bx	lr

080a22c0 <dynalib_user>:
 80a22c0:	001d 080a 005d 080a 0089 080a 008d 080a     ....]...........
 80a22d0:	0000 0000                                   ....

080a22d4 <_ZL9script_js>:
 80a22d4:	6176 2072 6162 6573 755f 6c72 273d 7468     var base_url='ht
 80a22e4:	7074 2f3a 312f 3239 312e 3836 302e 312e     tp://192.168.0.1
 80a22f4:	272f 763b 7261 6e20 7465 6f77 6b72 6c5f     /';var network_l
 80a2304:	7369 3b74 6176 2072 7570 6c62 6369 6b5f     ist;var public_k
 80a2314:	7965 763b 7261 7220 6173 6e3d 7765 5220     ey;var rsa=new R
 80a2324:	4153 654b 2879 3b29 6176 2072 6373 6e61     SAKey();var scan
 80a2334:	7542 7474 6e6f 643d 636f 6d75 6e65 2e74     Button=document.
 80a2344:	6567 4574 656c 656d 746e 7942 6449 2728     getElementById('
 80a2354:	6373 6e61 622d 7475 6f74 276e 3b29 6176     scan-button');va
 80a2364:	2072 6f63 6e6e 6365 4274 7475 6f74 3d6e     r connectButton=
 80a2374:	6f64 7563 656d 746e 672e 7465 6c45 6d65     document.getElem
 80a2384:	6e65 4274 4979 2864 6327 6e6f 656e 7463     entById('connect
 80a2394:	622d 7475 6f74 276e 3b29 6176 2072 6f63     -button');var co
 80a23a4:	7970 7542 7474 6e6f 643d 636f 6d75 6e65     pyButton=documen
 80a23b4:	2e74 6567 4574 656c 656d 746e 7942 6449     t.getElementById
 80a23c4:	2728 6f63 7970 622d 7475 6f74 276e 3b29     ('copy-button');
 80a23d4:	6176 2072 6873 776f 7542 7474 6e6f 643d     var showButton=d
 80a23e4:	636f 6d75 6e65 2e74 6567 4574 656c 656d     ocument.getEleme
 80a23f4:	746e 7942 6449 2728 6873 776f 622d 7475     ntById('show-but
 80a2404:	6f74 276e 3b29 6176 2072 6564 6976 6563     ton');var device
 80a2414:	4449 643d 636f 6d75 6e65 2e74 6567 4574     ID=document.getE
 80a2424:	656c 656d 746e 7942 6449 2728 6564 6976     lementById('devi
 80a2434:	6563 692d 2764 3b29 6176 2072 6f63 6e6e     ce-id');var conn
 80a2444:	6365 4674 726f 3d6d 6f64 7563 656d 746e     ectForm=document
 80a2454:	672e 7465 6c45 6d65 6e65 4274 4979 2864     .getElementById(
 80a2464:	6327 6e6f 656e 7463 662d 726f 276d 3b29     'connect-form');
 80a2474:	6176 2072 7570 6c62 6369 6b5f 7965 635f     var public_key_c
 80a2484:	6c61 626c 6361 3d6b 737b 6375 6563 7373     allback={success
 80a2494:	663a 6e75 7463 6f69 286e 2961 637b 6e6f     :function(a){con
 80a24a4:	6f73 656c 6c2e 676f 2728 7550 6c62 6369     sole.log('Public
 80a24b4:	6b20 7965 203a 2b27 2e61 2962 703b 6275      key: '+a.b);pub
 80a24c4:	696c 5f63 656b 3d79 2e61 3b62 7372 2e61     lic_key=a.b;rsa.
 80a24d4:	6573 5074 6275 696c 2863 7570 6c62 6369     setPublic(public
 80a24e4:	6b5f 7965 732e 6275 7473 6972 676e 3528     _key.substring(5
 80a24f4:	2c38 3835 322b 3635 2c29 7570 6c62 6369     8,58+256),public
 80a2504:	6b5f 7965 732e 6275 7473 6972 676e 3328     _key.substring(3
 80a2514:	3831 332c 3831 362b 2929 7d3b 652c 7272     18,318+6));},err
 80a2524:	726f 663a 6e75 7463 6f69 286e 2c61 2962     or:function(a,b)
 80a2534:	637b 6e6f 6f73 656c 6c2e 676f 6128 3b29     {console.log(a);
 80a2544:	6977 646e 776f 612e 656c 7472 2728 6854     window.alert('Th
 80a2554:	7265 2065 6177 2073 2061 7270 626f 656c     ere was a proble
 80a2564:	206d 6566 6374 6968 676e 6920 706d 726f     m fetching impor
 80a2574:	6174 746e 6920 666e 726f 616d 6974 6e6f     tant information
 80a2584:	6620 6f72 206d 6f79 7275 6420 7665 6369      from your devic
 80a2594:	2e65 5020 656c 7361 2065 6576 6972 7966     e. Please verify
 80a25a4:	7920 756f 2072 6f63 6e6e 6365 6974 6e6f      your connection
 80a25b4:	202c 6874 6e65 7220 6c65 616f 2064 6874     , then reload th
 80a25c4:	7369 7020 6761 2e65 2927 7d3b 3b7d 6176     is page.');}};va
 80a25d4:	2072 6564 6976 6563 695f 5f64 6163 6c6c     r device_id_call
 80a25e4:	6162 6b63 7b3d 7573 6363 7365 3a73 7566     back={success:fu
 80a25f4:	636e 6974 6e6f 6128 7b29 6176 2072 3d62     nction(a){var b=
 80a2604:	2e61 6469 643b 7665 6369 4965 2e44 6176     a.id;deviceID.va
 80a2614:	756c 3d65 3b62 2c7d 7265 6f72 3a72 7566     lue=b;},error:fu
 80a2624:	636e 6974 6e6f 6128 622c 7b29 6f63 736e     nction(a,b){cons
 80a2634:	6c6f 2e65 6f6c 2867 2961 763b 7261 6320     ole.log(a);var c
 80a2644:	273d 4f43 4d4d 4e55 4349 5441 4f49 5f4e     ='COMMUNICATION_
 80a2654:	5245 4f52 2752 643b 7665 6369 4965 2e44     ERROR';deviceID.
 80a2664:	6176 756c 3d65 3b63 7d7d 763b 7261 7320     value=c;}};var s
 80a2674:	6163 3d6e 7566 636e 6974 6e6f 2928 637b     can=function(){c
 80a2684:	6e6f 6f73 656c 6c2e 676f 2728 6353 6e61     onsole.log('Scan
 80a2694:	696e 676e 2e2e 212e 2927 643b 7369 6261     ning...!');disab
 80a26a4:	656c 7542 7474 6e6f 2873 3b29 6373 6e61     leButtons();scan
 80a26b4:	7542 7474 6e6f 692e 6e6e 7265 5448 4c4d     Button.innerHTML
 80a26c4:	273d 6353 6e61 696e 676e 2e2e 272e 633b     ='Scanning...';c
 80a26d4:	6e6f 656e 7463 7542 7474 6e6f 692e 6e6e     onnectButton.inn
 80a26e4:	7265 5448 4c4d 273d 6f43 6e6e 6365 2774     erHTML='Connect'
 80a26f4:	643b 636f 6d75 6e65 2e74 6567 4574 656c     ;document.getEle
 80a2704:	656d 746e 7942 6449 2728 6f63 6e6e 6365     mentById('connec
 80a2714:	2d74 6964 2776 2e29 7473 6c79 2e65 6964     t-div').style.di
 80a2724:	7073 616c 3d79 6e27 6e6f 2765 643b 636f     splay='none';doc
 80a2734:	6d75 6e65 2e74 6567 4574 656c 656d 746e     ument.getElement
 80a2744:	7942 6449 2728 656e 7774 726f 736b 642d     ById('networks-d
 80a2754:	7669 2927 732e 7974 656c 642e 7369 6c70     iv').style.displ
 80a2764:	7961 273d 6f6e 656e 3b27 6567 5274 7165     ay='none';getReq
 80a2774:	6575 7473 6228 7361 5f65 7275 2b6c 7327     uest(base_url+'s
 80a2784:	6163 2d6e 7061 2c27 6373 6e61 635f 6c61     can-ap',scan_cal
 80a2794:	626c 6361 296b 7d3b 763b 7261 7320 6163     lback);};var sca
 80a27a4:	5f6e 6163 6c6c 6162 6b63 7b3d 7573 6363     n_callback={succ
 80a27b4:	7365 3a73 7566 636e 6974 6e6f 6128 7b29     ess:function(a){
 80a27c4:	656e 7774 726f 5f6b 696c 7473 613d 732e     network_list=a.s
 80a27d4:	6163 736e 633b 6e6f 6f73 656c 6c2e 676f     cans;console.log
 80a27e4:	2728 2049 6f66 6e75 3a64 2927 763b 7261     ('I found:');var
 80a27f4:	6220 643d 636f 6d75 6e65 2e74 6567 4574      b=document.getE
 80a2804:	656c 656d 746e 7942 6449 2728 656e 7774     lementById('netw
 80a2814:	726f 736b 642d 7669 2927 623b 692e 6e6e     orks-div');b.inn
 80a2824:	7265 5448 4c4d 273d 3b27 6669 6e28 7465     erHTML='';if(net
 80a2834:	6f77 6b72 6c5f 7369 2e74 656c 676e 6874     work_list.length
 80a2844:	303e 6629 726f 7628 7261 6320 303d 633b     >0)for(var c=0;c
 80a2854:	6e3c 7465 6f77 6b72 6c5f 7369 2e74 656c     <network_list.le
 80a2864:	676e 6874 633b 2b2b 7b29 7373 6469 6e3d     ngth;c++){ssid=n
 80a2874:	7465 6f77 6b72 6c5f 7369 5b74 5d63 732e     etwork_list[c].s
 80a2884:	6973 3b64 6f63 736e 6c6f 2e65 6f6c 2867     sid;console.log(
 80a2894:	656e 7774 726f 5f6b 696c 7473 635b 295d     network_list[c])
 80a28a4:	613b 6464 775f 6669 5f69 706f 6974 6e6f     ;add_wifi_option
 80a28b4:	6228 732c 6973 2964 643b 636f 6d75 6e65     (b,ssid);documen
 80a28c4:	2e74 6567 4574 656c 656d 746e 7942 6449     t.getElementById
 80a28d4:	2728 6f63 6e6e 6365 2d74 6964 2776 2e29     ('connect-div').
 80a28e4:	7473 6c79 2e65 6964 7073 616c 3d79 6227     style.display='b
 80a28f4:	6f6c 6b63 3b27 657d 736c 2065 2e62 6e69     lock';}else b.in
 80a2904:	656e 4872 4d54 3d4c 3c27 2070 6c63 7361     nerHTML='<p clas
 80a2914:	3d73 275c 6373 6e61 696e 676e 652d 7272     s=\'scanning-err
 80a2924:	726f 275c 4e3e 206f 656e 7774 726f 736b     or\'>No networks
 80a2934:	6620 756f 646e 3c2e 702f 273e 7d3b 652c      found.</p>';},e
 80a2944:	7272 726f 663a 6e75 7463 6f69 286e 2961     rror:function(a)
 80a2954:	637b 6e6f 6f73 656c 6c2e 676f 2728 6353     {console.log('Sc
 80a2964:	6e61 696e 676e 6520 7272 726f 273a 612b     anning error:'+a
 80a2974:	3b29 6f64 7563 656d 746e 672e 7465 6c45     );document.getEl
 80a2984:	6d65 6e65 4274 4979 2864 6e27 7465 6f77     ementById('netwo
 80a2994:	6b72 2d73 6964 2776 2e29 6e69 656e 4872     rks-div').innerH
 80a29a4:	4d54 3d4c 3c27 2070 6c63 7361 3d73 275c     TML='<p class=\'
 80a29b4:	6373 6e61 696e 676e 652d 7272 726f 275c     scanning-error\'
 80a29c4:	533e 6163 6e6e 6e69 2067 7265 6f72 2e72     >Scanning error.
 80a29d4:	2f3c 3e70 3b27 2c7d 6572 6167 6472 656c     </p>';},regardle
 80a29e4:	7373 663a 6e75 7463 6f69 286e 7b29 6373     ss:function(){sc
 80a29f4:	6e61 7542 7474 6e6f 692e 6e6e 7265 5448     anButton.innerHT
 80a2a04:	4c4d 273d 6552 532d 6163 276e 653b 616e     ML='Re-Scan';ena
 80a2a14:	6c62 4265 7475 6f74 736e 2928 643b 636f     bleButtons();doc
 80a2a24:	6d75 6e65 2e74 6567 4574 656c 656d 746e     ument.getElement
 80a2a34:	7942 6449 2728 656e 7774 726f 736b 642d     ById('networks-d
 80a2a44:	7669 2927 732e 7974 656c 642e 7369 6c70     iv').style.displ
 80a2a54:	7961 273d 6c62 636f 276b 7d3b 3b7d 6176     ay='block';}};va
 80a2a64:	2072 6f63 666e 6769 7275 3d65 7566 636e     r configure=func
 80a2a74:	6974 6e6f 6128 7b29 2e61 7270 7665 6e65     tion(a){a.preven
 80a2a84:	4474 6665 7561 746c 2928 763b 7261 6220     tDefault();var b
 80a2a94:	673d 7465 735f 6c65 6365 6574 5f64 656e     =get_selected_ne
 80a2aa4:	7774 726f 286b 3b29 6176 2072 3d63 6f64     twork();var c=do
 80a2ab4:	7563 656d 746e 672e 7465 6c45 6d65 6e65     cument.getElemen
 80a2ac4:	4274 4979 2864 7027 7361 7773 726f 2764     tById('password'
 80a2ad4:	2e29 6176 756c 3b65 6669 2128 2962 777b     ).value;if(!b){w
 80a2ae4:	6e69 6f64 2e77 6c61 7265 2874 5027 656c     indow.alert('Ple
 80a2af4:	7361 2065 6573 656c 7463 6120 6e20 7465     ase select a net
 80a2b04:	6f77 6b72 2721 3b29 6572 7574 6e72 6620     work!');return f
 80a2b14:	6c61 6573 7d3b 6176 2072 3d64 697b 7864     alse;}var d={idx
 80a2b24:	303a 732c 6973 3a64 2e62 7373 6469 702c     :0,ssid:b.ssid,p
 80a2b34:	6477 723a 6173 652e 636e 7972 7470 6328     wd:rsa.encrypt(c
 80a2b44:	2c29 6573 3a63 2e62 6573 2c63 6863 623a     ),sec:b.sec,ch:b
 80a2b54:	632e 7d68 633b 6e6f 656e 7463 7542 7474     .ch};connectButt
 80a2b64:	6e6f 692e 6e6e 7265 5448 4c4d 273d 6553     on.innerHTML='Se
 80a2b74:	646e 6e69 2067 7263 6465 6e65 6974 6c61     nding credential
 80a2b84:	2e73 2e2e 3b27 6964 6173 6c62 4265 7475     s...';disableBut
 80a2b94:	6f74 736e 2928 633b 6e6f 6f73 656c 6c2e     tons();console.l
 80a2ba4:	676f 2728 6553 646e 6e69 2067 7263 6465     og('Sending cred
 80a2bb4:	6e65 6974 6c61 3a73 2720 4a2b 4f53 2e4e     entials: '+JSON.
 80a2bc4:	7473 6972 676e 6669 2879 2964 3b29 6f70     stringify(d));po
 80a2bd4:	7473 6552 7571 7365 2874 6162 6573 755f     stRequest(base_u
 80a2be4:	6c72 272b 6f63 666e 6769 7275 2d65 7061     rl+'configure-ap
 80a2bf4:	2c27 2c64 6f63 666e 6769 7275 5f65 6163     ',d,configure_ca
 80a2c04:	6c6c 6162 6b63 3b29 3b7d 6176 2072 6f63     llback);};var co
 80a2c14:	666e 6769 7275 5f65 6163 6c6c 6162 6b63     nfigure_callback
 80a2c24:	7b3d 7573 6363 7365 3a73 7566 636e 6974     ={success:functi
 80a2c34:	6e6f 6128 7b29 6f63 736e 6c6f 2e65 6f6c     on(a){console.lo
 80a2c44:	2867 4327 6572 6564 746e 6169 736c 7220     g('Credentials r
 80a2c54:	6365 6965 6576 2e64 2927 633b 6e6f 656e     eceived.');conne
 80a2c64:	7463 7542 7474 6e6f 692e 6e6e 7265 5448     ctButton.innerHT
 80a2c74:	4c4d 273d 7243 6465 6e65 6974 6c61 2073     ML='Credentials 
 80a2c84:	6572 6563 7669 6465 2e2e 272e 703b 736f     received...';pos
 80a2c94:	5274 7165 6575 7473 6228 7361 5f65 7275     tRequest(base_ur
 80a2ca4:	2b6c 6327 6e6f 656e 7463 612d 2770 7b2c     l+'connect-ap',{
 80a2cb4:	6469 3a78 7d30 632c 6e6f 656e 7463 635f     idx:0},connect_c
 80a2cc4:	6c61 626c 6361 296b 7d3b 652c 7272 726f     allback);},error
 80a2cd4:	663a 6e75 7463 6f69 286e 2c61 2962 637b     :function(a,b){c
 80a2ce4:	6e6f 6f73 656c 6c2e 676f 2728 6f43 666e     onsole.log('Conf
 80a2cf4:	6769 7275 2065 7265 6f72 3a72 2720 612b     igure error: '+a
 80a2d04:	3b29 6977 646e 776f 612e 656c 7472 2728     );window.alert('
 80a2d14:	6854 2065 6f63 666e 6769 7275 7461 6f69     The configuratio
 80a2d24:	206e 6f63 6d6d 6e61 2064 6166 6c69 6465     n command failed
 80a2d34:	202c 6863 6365 206b 6874 7461 7920 756f     , check that you
 80a2d44:	6120 6572 7320 6974 6c6c 7720 6c65 206c      are still well 
 80a2d54:	6f63 6e6e 6365 6574 2064 6f74 7420 6568     connected to the
 80a2d64:	6420 7665 6369 5c65 7327 5720 4669 2069      device\'s WiFi 
 80a2d74:	6f68 7374 6f70 2074 6e61 2064 6572 7274     hotspot and retr
 80a2d84:	2e79 2927 633b 6e6f 656e 7463 7542 7474     y.');connectButt
 80a2d94:	6e6f 692e 6e6e 7265 5448 4c4d 273d 6552     on.innerHTML='Re
 80a2da4:	7274 2779 653b 616e 6c62 4265 7475 6f74     try';enableButto
 80a2db4:	736e 2928 7d3b 3b7d 6176 2072 6f63 6e6e     ns();}};var conn
 80a2dc4:	6365 5f74 6163 6c6c 6162 6b63 7b3d 7573     ect_callback={su
 80a2dd4:	6363 7365 3a73 7566 636e 6974 6e6f 6128     ccess:function(a
 80a2de4:	7b29 6f63 736e 6c6f 2e65 6f6c 2867 4127     ){console.log('A
 80a2df4:	7474 6d65 7470 6e69 2067 6f74 6320 6e6f     ttempting to con
 80a2e04:	656e 7463 7420 206f 6874 2065 6c63 756f     nect to the clou
 80a2e14:	2e64 2927 633b 6e6f 656e 7463 7542 7474     d.');connectButt
 80a2e24:	6e6f 692e 6e6e 7265 5448 4c4d 273d 7441     on.innerHTML='At
 80a2e34:	6574 706d 6974 676e 7420 206f 6f63 6e6e     tempting to conn
 80a2e44:	6365 2e74 2e2e 3b27 6977 646e 776f 612e     ect...';window.a
 80a2e54:	656c 7472 2728 6f59 7275 6420 7665 6369     lert('Your devic
 80a2e64:	2065 6873 756f 646c 6e20 776f 7320 6174     e should now sta
 80a2e74:	7472 6620 616c 6873 6e69 2067 7267 6565     rt flashing gree
 80a2e84:	206e 6e61 2064 7461 6574 706d 2074 6f74     n and attempt to
 80a2e94:	6320 6e6f 656e 7463 7420 206f 6874 2065      connect to the 
 80a2ea4:	6c63 756f 2e64 5420 6968 2073 7375 6175     cloud. This usua
 80a2eb4:	6c6c 2079 6174 656b 2073 6261 756f 2074     lly takes about 
 80a2ec4:	3032 7320 6365 6e6f 7364 202c 6661 6574     20 seconds, afte
 80a2ed4:	2072 6877 6369 2068 7469 7720 6c69 206c     r which it will 
 80a2ee4:	6562 6967 206e 6c73 776f 796c 6220 696c     begin slowly bli
 80a2ef4:	6b6e 6e69 2067 7963 6e61 202e 6e5c 6e5c     nking cyan. \n\n
 80a2f04:	6e5c 6649 7420 6968 2073 7270 636f 7365     \nIf this proces
 80a2f14:	2073 6166 6c69 2073 6562 6163 7375 2065     s fails because 
 80a2f24:	6f79 2075 6e65 6574 6572 2064 6874 2065     you entered the 
 80a2f34:	7277 6e6f 2067 6170 7373 6f77 6472 202c     wrong password, 
 80a2f44:	6874 2065 6564 6976 6563 7720 6c69 206c     the device will 
 80a2f54:	6c66 7361 2068 7267 6565 206e 6e69 6564     flash green inde
 80a2f64:	6966 696e 6574 796c 202e 6e49 7420 6968     finitely. In thi
 80a2f74:	2073 6163 6573 202c 6f68 646c 7420 6568     s case, hold the
 80a2f84:	7320 7465 7075 6220 7475 6f74 206e 6f66      setup button fo
 80a2f94:	2072 2036 6573 6f63 646e 2073 6e75 6974     r 6 seconds unti
 80a2fa4:	206c 6874 2065 6564 6976 6563 7320 6174     l the device sta
 80a2fb4:	7472 2073 6c62 6e69 696b 676e 6220 756c     rts blinking blu
 80a2fc4:	2065 6761 6961 2e6e 5420 6568 206e 6572     e again. Then re
 80a2fd4:	6f63 6e6e 6365 2074 6f74 7420 6568 5720     connect to the W
 80a2fe4:	4669 2069 6f68 7374 6f70 2074 7469 6720     iFi hotspot it g
 80a2ff4:	6e65 7265 7461 7365 6120 646e 7220 6c65     enerates and rel
 80a3004:	616f 2064 6874 7369 7020 6761 2065 6f74     oad this page to
 80a3014:	7420 7972 6120 6167 6e69 272e 3b29 2c7d      try again.');},
 80a3024:	7265 6f72 3a72 7566 636e 6974 6e6f 6128     error:function(a
 80a3034:	622c 7b29 6f63 736e 6c6f 2e65 6f6c 2867     ,b){console.log(
 80a3044:	4327 6e6f 656e 7463 6520 7272 726f 203a     'Connect error: 
 80a3054:	2b27 2961 773b 6e69 6f64 2e77 6c61 7265     '+a);window.aler
 80a3064:	2874 5427 6568 6320 6e6f 656e 7463 6320     t('The connect c
 80a3074:	6d6f 616d 646e 6620 6961 656c 2c64 6320     ommand failed, c
 80a3084:	6568 6b63 7420 6168 2074 6f79 2075 7261     heck that you ar
 80a3094:	2065 7473 6c69 206c 6577 6c6c 6320 6e6f     e still well con
 80a30a4:	656e 7463 6465 7420 206f 6874 2065 6564     nected to the de
 80a30b4:	6976 6563 275c 2073 6957 6946 6820 746f     vice\'s WiFi hot
 80a30c4:	7073 746f 6120 646e 7220 7465 7972 272e     spot and retry.'
 80a30d4:	3b29 6f63 6e6e 6365 4274 7475 6f74 2e6e     );connectButton.
 80a30e4:	6e69 656e 4872 4d54 3d4c 5227 7465 7972     innerHTML='Retry
 80a30f4:	3b27 6e65 6261 656c 7542 7474 6e6f 2873     ';enableButtons(
 80a3104:	3b29 7d7d 763b 7261 6420 7369 6261 656c     );}};var disable
 80a3114:	7542 7474 6e6f 3d73 7566 636e 6974 6e6f     Buttons=function
 80a3124:	2928 637b 6e6f 656e 7463 7542 7474 6e6f     (){connectButton
 80a3134:	642e 7369 6261 656c 3d64 7274 6575 733b     .disabled=true;s
 80a3144:	6163 426e 7475 6f74 2e6e 6964 6173 6c62     canButton.disabl
 80a3154:	6465 743d 7572 3b65 3b7d 6176 2072 6e65     ed=true;};var en
 80a3164:	6261 656c 7542 7474 6e6f 3d73 7566 636e     ableButtons=func
 80a3174:	6974 6e6f 2928 637b 6e6f 656e 7463 7542     tion(){connectBu
 80a3184:	7474 6e6f 642e 7369 6261 656c 3d64 6166     tton.disabled=fa
 80a3194:	736c 3b65 6373 6e61 7542 7474 6e6f 642e     lse;scanButton.d
 80a31a4:	7369 6261 656c 3d64 6166 736c 3b65 3b7d     isabled=false;};
 80a31b4:	6176 2072 6461 5f64 6977 6966 6f5f 7470     var add_wifi_opt
 80a31c4:	6f69 3d6e 7566 636e 6974 6e6f 6128 622c     ion=function(a,b
 80a31d4:	7b29 6176 2072 3d63 6f64 7563 656d 746e     ){var c=document
 80a31e4:	632e 6572 7461 4565 656c 656d 746e 2728     .createElement('
 80a31f4:	4e49 5550 2754 3b29 2e63 7974 6570 273d     INPUT');c.type='
 80a3204:	6172 6964 276f 633b 762e 6c61 6575 623d     radio';c.value=b
 80a3214:	633b 692e 3d64 3b62 2e63 616e 656d 273d     ;c.id=b;c.name='
 80a3224:	7373 6469 3b27 2e63 6c63 7361 4e73 6d61     ssid';c.classNam
 80a3234:	3d65 7227 6461 6f69 3b27 6176 2072 3d64     e='radio';var d=
 80a3244:	6f64 7563 656d 746e 632e 6572 7461 4565     document.createE
 80a3254:	656c 656d 746e 2728 4944 2756 3b29 2e64     lement('DIV');d.
 80a3264:	6c63 7361 4e73 6d61 3d65 7227 6461 6f69     className='radio
 80a3274:	642d 7669 3b27 2e64 7061 6570 646e 6843     -div';d.appendCh
 80a3284:	6c69 2864 2963 763b 7261 6520 643d 636f     ild(c);var e=doc
 80a3294:	6d75 6e65 2e74 7263 6165 6574 6c45 6d65     ument.createElem
 80a32a4:	6e65 2874 6c27 6261 6c65 2927 653b 682e     ent('label');e.h
 80a32b4:	6d74 466c 726f 623d 653b 692e 6e6e 7265     tmlFor=b;e.inner
 80a32c4:	5448 4c4d 623d 643b 612e 7070 6e65 4364     HTML=b;d.appendC
 80a32d4:	6968 646c 6528 3b29 2e61 7061 6570 646e     hild(e);a.append
 80a32e4:	6843 6c69 2864 2964 7d3b 763b 7261 6720     Child(d);};var g
 80a32f4:	7465 735f 6c65 6365 6574 5f64 656e 7774     et_selected_netw
 80a3304:	726f 3d6b 7566 636e 6974 6e6f 2928 667b     ork=function(){f
 80a3314:	726f 7628 7261 6120 303d 613b 6e3c 7465     or(var a=0;a<net
 80a3324:	6f77 6b72 6c5f 7369 2e74 656c 676e 6874     work_list.length
 80a3334:	613b 2b2b 7b29 7373 6469 6e3d 7465 6f77     ;a++){ssid=netwo
 80a3344:	6b72 6c5f 7369 5b74 5d61 732e 6973 3b64     rk_list[a].ssid;
 80a3354:	6669 6428 636f 6d75 6e65 2e74 6567 4574     if(document.getE
 80a3364:	656c 656d 746e 7942 6449 7328 6973 2964     lementById(ssid)
 80a3374:	632e 6568 6b63 6465 7229 7465 7275 206e     .checked)return 
 80a3384:	656e 7774 726f 5f6b 696c 7473 615b 3b5d     network_list[a];
 80a3394:	7d7d 763b 7261 6320 706f 3d79 7566 636e     }};var copy=func
 80a33a4:	6974 6e6f 2928 777b 6e69 6f64 2e77 7270     tion(){window.pr
 80a33b4:	6d6f 7470 2728 6f43 7970 7420 206f 6c63     ompt('Copy to cl
 80a33c4:	7069 6f62 7261 3a64 4320 7274 206c 202b     ipboard: Ctrl + 
 80a33d4:	2c43 4520 746e 7265 2c27 6564 6976 6563     C, Enter',device
 80a33e4:	4449 762e 6c61 6575 3b29 3b7d 6176 2072     ID.value);};var 
 80a33f4:	6f74 6767 656c 6853 776f 663d 6e75 7463     toggleShow=funct
 80a3404:	6f69 286e 7b29 6176 2072 3d61 6f64 7563     ion(){var a=docu
 80a3414:	656d 746e 672e 7465 6c45 6d65 6e65 4274     ment.getElementB
 80a3424:	4979 2864 7027 7361 7773 726f 2764 3b29     yId('password');
 80a3434:	6e69 7570 5474 7079 3d65 2e61 7974 6570     inputType=a.type
 80a3444:	693b 2866 6e69 7570 5474 7079 3d65 3d3d     ;if(inputType===
 80a3454:	7027 7361 7773 726f 2764 7b29 6873 776f     'password'){show
 80a3464:	7542 7474 6e6f 692e 6e6e 7265 5448 4c4d     Button.innerHTML
 80a3474:	273d 6948 6564 3b27 2e61 7974 6570 273d     ='Hide';a.type='
 80a3484:	6574 7478 3b27 657d 736c 7b65 6873 776f     text';}else{show
 80a3494:	7542 7474 6e6f 692e 6e6e 7265 5448 4c4d     Button.innerHTML
 80a34a4:	273d 6853 776f 3b27 2e61 7974 6570 273d     ='Show';a.type='
 80a34b4:	6170 7373 6f77 6472 3b27 7d7d 763b 7261     password';}};var
 80a34c4:	6720 7465 6552 7571 7365 3d74 7566 636e      getRequest=func
 80a34d4:	6974 6e6f 6128 622c 7b29 6176 2072 3d63     tion(a,b){var c=
 80a34e4:	656e 2077 4d58 484c 7474 5270 7165 6575     new XMLHttpReque
 80a34f4:	7473 2928 633b 6f2e 6570 286e 4727 5445     st();c.open('GET
 80a3504:	2c27 2c61 7274 6575 3b29 2e63 6974 656d     ',a,true);c.time
 80a3514:	756f 3d74 3038 3030 633b 732e 6e65 2864     out=8000;c.send(
 80a3524:	3b29 2e63 6e6f 6572 6461 7379 6174 6574     );c.onreadystate
 80a3534:	6863 6e61 6567 663d 6e75 7463 6f69 286e     change=function(
 80a3544:	7b29 6669 6328 722e 6165 7964 7453 7461     ){if(c.readyStat
 80a3554:	3d65 343d 6929 2866 2962 697b 2866 2e63     e==4)if(b){if(c.
 80a3564:	7473 7461 7375 3d3d 3032 2930 697b 2866     status==200){if(
 80a3574:	2e62 7573 6363 7365 2973 2e62 7573 6363     b.success)b.succ
 80a3584:	7365 2873 534a 4e4f 702e 7261 6573 6328     ess(JSON.parse(c
 80a3594:	722e 7365 6f70 736e 5465 7865 2974 3b29     .responseText));
 80a35a4:	657d 736c 2065 6669 6228 652e 7272 726f     }else if(b.error
 80a35b4:	6229 652e 7272 726f 6328 732e 6174 7574     )b.error(c.statu
 80a35c4:	2c73 2e63 6572 7073 6e6f 6573 6554 7478     s,c.responseText
 80a35d4:	3b29 6669 6228 722e 6765 7261 6c64 7365     );if(b.regardles
 80a35e4:	2973 2e62 6572 6167 6472 656c 7373 2928     s)b.regardless()
 80a35f4:	7d3b 3b7d 3b7d 6176 2072 6f70 7473 6552     ;}};};var postRe
 80a3604:	7571 7365 3d74 7566 636e 6974 6e6f 6128     quest=function(a
 80a3614:	622c 632c 7b29 6176 2072 3d64 534a 4e4f     ,b,c){var d=JSON
 80a3624:	732e 7274 6e69 6967 7966 6228 3b29 6176     .stringify(b);va
 80a3634:	2072 3d65 656e 2077 4d58 484c 7474 5270     r e=new XMLHttpR
 80a3644:	7165 6575 7473 2928 653b 6f2e 6570 286e     equest();e.open(
 80a3654:	5027 534f 2754 612c 742c 7572 2965 653b     'POST',a,true);e
 80a3664:	742e 6d69 6f65 7475 343d 3030 3b30 2e65     .timeout=4000;e.
 80a3674:	6573 5274 7165 6575 7473 6548 6461 7265     setRequestHeader
 80a3684:	2728 6f43 746e 6e65 2d74 7954 6570 2c27     ('Content-Type',
 80a3694:	6d27 6c75 6974 6170 7472 662f 726f 2d6d     'multipart/form-
 80a36a4:	6164 6174 2927 653b 732e 6e65 2864 2964     data');e.send(d)
 80a36b4:	653b 6f2e 726e 6165 7964 7473 7461 6365     ;e.onreadystatec
 80a36c4:	6168 676e 3d65 7566 636e 6974 6e6f 2928     hange=function()
 80a36d4:	697b 2866 2e65 6572 6461 5379 6174 6574     {if(e.readyState
 80a36e4:	3d3d 2934 6669 6328 7b29 6669 6528 732e     ==4)if(c){if(e.s
 80a36f4:	6174 7574 3d73 323d 3030 7b29 6669 6328     tatus==200){if(c
 80a3704:	732e 6375 6563 7373 6329 732e 6375 6563     .success)c.succe
 80a3714:	7373 4a28 4f53 2e4e 6170 7372 2865 2e65     ss(JSON.parse(e.
 80a3724:	6572 7073 6e6f 6573 6554 7478 2929 7d3b     responseText));}
 80a3734:	6c65 6573 6920 2866 2e63 7265 6f72 2972     else if(c.error)
 80a3744:	2e63 7265 6f72 2872 2e65 7473 7461 7375     c.error(e.status
 80a3754:	652c 722e 7365 6f70 736e 5465 7865 2974     ,e.responseText)
 80a3764:	693b 2866 2e63 6572 6167 6472 656c 7373     ;if(c.regardless
 80a3774:	6329 722e 6765 7261 6c64 7365 2873 3b29     )c.regardless();
 80a3784:	7d7d 7d3b 693b 2866 6373 6e61 7542 7474     }};};if(scanButt
 80a3794:	6e6f 612e 6464 7645 6e65 4c74 7369 6574     on.addEventListe
 80a37a4:	656e 2972 637b 706f 4279 7475 6f74 2e6e     ner){copyButton.
 80a37b4:	6461 4564 6576 746e 694c 7473 6e65 7265     addEventListener
 80a37c4:	2728 6c63 6369 276b 632c 706f 2979 733b     ('click',copy);s
 80a37d4:	6f68 4277 7475 6f74 2e6e 6461 4564 6576     howButton.addEve
 80a37e4:	746e 694c 7473 6e65 7265 2728 6c63 6369     ntListener('clic
 80a37f4:	276b 742c 676f 6c67 5365 6f68 2977 733b     k',toggleShow);s
 80a3804:	6163 426e 7475 6f74 2e6e 6461 4564 6576     canButton.addEve
 80a3814:	746e 694c 7473 6e65 7265 2728 6c63 6369     ntListener('clic
 80a3824:	276b 732c 6163 296e 633b 6e6f 656e 7463     k',scan);connect
 80a3834:	6f46 6d72 612e 6464 7645 6e65 4c74 7369     Form.addEventLis
 80a3844:	6574 656e 2872 7327 6275 696d 2774 632c     tener('submit',c
 80a3854:	6e6f 6966 7567 6572 3b29 657d 736c 2065     onfigure);}else 
 80a3864:	6669 7328 6163 426e 7475 6f74 2e6e 7461     if(scanButton.at
 80a3874:	6174 6863 7645 6e65 2974 637b 706f 4279     tachEvent){copyB
 80a3884:	7475 6f74 2e6e 7461 6174 6863 7645 6e65     utton.attachEven
 80a3894:	2874 6f27 636e 696c 6b63 2c27 6f63 7970     t('onclick',copy
 80a38a4:	3b29 6873 776f 7542 7474 6e6f 612e 7474     );showButton.att
 80a38b4:	6361 4568 6576 746e 2728 6e6f 6c63 6369     achEvent('onclic
 80a38c4:	276b 742c 676f 6c67 5365 6f68 2977 733b     k',toggleShow);s
 80a38d4:	6163 426e 7475 6f74 2e6e 7461 6174 6863     canButton.attach
 80a38e4:	7645 6e65 2874 6f27 636e 696c 6b63 2c27     Event('onclick',
 80a38f4:	6373 6e61 3b29 6f63 6e6e 6365 4674 726f     scan);connectFor
 80a3904:	2e6d 7461 6174 6863 7645 6e65 2874 6f27     m.attachEvent('o
 80a3914:	736e 6275 696d 2774 632c 6e6f 6966 7567     nsubmit',configu
 80a3924:	6572 3b29 677d 7465 6552 7571 7365 2874     re);}getRequest(
 80a3934:	6162 6573 755f 6c72 272b 6564 6976 6563     base_url+'device
 80a3944:	692d 2764 642c 7665 6369 5f65 6469 635f     -id',device_id_c
 80a3954:	6c61 626c 6361 296b 673b 7465 6552 7571     allback);getRequ
 80a3964:	7365 2874 6162 6573 755f 6c72 272b 7570     est(base_url+'pu
 80a3974:	6c62 6369 6b2d 7965 2c27 7570 6c62 6369     blic-key',public
 80a3984:	6b5f 7965 635f 6c61 626c 6361 296b 003b     _key_callback);.

080a3994 <_ZL9style_css>:
 80a3994:	7468 6c6d 687b 6965 6867 3a74 3031 2530     html{height:100%
 80a39a4:	6d3b 7261 6967 3a6e 7561 6f74 623b 6361     ;margin:auto;bac
 80a39b4:	676b 6f72 6e75 2d64 6f63 6f6c 3a72 6877     kground-color:wh
 80a39c4:	7469 7d65 6f62 7964 627b 786f 732d 7a69     ite}body{box-siz
 80a39d4:	6e69 3a67 6f62 6472 7265 622d 786f 6d3b     ing:border-box;m
 80a39e4:	6e69 682d 6965 6867 3a74 3031 2530 703b     in-height:100%;p
 80a39f4:	6461 6964 676e 323a 7030 3b78 6162 6b63     adding:20px;back
 80a3a04:	7267 756f 646e 632d 6c6f 726f 233a 6131     ground-color:#1a
 80a3a14:	6261 3065 663b 6e6f 2d74 6166 696d 796c     abe0;font-family
 80a3a24:	273a 754c 6963 6164 5320 6e61 2073 6e55     :'Lucida Sans Un
 80a3a34:	6369 646f 2765 272c 754c 6963 6164 4720     icode','Lucida G
 80a3a44:	6172 646e 2765 732c 6e61 2d73 6573 6972     rande',sans-seri
 80a3a54:	3b66 6f66 746e 772d 6965 6867 3a74 6f6e     f;font-weight:no
 80a3a64:	6d72 6c61 633b 6c6f 726f 773a 6968 6574     rmal;color:white
 80a3a74:	6d3b 7261 6967 2d6e 6f74 3a70 3b30 616d     ;margin-top:0;ma
 80a3a84:	6772 6e69 6c2d 6665 3a74 7561 6f74 6d3b     rgin-left:auto;m
 80a3a94:	7261 6967 2d6e 6972 6867 3a74 7561 6f74     argin-right:auto
 80a3aa4:	6d3b 7261 6967 2d6e 6f62 7474 6d6f 303a     ;margin-bottom:0
 80a3ab4:	6d3b 7861 772d 6469 6874 343a 3030 7870     ;max-width:400px
 80a3ac4:	743b 7865 2d74 6c61 6769 3a6e 6563 746e     ;text-align:cent
 80a3ad4:	7265 623b 726f 6564 3a72 7031 2078 6f73     er;border:1px so
 80a3ae4:	696c 2064 3623 3665 3765 3b30 6f62 6472     lid #6e6e70;bord
 80a3af4:	7265 722d 6461 7569 3a73 7034 7d78 6964     er-radius:4px}di
 80a3b04:	7b76 616d 6772 6e69 742d 706f 323a 7035     v{margin-top:25p
 80a3b14:	3b78 616d 6772 6e69 622d 746f 6f74 3a6d     x;margin-bottom:
 80a3b24:	3532 7870 687d 7b31 616d 6772 6e69 742d     25px}h1{margin-t
 80a3b34:	706f 323a 7035 3b78 616d 6772 6e69 622d     op:25px;margin-b
 80a3b44:	746f 6f74 3a6d 3532 7870 627d 7475 6f74     ottom:25px}butto
 80a3b54:	7b6e 6f62 6472 7265 632d 6c6f 726f 233a     n{border-color:#
 80a3b64:	6331 3537 6562 623b 6361 676b 6f72 6e75     1c75be;backgroun
 80a3b74:	2d64 6f63 6f6c 3a72 3123 3763 6235 3b65     d-color:#1c75be;
 80a3b84:	6f63 6f6c 3a72 6877 7469 3b65 6f62 6472     color:white;bord
 80a3b94:	7265 722d 6461 7569 3a73 7035 3b78 6568     er-radius:5px;he
 80a3ba4:	6769 7468 333a 7030 3b78 6f66 746e 732d     ight:30px;font-s
 80a3bb4:	7a69 3a65 3531 7870 663b 6e6f 2d74 6577     ize:15px;font-we
 80a3bc4:	6769 7468 623a 6c6f 7d64 7562 7474 6e6f     ight:bold}button
 80a3bd4:	692e 706e 7475 682d 6c65 6570 7b72 6162     .input-helper{ba
 80a3be4:	6b63 7267 756f 646e 632d 6c6f 726f 233a     ckground-color:#
 80a3bf4:	6562 6562 6562 623b 726f 6564 2d72 6f63     bebebe;border-co
 80a3c04:	6f6c 3a72 6223 6265 6265 3b65 6f63 6f6c     lor:#bebebe;colo
 80a3c14:	3a72 3623 3665 3765 3b30 616d 6772 6e69     r:#6e6e70;margin
 80a3c24:	6c2d 6665 3a74 7033 7d78 7562 7474 6e6f     -left:3px}button
 80a3c34:	643a 7369 6261 656c 7b64 6162 6b63 7267     :disabled{backgr
 80a3c44:	756f 646e 632d 6c6f 726f 233a 6562 6562     ound-color:#bebe
 80a3c54:	6562 623b 726f 6564 2d72 6f63 6f6c 3a72     be;border-color:
 80a3c64:	6223 6265 6265 3b65 6f63 6f6c 3a72 6877     #bebebe;color:wh
 80a3c74:	7469 7d65 6e69 7570 5b74 7974 6570 273d     ite}input[type='
 80a3c84:	6574 7478 5d27 692c 706e 7475 745b 7079     text'],input[typ
 80a3c94:	3d65 7027 7361 7773 726f 2764 7b5d 6162     e='password']{ba
 80a3ca4:	6b63 7267 756f 646e 632d 6c6f 726f 773a     ckground-color:w
 80a3cb4:	6968 6574 633b 6c6f 726f 233a 6536 6536     hite;color:#6e6e
 80a3cc4:	3037 623b 726f 6564 2d72 6f63 6f6c 3a72     70;border-color:
 80a3cd4:	6877 7469 3b65 6f62 6472 7265 722d 6461     white;border-rad
 80a3ce4:	7569 3a73 7035 3b78 6568 6769 7468 323a     ius:5px;height:2
 80a3cf4:	7035 3b78 6574 7478 612d 696c 6e67 633a     5px;text-align:c
 80a3d04:	6e65 6574 3b72 6f66 746e 732d 7a69 3a65     enter;font-size:
 80a3d14:	3531 7870 697d 706e 7475 643a 7369 6261     15px}input:disab
 80a3d24:	656c 7b64 6162 6b63 7267 756f 646e 632d     led{background-c
 80a3d34:	6c6f 726f 233a 6562 6562 6562 623b 726f     olor:#bebebe;bor
 80a3d44:	6564 2d72 6f63 6f6c 3a72 6223 6265 6265     der-color:#bebeb
 80a3d54:	7d65 6e69 7570 5b74 7974 6570 273d 6172     e}input[type='ra
 80a3d64:	6964 276f 7b5d 6f70 6973 6974 6e6f 723a     dio']{position:r
 80a3d74:	6c65 7461 7669 3b65 6f62 7474 6d6f 2d3a     elative;bottom:-
 80a3d84:	2e30 3333 6d65 6d3b 7261 6967 3a6e 3b30     0.33em;margin:0;
 80a3d94:	6f62 6472 7265 303a 683b 6965 6867 3a74     border:0;height:
 80a3da4:	2e31 6535 3b6d 6977 7464 3a68 3531 7d25     1.5em;width:15%}
 80a3db4:	616c 6562 7b6c 6170 6464 6e69 2d67 6f74     label{padding-to
 80a3dc4:	3a70 7037 3b78 6170 6464 6e69 2d67 6f62     p:7px;padding-bo
 80a3dd4:	7474 6d6f 373a 7870 703b 6461 6964 676e     ttom:7px;padding
 80a3de4:	6c2d 6665 3a74 2535 643b 7369 6c70 7961     -left:5%;display
 80a3df4:	693a 6c6e 6e69 2d65 6c62 636f 3b6b 6977     :inline-block;wi
 80a3e04:	7464 3a68 3038 3b25 6574 7478 612d 696c     dth:80%;text-ali
 80a3e14:	6e67 6c3a 6665 7d74 6e69 7570 5b74 7974     gn:left}input[ty
 80a3e24:	6570 273d 6172 6964 276f 3a5d 6863 6365     pe='radio']:chec
 80a3e34:	656b 2b64 616c 6562 7b6c 6f66 746e 772d     ked+label{font-w
 80a3e44:	6965 6867 3a74 6f62 646c 633b 6c6f 726f     eight:bold;color
 80a3e54:	233a 6331 3537 6562 2e7d 6373 6e61 696e     :#1c75be}.scanni
 80a3e64:	676e 652d 7272 726f 667b 6e6f 2d74 6577     ng-error{font-we
 80a3e74:	6769 7468 623a 6c6f 3b64 6574 7478 612d     ight:bold;text-a
 80a3e84:	696c 6e67 633a 6e65 6574 7d72 722e 6461     lign:center}.rad
 80a3e94:	6f69 642d 7669 627b 786f 732d 7a69 6e69     io-div{box-sizin
 80a3ea4:	3a67 6f62 6472 7265 622d 786f 6d3b 7261     g:border-box;mar
 80a3eb4:	6967 3a6e 7032 3b78 616d 6772 6e69 6c2d     gin:2px;margin-l
 80a3ec4:	6665 3a74 7561 6f74 6d3b 7261 6967 2d6e     eft:auto;margin-
 80a3ed4:	6972 6867 3a74 7561 6f74 623b 6361 676b     right:auto;backg
 80a3ee4:	6f72 6e75 2d64 6f63 6f6c 3a72 6877 7469     round-color:whit
 80a3ef4:	3b65 6f63 6f6c 3a72 3623 3665 3765 3b30     e;color:#6e6e70;
 80a3f04:	6f62 6472 7265 313a 7870 7320 6c6f 6469     border:1px solid
 80a3f14:	2320 6536 6536 3037 623b 726f 6564 2d72      #6e6e70;border-
 80a3f24:	6172 6964 7375 333a 7870 773b 6469 6874     radius:3px;width
 80a3f34:	313a 3030 3b25 6170 6464 6e69 3a67 7035     :100%;padding:5p
 80a3f44:	7d78 6e23 7465 6f77 6b72 2d73 6964 7b76     x}#networks-div{
 80a3f54:	616d 6772 6e69 6c2d 6665 3a74 7561 6f74     margin-left:auto
 80a3f64:	6d3b 7261 6967 2d6e 6972 6867 3a74 7561     ;margin-right:au
 80a3f74:	6f74 743b 7865 2d74 6c61 6769 3a6e 656c     to;text-align:le
 80a3f84:	7466 237d 6564 6976 6563 692d 7b64 6574     ft}#device-id{te
 80a3f94:	7478 612d 696c 6e67 633a 6e65 6574 7d72     xt-align:center}
 80a3fa4:	7323 6163 2d6e 7562 7474 6e6f 6d7b 6e69     #scan-button{min
 80a3fb4:	772d 6469 6874 313a 3030 7870 237d 6f63     -width:100px}#co
 80a3fc4:	6e6e 6365 2d74 7562 7474 6e6f 647b 7369     nnect-button{dis
 80a3fd4:	6c70 7961 623a 6f6c 6b63 6d3b 6e69 772d     play:block;min-w
 80a3fe4:	6469 6874 313a 3030 7870 6d3b 7261 6967     idth:100px;margi
 80a3ff4:	2d6e 6f74 3a70 3031 7870 6d3b 7261 6967     n-top:10px;margi
 80a4004:	2d6e 656c 7466 613a 7475 3b6f 616d 6772     n-left:auto;marg
 80a4014:	6e69 722d 6769 7468 613a 7475 3b6f 616d     in-right:auto;ma
 80a4024:	6772 6e69 622d 746f 6f74 3a6d 3032 7870     rgin-bottom:20px
 80a4034:	237d 6170 7373 6f77 6472 6d7b 7261 6967     }#password{margi
 80a4044:	2d6e 6f74 3a70 3032 7870 6d3b 7261 6967     n-top:20px;margi
 80a4054:	2d6e 6f62 7474 6d6f 313a 7030 7d78 6800     n-bottom:10px}.h
 80a4064:	6e61 6c64 6e69 2067 6170 6567 2520 0073     andling page %s.
 80a4074:	692f 646e 7865 7300 6e65 6964 676e 7220     /index.sending r
 80a4084:	6465 7269 6365 0074 6f4c 6163 6974 6e6f     edirect.Location
 80a4094:	203a 692f 646e 7865 682e 6d74 0d6c 000a     : /index.html...
 80a40a4:	6574 7478 702f 616c 6e69 2f00 6e69 6564     text/plain./inde
 80a40b4:	2e78 7468 6c6d 7400 7865 2f74 7468 6c6d     x.html.text/html
 80a40c4:	2f00 7372 2d61 7475 6c69 2f73 7372 2e61     ./rsa-utils/rsa.
 80a40d4:	736a 6100 7070 696c 6163 6974 6e6f 6a2f     js.application/j
 80a40e4:	7661 7361 7263 7069 0074 732f 7974 656c     avascript./style
 80a40f4:	632e 7373 7400 7865 2f74 7363 0073 722f     .css.text/css./r
 80a4104:	6173 752d 6974 736c 722f 676e 6a2e 0073     sa-utils/rng.js.
 80a4114:	722f 6173 752d 6974 736c 6a2f 6273 5f6e     /rsa-utils/jsbn_
 80a4124:	2e32 736a 2f00 7372 2d61 7475 6c69 2f73     2.js./rsa-utils/
 80a4134:	736a 6e62 315f 6a2e 0073 732f 7263 7069     jsbn_1.js./scrip
 80a4144:	2e74 736a 2f00 7372 2d61 7475 6c69 2f73     t.js./rsa-utils/
 80a4154:	7270 676e 2e34 736a 6600                         prng4.js.

080a415d <_ZL8prng4_js>:
 80a415d:	7566 636e 6974 6e6f 4120 6372 6f66 7275     function Arcfour
 80a416d:	2928 747b 6968 2e73 3d69 3b30 6874 7369     (){this.i=0;this
 80a417d:	6a2e 303d 743b 6968 2e73 3d53 656e 2077     .j=0;this.S=new 
 80a418d:	7241 6172 2879 3b29 667d 6e75 7463 6f69     Array();}functio
 80a419d:	206e 5241 3443 6e69 7469 6128 7b29 6176     n ARC4init(a){va
 80a41ad:	2072 2c62 2c63 3b64 6f66 2872 3d62 3b30     r b,c,d;for(b=0;
 80a41bd:	3c62 3532 3b36 2b2b 2962 6874 7369 532e     b<256;++b)this.S
 80a41cd:	625b 3d5d 3b62 3d63 3b30 6f66 2872 3d62     [b]=b;c=0;for(b=
 80a41dd:	3b30 3c62 3532 3b36 2b2b 2962 637b 283d     0;b<256;++b){c=(
 80a41ed:	2b63 6874 7369 532e 625b 2b5d 5b61 2562     c+this.S[b]+a[b%
 80a41fd:	2e61 656c 676e 6874 295d 3226 3535 643b     a.length])&255;d
 80a420d:	743d 6968 2e73 5b53 5d62 743b 6968 2e73     =this.S[b];this.
 80a421d:	5b53 5d62 743d 6968 2e73 5b53 5d63 743b     S[b]=this.S[c];t
 80a422d:	6968 2e73 5b53 5d63 643d 7d3b 6874 7369     his.S[c]=d;}this
 80a423d:	692e 303d 743b 6968 2e73 3d6a 3b30 667d     .i=0;this.j=0;}f
 80a424d:	6e75 7463 6f69 206e 5241 3443 656e 7478     unction ARC4next
 80a425d:	2928 767b 7261 6120 743b 6968 2e73 3d69     (){var a;this.i=
 80a426d:	7428 6968 2e73 2b69 2931 3226 3535 743b     (this.i+1)&255;t
 80a427d:	6968 2e73 3d6a 7428 6968 2e73 2b6a 6874     his.j=(this.j+th
 80a428d:	7369 532e 745b 6968 2e73 5d69 2629 3532     is.S[this.i])&25
 80a429d:	3b35 3d61 6874 7369 532e 745b 6968 2e73     5;a=this.S[this.
 80a42ad:	5d69 743b 6968 2e73 5b53 6874 7369 692e     i];this.S[this.i
 80a42bd:	3d5d 6874 7369 532e 745b 6968 2e73 5d6a     ]=this.S[this.j]
 80a42cd:	743b 6968 2e73 5b53 6874 7369 6a2e 3d5d     ;this.S[this.j]=
 80a42dd:	3b61 6572 7574 6e72 7420 6968 2e73 5b53     a;return this.S[
 80a42ed:	6128 742b 6968 2e73 5b53 6874 7369 692e     (a+this.S[this.i
 80a42fd:	295d 3226 3535 3b5d 417d 6372 6f66 7275     ])&255];}Arcfour
 80a430d:	702e 6f72 6f74 7974 6570 692e 696e 3d74     .prototype.init=
 80a431d:	5241 3443 6e69 7469 413b 6372 6f66 7275     ARC4init;Arcfour
 80a432d:	702e 6f72 6f74 7974 6570 6e2e 7865 3d74     .prototype.next=
 80a433d:	5241 3443 656e 7478 663b 6e75 7463 6f69     ARC4next;functio
 80a434d:	206e 7270 676e 6e5f 7765 7473 7461 2865     n prng_newstate(
 80a435d:	7b29 6572 7574 6e72 6e20 7765 4120 6372     ){return new Arc
 80a436d:	6f66 7275 2928 7d3b 6176 2072 6e72 5f67     four();}var rng_
 80a437d:	7370 7a69 3d65 3532 3b36 6600                    psize=256;.

080a4388 <_ZL6rsa_js>:
 80a4388:	7566 636e 6974 6e6f 7020 7261 6573 6942     function parseBi
 80a4398:	4967 746e 6128 622c 7b29 6572 7574 6e72     gInt(a,b){return
 80a43a8:	6e20 7765 4220 6769 6e49 6574 6567 2872      new BigInteger(
 80a43b8:	2c61 2962 7d3b 7566 636e 6974 6e6f 6c20     a,b);}function l
 80a43c8:	6e69 6265 6b72 6128 622c 7b29 6176 2072     inebrk(a,b){var 
 80a43d8:	3d63 2727 763b 7261 6420 303d 773b 6968     c='';var d=0;whi
 80a43e8:	656c 6428 622b 613c 6c2e 6e65 7467 2968     le(d+b<a.length)
 80a43f8:	637b 3d2b 2e61 7573 7362 7274 6e69 2867     {c+=a.substring(
 80a4408:	2c64 2b64 2962 272b 6e5c 3b27 2b64 623d     d,d+b)+'\n';d+=b
 80a4418:	7d3b 6572 7574 6e72 6320 612b 732e 6275     ;}return c+a.sub
 80a4428:	7473 6972 676e 6428 612c 6c2e 6e65 7467     string(d,a.lengt
 80a4438:	2968 7d3b 7566 636e 6974 6e6f 6220 7479     h);}function byt
 80a4448:	3265 6548 2878 2961 697b 2866 3c61 7830     e2Hex(a){if(a<0x
 80a4458:	3031 7229 7465 7275 206e 3027 2b27 2e61     10)return '0'+a.
 80a4468:	6f74 7453 6972 676e 3128 2936 653b 736c     toString(16);els
 80a4478:	2065 6572 7574 6e72 6120 742e 536f 7274     e return a.toStr
 80a4488:	6e69 2867 3631 3b29 667d 6e75 7463 6f69     ing(16);}functio
 80a4498:	206e 6b70 7363 7031 6461 2832 2c61 2962     n pkcs1pad2(a,b)
 80a44a8:	697b 2866 3c62 2e61 656c 676e 6874 312b     {if(b<a.length+1
 80a44b8:	2931 617b 656c 7472 2728 654d 7373 6761     1){alert('Messag
 80a44c8:	2065 6f74 206f 6f6c 676e 6620 726f 5220     e too long for R
 80a44d8:	4153 2927 723b 7465 7275 206e 756e 6c6c     SA');return null
 80a44e8:	7d3b 6176 2072 3d63 656e 2077 7241 6172     ;}var c=new Arra
 80a44f8:	2879 3b29 6176 2072 3d64 2e61 656c 676e     y();var d=a.leng
 80a4508:	6874 312d 773b 6968 656c 6428 3d3e 2630     th-1;while(d>=0&
 80a4518:	6226 303e 7b29 6176 2072 3d65 2e61 6863     &b>0){var e=a.ch
 80a4528:	7261 6f43 6564 7441 6428 2d2d 3b29 6669     arCodeAt(d--);if
 80a4538:	6528 313c 3832 6329 2d5b 622d 3d5d 3b65     (e<128)c[--b]=e;
 80a4548:	6c65 6573 6920 2866 6528 313e 3732 2629     else if((e>127)&
 80a4558:	2826 3c65 3032 3834 2929 637b 2d5b 622d     &(e<2048)){c[--b
 80a4568:	3d5d 6528 3626 2933 317c 3832 633b 2d5b     ]=(e&63)|128;c[-
 80a4578:	622d 3d5d 6528 3e3e 2936 317c 3239 7d3b     -b]=(e>>6)|192;}
 80a4588:	6c65 6573 637b 2d5b 622d 3d5d 6528 3626     else{c[--b]=(e&6
 80a4598:	2933 317c 3832 633b 2d5b 622d 3d5d 2828     3)|128;c[--b]=((
 80a45a8:	3e65 363e 2629 3336 7c29 3231 3b38 5b63     e>>6)&63)|128;c[
 80a45b8:	2d2d 5d62 283d 3e65 313e 2932 327c 3432     --b]=(e>>12)|224
 80a45c8:	7d3b 637d 2d5b 622d 3d5d 3b30 6176 2072     ;}}c[--b]=0;var 
 80a45d8:	3d66 656e 2077 6553 7563 6572 6152 646e     f=new SecureRand
 80a45e8:	6d6f 2928 763b 7261 6720 6e3d 7765 4120     om();var g=new A
 80a45f8:	7272 7961 2928 773b 6968 656c 6228 323e     rray();while(b>2
 80a4608:	7b29 5b67 5d30 303d 773b 6968 656c 6728     ){g[0]=0;while(g
 80a4618:	305b 3d5d 303d 6629 6e2e 7865 4274 7479     [0]==0)f.nextByt
 80a4628:	7365 6728 3b29 5b63 2d2d 5d62 673d 305b     es(g);c[--b]=g[0
 80a4638:	3b5d 637d 2d5b 622d 3d5d 3b32 5b63 2d2d     ];}c[--b]=2;c[--
 80a4648:	5d62 303d 723b 7465 7275 206e 656e 2077     b]=0;return new 
 80a4658:	6942 4967 746e 6765 7265 6328 3b29 667d     BigInteger(c);}f
 80a4668:	6e75 7463 6f69 206e 5352 4b41 7965 2928     unction RSAKey()
 80a4678:	747b 6968 2e73 3d6e 756e 6c6c 743b 6968     {this.n=null;thi
 80a4688:	2e73 3d65 3b30 6874 7369 642e 6e3d 6c75     s.e=0;this.d=nul
 80a4698:	3b6c 6874 7369 702e 6e3d 6c75 3b6c 6874     l;this.p=null;th
 80a46a8:	7369 712e 6e3d 6c75 3b6c 6874 7369 642e     is.q=null;this.d
 80a46b8:	706d 3d31 756e 6c6c 743b 6968 2e73 6d64     mp1=null;this.dm
 80a46c8:	3171 6e3d 6c75 3b6c 6874 7369 632e 656f     q1=null;this.coe
 80a46d8:	6666 6e3d 6c75 3b6c 667d 6e75 7463 6f69     ff=null;}functio
 80a46e8:	206e 5352 5341 7465 7550 6c62 6369 6128     n RSASetPublic(a
 80a46f8:	622c 7b29 6669 6128 3d21 756e 6c6c 2626     ,b){if(a!=null&&
 80a4708:	2162 6e3d 6c75 266c 6126 6c2e 6e65 7467     b!=null&&a.lengt
 80a4718:	3e68 2630 6226 6c2e 6e65 7467 3e68 2930     h>0&&b.length>0)
 80a4728:	747b 6968 2e73 3d6e 6170 7372 4265 6769     {this.n=parseBig
 80a4738:	6e49 2874 2c61 3631 3b29 6874 7369 652e     Int(a,16);this.e
 80a4748:	703d 7261 6573 6e49 2874 2c62 3631 3b29     =parseInt(b,16);
 80a4758:	657d 736c 2065 6c61 7265 2874 4927 766e     }else alert('Inv
 80a4768:	6c61 6469 5220 4153 7020 6275 696c 2063     alid RSA public 
 80a4778:	656b 2779 3b29 667d 6e75 7463 6f69 206e     key');}function 
 80a4788:	5352 4441 506f 6275 696c 2863 2961 727b     RSADoPublic(a){r
 80a4798:	7465 7275 206e 2e61 6f6d 5064 776f 6e49     eturn a.modPowIn
 80a47a8:	2874 6874 7369 652e 742c 6968 2e73 296e     t(this.e,this.n)
 80a47b8:	7d3b 7566 636e 6974 6e6f 5220 4153 6e45     ;}function RSAEn
 80a47c8:	7263 7079 2874 2961 767b 7261 6220 703d     crypt(a){var b=p
 80a47d8:	636b 3173 6170 3264 6128 282c 6874 7369     kcs1pad2(a,(this
 80a47e8:	6e2e 622e 7469 654c 676e 6874 2928 372b     .n.bitLength()+7
 80a47f8:	3e29 333e 3b29 6669 6228 3d3d 756e 6c6c     )>>3);if(b==null
 80a4808:	7229 7465 7275 206e 756e 6c6c 763b 7261     )return null;var
 80a4818:	6320 743d 6968 2e73 6f64 7550 6c62 6369      c=this.doPublic
 80a4828:	6228 3b29 6669 6328 3d3d 756e 6c6c 7229     (b);if(c==null)r
 80a4838:	7465 7275 206e 756e 6c6c 763b 7261 6420     eturn null;var d
 80a4848:	633d 742e 536f 7274 6e69 2867 3631 3b29     =c.toString(16);
 80a4858:	6669 2828 2e64 656c 676e 6874 3126 3d29     if((d.length&1)=
 80a4868:	303d 7229 7465 7275 206e 3b64 6c65 6573     =0)return d;else
 80a4878:	7220 7465 7275 206e 3027 2b27 3b64 527d      return '0'+d;}R
 80a4888:	4153 654b 2e79 7270 746f 746f 7079 2e65     SAKey.prototype.
 80a4898:	6f64 7550 6c62 6369 523d 4153 6f44 7550     doPublic=RSADoPu
 80a48a8:	6c62 6369 523b 4153 654b 2e79 7270 746f     blic;RSAKey.prot
 80a48b8:	746f 7079 2e65 6573 5074 6275 696c 3d63     otype.setPublic=
 80a48c8:	5352 5341 7465 7550 6c62 6369 523b 4153     RSASetPublic;RSA
 80a48d8:	654b 2e79 7270 746f 746f 7079 2e65 6e65     Key.prototype.en
 80a48e8:	7263 7079 3d74 5352 4541 636e 7972 7470     crypt=RSAEncrypt
 80a48f8:	003b                                        ;.

080a48fa <_ZL9jsbn_2_js>:
 80a48fa:	7566 636e 6974 6e6f 6220 706e 5352 6968     function bnpRShi
 80a490a:	7466 6f54 6128 622c 7b29 2e62 3d73 6874     ftTo(a,b){b.s=th
 80a491a:	7369 732e 763b 7261 6320 4d3d 7461 2e68     is.s;var c=Math.
 80a492a:	6c66 6f6f 2872 2f61 6874 7369 442e 2942     floor(a/this.DB)
 80a493a:	693b 2866 3e63 743d 6968 2e73 2974 627b     ;if(c>=this.t){b
 80a494a:	742e 303d 723b 7465 7275 3b6e 767d 7261     .t=0;return;}var
 80a495a:	6420 613d 7425 6968 2e73 4244 763b 7261      d=a%this.DB;var
 80a496a:	6520 743d 6968 2e73 4244 642d 763b 7261      e=this.DB-d;var
 80a497a:	6620 283d 3c31 643c 2d29 3b31 5b62 5d30      f=(1<<d)-1;b[0]
 80a498a:	743d 6968 5b73 5d63 3e3e 3b64 6f66 2872     =this[c]>>d;for(
 80a499a:	6176 2072 3d67 2b63 3b31 3c67 6874 7369     var g=c+1;g<this
 80a49aa:	742e 2b3b 672b 7b29 5b62 2d67 2d63 5d31     .t;++g){b[g-c-1]
 80a49ba:	3d7c 7428 6968 5b73 5d67 6626 3c29 653c     |=(this[g]&f)<<e
 80a49ca:	623b 675b 632d 3d5d 6874 7369 675b 3e5d     ;b[g-c]=this[g]>
 80a49da:	643e 7d3b 6669 6428 303e 6229 745b 6968     >d;}if(d>0)b[thi
 80a49ea:	2e73 2d74 2d63 5d31 3d7c 7428 6968 2e73     s.t-c-1]|=(this.
 80a49fa:	2673 2966 3c3c 3b65 2e62 3d74 6874 7369     s&f)<<e;b.t=this
 80a4a0a:	742e 632d 623b 632e 616c 706d 2928 7d3b     .t-c;b.clamp();}
 80a4a1a:	7566 636e 6974 6e6f 6220 706e 7553 5462     function bnpSubT
 80a4a2a:	286f 2c61 2962 767b 7261 6320 303d 642c     o(a,b){var c=0,d
 80a4a3a:	303d 652c 4d3d 7461 2e68 696d 286e 2e61     =0,e=Math.min(a.
 80a4a4a:	2c74 6874 7369 742e 3b29 6877 6c69 2865     t,this.t);while(
 80a4a5a:	3c63 2965 647b 3d2b 6874 7369 635b 2d5d     c<e){d+=this[c]-
 80a4a6a:	5b61 5d63 623b 635b 2b2b 3d5d 2664 6874     a[c];b[c++]=d&th
 80a4a7a:	7369 442e 3b4d 3e64 3d3e 6874 7369 442e     is.DM;d>>=this.D
 80a4a8a:	3b42 697d 2866 2e61 3c74 6874 7369 742e     B;}if(a.t<this.t
 80a4a9a:	7b29 2d64 613d 732e 773b 6968 656c 6328     ){d-=a.s;while(c
 80a4aaa:	743c 6968 2e73 2974 647b 3d2b 6874 7369     <this.t){d+=this
 80a4aba:	635b 3b5d 5b62 2b63 5d2b 643d 7426 6968     [c];b[c++]=d&thi
 80a4aca:	2e73 4d44 643b 3e3e 743d 6968 2e73 4244     s.DM;d>>=this.DB
 80a4ada:	7d3b 2b64 743d 6968 2e73 3b73 657d 736c     ;}d+=this.s;}els
 80a4aea:	7b65 2b64 743d 6968 2e73 3b73 6877 6c69     e{d+=this.s;whil
 80a4afa:	2865 3c63 2e61 2974 647b 3d2d 5b61 5d63     e(c<a.t){d-=a[c]
 80a4b0a:	623b 635b 2b2b 3d5d 2664 6874 7369 442e     ;b[c++]=d&this.D
 80a4b1a:	3b4d 3e64 3d3e 6874 7369 442e 3b42 647d     M;d>>=this.DB;}d
 80a4b2a:	3d2d 2e61 3b73 627d 732e 283d 3c64 2930     -=a.s;}b.s=(d<0)
 80a4b3a:	2d3f 3a31 3b30 6669 6428 2d3c 2931 5b62     ?-1:0;if(d<-1)b[
 80a4b4a:	2b63 5d2b 743d 6968 2e73 5644 642b 653b     c++]=this.DV+d;e
 80a4b5a:	736c 2065 6669 6428 303e 6229 635b 2b2b     lse if(d>0)b[c++
 80a4b6a:	3d5d 3b64 2e62 3d74 3b63 2e62 6c63 6d61     ]=d;b.t=c;b.clam
 80a4b7a:	2870 3b29 667d 6e75 7463 6f69 206e 6e62     p();}function bn
 80a4b8a:	4d70 6c75 6974 6c70 5479 286f 2c61 2962     pMultiplyTo(a,b)
 80a4b9a:	767b 7261 6320 743d 6968 2e73 6261 2873     {var c=this.abs(
 80a4baa:	2c29 3d64 2e61 6261 2873 3b29 6176 2072     ),d=a.abs();var 
 80a4bba:	3d65 2e63 3b74 2e62 3d74 2b65 2e64 3b74     e=c.t;b.t=e+d.t;
 80a4bca:	6877 6c69 2865 2d2d 3e65 303d 6229 655b     while(--e>=0)b[e
 80a4bda:	3d5d 3b30 6f66 2872 3d65 3b30 3c65 2e64     ]=0;for(e=0;e<d.
 80a4bea:	3b74 2b2b 2965 5b62 2b65 2e63 5d74 633d     t;++e)b[e+c.t]=c
 80a4bfa:	612e 286d 2c30 5b64 5d65 622c 652c 302c     .am(0,d[e],b,e,0
 80a4c0a:	632c 742e 3b29 2e62 3d73 3b30 2e62 6c63     ,c.t);b.s=0;b.cl
 80a4c1a:	6d61 2870 3b29 6669 7428 6968 2e73 2173     amp();if(this.s!
 80a4c2a:	613d 732e 4229 6769 6e49 6574 6567 2e72     =a.s)BigInteger.
 80a4c3a:	455a 4f52 732e 6275 6f54 6228 622c 3b29     ZERO.subTo(b,b);
 80a4c4a:	667d 6e75 7463 6f69 206e 6e62 5370 7571     }function bnpSqu
 80a4c5a:	7261 5465 286f 2961 767b 7261 6220 743d     areTo(a){var b=t
 80a4c6a:	6968 2e73 6261 2873 3b29 6176 2072 3d63     his.abs();var c=
 80a4c7a:	2e61 3d74 2a32 2e62 3b74 6877 6c69 2865     a.t=2*b.t;while(
 80a4c8a:	2d2d 3e63 303d 6129 635b 3d5d 3b30 6f66     --c>=0)a[c]=0;fo
 80a4c9a:	2872 3d63 3b30 3c63 2e62 2d74 3b31 2b2b     r(c=0;c<b.t-1;++
 80a4caa:	2963 767b 7261 6420 623d 612e 286d 2c63     c){var d=b.am(c,
 80a4cba:	5b62 5d63 612c 322c 632a 302c 312c 3b29     b[c],a,2*c,0,1);
 80a4cca:	6669 2828 5b61 2b63 2e62 5d74 3d2b 2e62     if((a[c+b.t]+=b.
 80a4cda:	6d61 6328 312b 322c 622a 635b 2c5d 2c61     am(c+1,2*b[c],a,
 80a4cea:	2a32 2b63 2c31 2c64 2e62 2d74 2d63 2931     2*c+1,d,b.t-c-1)
 80a4cfa:	3e29 623d 442e 2956 617b 635b 622b 742e     )>=b.DV){a[c+b.t
 80a4d0a:	2d5d 623d 442e 3b56 5b61 2b63 2e62 2b74     ]-=b.DV;a[c+b.t+
 80a4d1a:	5d31 313d 7d3b 697d 2866 2e61 3e74 2930     1]=1;}}if(a.t>0)
 80a4d2a:	5b61 2e61 2d74 5d31 3d2b 2e62 6d61 6328     a[a.t-1]+=b.am(c
 80a4d3a:	622c 635b 2c5d 2c61 2a32 2c63 2c30 2931     ,b[c],a,2*c,0,1)
 80a4d4a:	613b 732e 303d 613b 632e 616c 706d 2928     ;a.s=0;a.clamp()
 80a4d5a:	7d3b 7566 636e 6974 6e6f 6220 706e 6944     ;}function bnpDi
 80a4d6a:	5276 6d65 6f54 6128 622c 632c 7b29 6176     vRemTo(a,b,c){va
 80a4d7a:	2072 3d64 2e61 6261 2873 3b29 6669 6428     r d=a.abs();if(d
 80a4d8a:	742e 3d3c 2930 6572 7574 6e72 763b 7261     .t<=0)return;var
 80a4d9a:	6520 743d 6968 2e73 6261 2873 3b29 6669      e=this.abs();if
 80a4daa:	6528 742e 643c 742e 7b29 6669 6228 3d21     (e.t<d.t){if(b!=
 80a4dba:	756e 6c6c 6229 662e 6f72 496d 746e 3028     null)b.fromInt(0
 80a4dca:	3b29 6669 6328 3d21 756e 6c6c 7429 6968     );if(c!=null)thi
 80a4dda:	2e73 6f63 7970 6f54 6328 3b29 6572 7574     s.copyTo(c);retu
 80a4dea:	6e72 7d3b 6669 6328 3d3d 756e 6c6c 6329     rn;}if(c==null)c
 80a4dfa:	6e3d 6962 2928 763b 7261 6620 6e3d 6962     =nbi();var f=nbi
 80a4e0a:	2928 672c 743d 6968 2e73 2c73 3d68 2e61     (),g=this.s,h=a.
 80a4e1a:	3b73 6176 2072 3d69 6874 7369 442e 2d42     s;var i=this.DB-
 80a4e2a:	626e 7469 2873 5b64 2e64 2d74 5d31 3b29     nbits(d[d.t-1]);
 80a4e3a:	6669 6928 303e 7b29 2e64 536c 6968 7466     if(i>0){d.lShift
 80a4e4a:	6f54 6928 662c 3b29 2e65 536c 6968 7466     To(i,f);e.lShift
 80a4e5a:	6f54 6928 632c 3b29 657d 736c 7b65 2e64     To(i,c);}else{d.
 80a4e6a:	6f63 7970 6f54 6628 3b29 2e65 6f63 7970     copyTo(f);e.copy
 80a4e7a:	6f54 6328 3b29 767d 7261 6a20 663d 742e     To(c);}var j=f.t
 80a4e8a:	763b 7261 6b20 663d 6a5b 312d 3b5d 6669     ;var k=f[j-1];if
 80a4e9a:	6b28 3d3d 2930 6572 7574 6e72 763b 7261     (k==0)return;var
 80a4eaa:	6c20 6b3d 282a 3c31 743c 6968 2e73 3146      l=k*(1<<this.F1
 80a4eba:	2b29 2828 3e6a 2931 663f 6a5b 322d 3e5d     )+((j>1)?f[j-2]>
 80a4eca:	743e 6968 2e73 3246 303a 3b29 6176 2072     >this.F2:0);var 
 80a4eda:	3d6d 6874 7369 462e 2f56 2c6c 3d6e 3128     m=this.FV/l,n=(1
 80a4eea:	3c3c 6874 7369 462e 2931 6c2f 6f2c 313d     <<this.F1)/l,o=1
 80a4efa:	3c3c 6874 7369 462e 3b32 6176 2072 3d70     <<this.F2;var p=
 80a4f0a:	2e63 2c74 3d71 2d70 2c6a 3d72 6228 3d3d     c.t,q=p-j,r=(b==
 80a4f1a:	756e 6c6c 3f29 626e 2869 3a29 3b62 2e66     null)?nbi():b;f.
 80a4f2a:	6c64 6853 6669 5474 286f 2c71 2972 693b     dlShiftTo(q,r);i
 80a4f3a:	2866 2e63 6f63 706d 7261 5465 286f 2972     f(c.compareTo(r)
 80a4f4a:	3d3e 2930 637b 635b 742e 2b2b 3d5d 3b31     >=0){c[c.t++]=1;
 80a4f5a:	2e63 7573 5462 286f 2c72 2963 7d3b 6942     c.subTo(r,c);}Bi
 80a4f6a:	4967 746e 6765 7265 4f2e 454e 642e 536c     gInteger.ONE.dlS
 80a4f7a:	6968 7466 6f54 6a28 722c 3b29 2e72 7573     hiftTo(j,r);r.su
 80a4f8a:	5462 286f 2c66 2966 773b 6968 656c 6628     bTo(f,f);while(f
 80a4f9a:	742e 6a3c 6629 665b 742e 2b2b 3d5d 3b30     .t<j)f[f.t++]=0;
 80a4faa:	6877 6c69 2865 2d2d 3e71 303d 7b29 6176     while(--q>=0){va
 80a4fba:	2072 3d73 6328 2d5b 702d 3d5d 6b3d 3f29     r s=(c[--p]==k)?
 80a4fca:	6874 7369 442e 3a4d 614d 6874 662e 6f6c     this.DM:Math.flo
 80a4fda:	726f 6328 705b 2a5d 2b6d 6328 705b 312d     or(c[p]*m+(c[p-1
 80a4fea:	2b5d 296f 6e2a 3b29 6669 2828 5b63 5d70     ]+o)*n);if((c[p]
 80a4ffa:	3d2b 2e66 6d61 3028 732c 632c 712c 302c     +=f.am(0,s,c,q,0
 80a500a:	6a2c 2929 733c 7b29 2e66 6c64 6853 6669     ,j))<s){f.dlShif
 80a501a:	5474 286f 2c71 2972 633b 732e 6275 6f54     tTo(q,r);c.subTo
 80a502a:	7228 632c 3b29 6877 6c69 2865 5b63 5d70     (r,c);while(c[p]
 80a503a:	2d3c 732d 6329 732e 6275 6f54 7228 632c     <--s)c.subTo(r,c
 80a504a:	3b29 7d7d 6669 6228 3d21 756e 6c6c 7b29     );}}if(b!=null){
 80a505a:	2e63 7264 6853 6669 5474 286f 2c6a 2962     c.drShiftTo(j,b)
 80a506a:	693b 2866 2167 683d 4229 6769 6e49 6574     ;if(g!=h)BigInte
 80a507a:	6567 2e72 455a 4f52 732e 6275 6f54 6228     ger.ZERO.subTo(b
 80a508a:	622c 3b29 637d 742e 6a3d 633b 632e 616c     ,b);}c.t=j;c.cla
 80a509a:	706d 2928 693b 2866 3e69 2930 2e63 5372     mp();if(i>0)c.rS
 80a50aa:	6968 7466 6f54 6928 632c 3b29 6669 6728     hiftTo(i,c);if(g
 80a50ba:	303c 4229 6769 6e49 6574 6567 2e72 455a     <0)BigInteger.ZE
 80a50ca:	4f52 732e 6275 6f54 6328 632c 3b29 667d     RO.subTo(c,c);}f
 80a50da:	6e75 7463 6f69 206e 6e62 6f4d 2864 2961     unction bnMod(a)
 80a50ea:	767b 7261 6220 6e3d 6962 2928 743b 6968     {var b=nbi();thi
 80a50fa:	2e73 6261 2873 2e29 6964 5276 6d65 6f54     s.abs().divRemTo
 80a510a:	6128 6e2c 6c75 2c6c 2962 693b 2866 6874     (a,null,b);if(th
 80a511a:	7369 732e 303c 2626 2e62 6f63 706d 7261     is.s<0&&b.compar
 80a512a:	5465 286f 6942 4967 746e 6765 7265 5a2e     eTo(BigInteger.Z
 80a513a:	5245 294f 303e 6129 732e 6275 6f54 6228     ERO)>0)a.subTo(b
 80a514a:	622c 3b29 6572 7574 6e72 6220 7d3b 7566     ,b);return b;}fu
 80a515a:	636e 6974 6e6f 4320 616c 7373 6369 6128     nction Classic(a
 80a516a:	7b29 6874 7369 6d2e 613d 7d3b 7566 636e     ){this.m=a;}func
 80a517a:	6974 6e6f 6320 6f43 766e 7265 2874 2961     tion cConvert(a)
 80a518a:	697b 2866 2e61 3c73 7c30 617c 632e 6d6f     {if(a.s<0||a.com
 80a519a:	6170 6572 6f54 7428 6968 2e73 296d 3d3e     pareTo(this.m)>=
 80a51aa:	2930 6572 7574 6e72 6120 6d2e 646f 7428     0)return a.mod(t
 80a51ba:	6968 2e73 296d 653b 736c 2065 6572 7574     his.m);else retu
 80a51ca:	6e72 6120 7d3b 7566 636e 6974 6e6f 6320     rn a;}function c
 80a51da:	6552 6576 7472 6128 7b29 6572 7574 6e72     Revert(a){return
 80a51ea:	6120 7d3b 7566 636e 6974 6e6f 6320 6552      a;}function cRe
 80a51fa:	7564 6563 6128 7b29 2e61 6964 5276 6d65     duce(a){a.divRem
 80a520a:	6f54 7428 6968 2e73 2c6d 756e 6c6c 612c     To(this.m,null,a
 80a521a:	3b29 667d 6e75 7463 6f69 206e 4d63 6c75     );}function cMul
 80a522a:	6f54 6128 622c 632c 7b29 2e61 756d 746c     To(a,b,c){a.mult
 80a523a:	7069 796c 6f54 6228 632c 3b29 6874 7369     iplyTo(b,c);this
 80a524a:	722e 6465 6375 2865 2963 7d3b 7566 636e     .reduce(c);}func
 80a525a:	6974 6e6f 6320 7153 5472 286f 2c61 2962     tion cSqrTo(a,b)
 80a526a:	617b 732e 7571 7261 5465 286f 2962 743b     {a.squareTo(b);t
 80a527a:	6968 2e73 6572 7564 6563 6228 3b29 437d     his.reduce(b);}C
 80a528a:	616c 7373 6369 702e 6f72 6f74 7974 6570     lassic.prototype
 80a529a:	632e 6e6f 6576 7472 633d 6f43 766e 7265     .convert=cConver
 80a52aa:	3b74 6c43 7361 6973 2e63 7270 746f 746f     t;Classic.protot
 80a52ba:	7079 2e65 6572 6576 7472 633d 6552 6576     ype.revert=cReve
 80a52ca:	7472 433b 616c 7373 6369 702e 6f72 6f74     rt;Classic.proto
 80a52da:	7974 6570 722e 6465 6375 3d65 5263 6465     type.reduce=cRed
 80a52ea:	6375 3b65 6c43 7361 6973 2e63 7270 746f     uce;Classic.prot
 80a52fa:	746f 7079 2e65 756d 546c 3d6f 4d63 6c75     otype.mulTo=cMul
 80a530a:	6f54 433b 616c 7373 6369 702e 6f72 6f74     To;Classic.proto
 80a531a:	7974 6570 732e 7271 6f54 633d 7153 5472     type.sqrTo=cSqrT
 80a532a:	3b6f 7566 636e 6974 6e6f 6220 706e 6e49     o;function bnpIn
 80a533a:	4476 6769 7469 2928 697b 2866 6874 7369     vDigit(){if(this
 80a534a:	742e 313c 7229 7465 7275 206e 3b30 6176     .t<1)return 0;va
 80a535a:	2072 3d61 6874 7369 305b 3b5d 6669 2828     r a=this[0];if((
 80a536a:	2661 2931 3d3d 2930 6572 7574 6e72 3020     a&1)==0)return 0
 80a537a:	763b 7261 6220 613d 3326 623b 283d 2a62     ;var b=a&3;b=(b*
 80a538a:	3228 282d 2661 7830 2966 622a 2929 3026     (2-(a&0xf)*b))&0
 80a539a:	6678 623b 283d 2a62 3228 282d 2661 7830     xf;b=(b*(2-(a&0x
 80a53aa:	6666 2a29 2962 2629 7830 6666 623b 283d     ff)*b))&0xff;b=(
 80a53ba:	2a62 3228 282d 2828 2661 7830 6666 6666     b*(2-(((a&0xffff
 80a53ca:	2a29 2962 3026 6678 6666 2966 2929 3026     )*b)&0xffff)))&0
 80a53da:	6678 6666 3b66 3d62 6228 282a 2d32 2a61     xffff;b=(b*(2-a*
 80a53ea:	2562 6874 7369 442e 2956 2529 6874 7369     b%this.DV))%this
 80a53fa:	442e 3b56 6572 7574 6e72 6228 303e 3f29     .DV;return(b>0)?
 80a540a:	6874 7369 442e 2d56 3a62 622d 7d3b 7566     this.DV-b:-b;}fu
 80a541a:	636e 6974 6e6f 4d20 6e6f 6774 6d6f 7265     nction Montgomer
 80a542a:	2879 2961 747b 6968 2e73 3d6d 3b61 6874     y(a){this.m=a;th
 80a543a:	7369 6d2e 3d70 2e61 6e69 4476 6769 7469     is.mp=a.invDigit
 80a544a:	2928 743b 6968 2e73 706d 3d6c 6874 7369     ();this.mpl=this
 80a545a:	6d2e 2670 7830 6637 6666 743b 6968 2e73     .mp&0x7fff;this.
 80a546a:	706d 3d68 6874 7369 6d2e 3e70 313e 3b35     mph=this.mp>>15;
 80a547a:	6874 7369 752e 3d6d 3128 3c3c 6128 442e     this.um=(1<<(a.D
 80a548a:	2d42 3531 2929 312d 743b 6968 2e73 746d     B-15))-1;this.mt
 80a549a:	3d32 2a32 2e61 3b74 667d 6e75 7463 6f69     2=2*a.t;}functio
 80a54aa:	206e 6f6d 746e 6f43 766e 7265 2874 2961     n montConvert(a)
 80a54ba:	767b 7261 6220 6e3d 6962 2928 613b 612e     {var b=nbi();a.a
 80a54ca:	7362 2928 642e 536c 6968 7466 6f54 7428     bs().dlShiftTo(t
 80a54da:	6968 2e73 2e6d 2c74 2962 623b 642e 7669     his.m.t,b);b.div
 80a54ea:	6552 546d 286f 6874 7369 6d2e 6e2c 6c75     RemTo(this.m,nul
 80a54fa:	2c6c 2962 693b 2866 2e61 3c73 2630 6226     l,b);if(a.s<0&&b
 80a550a:	632e 6d6f 6170 6572 6f54 4228 6769 6e49     .compareTo(BigIn
 80a551a:	6574 6567 2e72 455a 4f52 3e29 2930 6874     teger.ZERO)>0)th
 80a552a:	7369 6d2e 732e 6275 6f54 6228 622c 3b29     is.m.subTo(b,b);
 80a553a:	6572 7574 6e72 6220 7d3b 7566 636e 6974     return b;}functi
 80a554a:	6e6f 6d20 6e6f 5274 7665 7265 2874 2961     on montRevert(a)
 80a555a:	767b 7261 6220 6e3d 6962 2928 613b 632e     {var b=nbi();a.c
 80a556a:	706f 5479 286f 2962 743b 6968 2e73 6572     opyTo(b);this.re
 80a557a:	7564 6563 6228 3b29 6572 7574 6e72 6220     duce(b);return b
 80a558a:	7d3b 7566 636e 6974 6e6f 6d20 6e6f 5274     ;}function montR
 80a559a:	6465 6375 2865 2961 777b 6968 656c 6128     educe(a){while(a
 80a55aa:	742e 3d3c 6874 7369 6d2e 3274 6129 615b     .t<=this.mt2)a[a
 80a55ba:	742e 2b2b 3d5d 3b30 6f66 2872 6176 2072     .t++]=0;for(var 
 80a55ca:	3d62 3b30 3c62 6874 7369 6d2e 742e 2b3b     b=0;b<this.m.t;+
 80a55da:	622b 7b29 6176 2072 3d63 5b61 5d62 3026     +b){var c=a[b]&0
 80a55ea:	3778 6666 3b66 6176 2072 3d64 6328 742a     x7fff;var d=(c*t
 80a55fa:	6968 2e73 706d 2b6c 2828 6328 742a 6968     his.mpl+(((c*thi
 80a560a:	2e73 706d 2b68 6128 625b 3e5d 313e 2935     s.mph+(a[b]>>15)
 80a561a:	742a 6968 2e73 706d 296c 7426 6968 2e73     *this.mpl)&this.
 80a562a:	6d75 3c29 313c 2935 2629 2e61 4d44 633b     um)<<15))&a.DM;c
 80a563a:	623d 742b 6968 2e73 2e6d 3b74 5b61 5d63     =b+this.m.t;a[c]
 80a564a:	3d2b 6874 7369 6d2e 612e 286d 2c30 2c64     +=this.m.am(0,d,
 80a565a:	2c61 2c62 2c30 6874 7369 6d2e 742e 3b29     a,b,0,this.m.t);
 80a566a:	6877 6c69 2865 5b61 5d63 3d3e 2e61 5644     while(a[c]>=a.DV
 80a567a:	7b29 5b61 5d63 3d2d 2e61 5644 613b 2b5b     ){a[c]-=a.DV;a[+
 80a568a:	632b 2b5d 3b2b 7d7d 2e61 6c63 6d61 2870     +c]++;}}a.clamp(
 80a569a:	3b29 2e61 7264 6853 6669 5474 286f 6874     );a.drShiftTo(th
 80a56aa:	7369 6d2e 742e 612c 3b29 6669 6128 632e     is.m.t,a);if(a.c
 80a56ba:	6d6f 6170 6572 6f54 7428 6968 2e73 296d     ompareTo(this.m)
 80a56ca:	3d3e 2930 2e61 7573 5462 286f 6874 7369     >=0)a.subTo(this
 80a56da:	6d2e 612c 3b29 667d 6e75 7463 6f69 206e     .m,a);}function 
 80a56ea:	6f6d 746e 7153 5472 286f 2c61 2962 617b     montSqrTo(a,b){a
 80a56fa:	732e 7571 7261 5465 286f 2962 743b 6968     .squareTo(b);thi
 80a570a:	2e73 6572 7564 6563 6228 3b29 667d 6e75     s.reduce(b);}fun
 80a571a:	7463 6f69 206e 6f6d 746e 754d 546c 286f     ction montMulTo(
 80a572a:	2c61 2c62 2963 617b 6d2e 6c75 6974 6c70     a,b,c){a.multipl
 80a573a:	5479 286f 2c62 2963 743b 6968 2e73 6572     yTo(b,c);this.re
 80a574a:	7564 6563 6328 3b29 4d7d 6e6f 6774 6d6f     duce(c);}Montgom
 80a575a:	7265 2e79 7270 746f 746f 7079 2e65 6f63     ery.prototype.co
 80a576a:	766e 7265 3d74 6f6d 746e 6f43 766e 7265     nvert=montConver
 80a577a:	3b74 6f4d 746e 6f67 656d 7972 702e 6f72     t;Montgomery.pro
 80a578a:	6f74 7974 6570 722e 7665 7265 3d74 6f6d     totype.revert=mo
 80a579a:	746e 6552 6576 7472 4d3b 6e6f 6774 6d6f     ntRevert;Montgom
 80a57aa:	7265 2e79 7270 746f 746f 7079 2e65 6572     ery.prototype.re
 80a57ba:	7564 6563 6d3d 6e6f 5274 6465 6375 3b65     duce=montReduce;
 80a57ca:	6f4d 746e 6f67 656d 7972 702e 6f72 6f74     Montgomery.proto
 80a57da:	7974 6570 6d2e 6c75 6f54 6d3d 6e6f 4d74     type.mulTo=montM
 80a57ea:	6c75 6f54 4d3b 6e6f 6774 6d6f 7265 2e79     ulTo;Montgomery.
 80a57fa:	7270 746f 746f 7079 2e65 7173 5472 3d6f     prototype.sqrTo=
 80a580a:	6f6d 746e 7153 5472 3b6f 7566 636e 6974     montSqrTo;functi
 80a581a:	6e6f 6220 706e 7349 7645 6e65 2928 727b     on bnpIsEven(){r
 80a582a:	7465 7275 286e 7428 6968 2e73 3e74 2930     eturn((this.t>0)
 80a583a:	283f 6874 7369 305b 265d 2931 743a 6968     ?(this[0]&1):thi
 80a584a:	2e73 2973 3d3d 3b30 667d 6e75 7463 6f69     s.s)==0;}functio
 80a585a:	206e 6e62 4570 7078 6128 622c 7b29 6669     n bnpExp(a,b){if
 80a586a:	6128 303e 6678 6666 6666 6666 7c66 617c     (a>0xffffffff||a
 80a587a:	313c 7229 7465 7275 206e 6942 4967 746e     <1)return BigInt
 80a588a:	6765 7265 4f2e 454e 763b 7261 6320 6e3d     eger.ONE;var c=n
 80a589a:	6962 2928 642c 6e3d 6962 2928 652c 623d     bi(),d=nbi(),e=b
 80a58aa:	632e 6e6f 6576 7472 7428 6968 2973 662c     .convert(this),f
 80a58ba:	6e3d 6962 7374 6128 2d29 3b31 2e65 6f63     =nbits(a)-1;e.co
 80a58ca:	7970 6f54 6328 3b29 6877 6c69 2865 2d2d     pyTo(c);while(--
 80a58da:	3e66 303d 7b29 2e62 7173 5472 286f 2c63     f>=0){b.sqrTo(c,
 80a58ea:	2964 693b 2866 6128 2826 3c31 663c 2929     d);if((a&(1<<f))
 80a58fa:	303e 6229 6d2e 6c75 6f54 6428 652c 632c     >0)b.mulTo(d,e,c
 80a590a:	3b29 6c65 6573 767b 7261 6720 633d 633b     );else{var g=c;c
 80a591a:	643d 643b 673d 7d3b 727d 7465 7275 206e     =d;d=g;}}return 
 80a592a:	2e62 6572 6576 7472 6328 3b29 667d 6e75     b.revert(c);}fun
 80a593a:	7463 6f69 206e 6e62 6f4d 5064 776f 6e49     ction bnModPowIn
 80a594a:	2874 2c61 2962 767b 7261 6320 693b 2866     t(a,b){var c;if(
 80a595a:	3c61 3532 7c36 627c 692e 4573 6576 286e     a<256||b.isEven(
 80a596a:	2929 3d63 656e 2077 6c43 7361 6973 2863     ))c=new Classic(
 80a597a:	2962 653b 736c 2065 3d63 656e 2077 6f4d     b);else c=new Mo
 80a598a:	746e 6f67 656d 7972 6228 3b29 6572 7574     ntgomery(b);retu
 80a599a:	6e72 7420 6968 2e73 7865 2870 2c61 2963     rn this.exp(a,c)
 80a59aa:	7d3b 6942 4967 746e 6765 7265 702e 6f72     ;}BigInteger.pro
 80a59ba:	6f74 7974 6570 632e 706f 5479 3d6f 6e62     totype.copyTo=bn
 80a59ca:	4370 706f 5479 3b6f 6942 4967 746e 6765     pCopyTo;BigInteg
 80a59da:	7265 702e 6f72 6f74 7974 6570 662e 6f72     er.prototype.fro
 80a59ea:	496d 746e 623d 706e 7246 6d6f 6e49 3b74     mInt=bnpFromInt;
 80a59fa:	6942 4967 746e 6765 7265 702e 6f72 6f74     BigInteger.proto
 80a5a0a:	7974 6570 662e 6f72 536d 7274 6e69 3d67     type.fromString=
 80a5a1a:	6e62 4670 6f72 536d 7274 6e69 3b67 6942     bnpFromString;Bi
 80a5a2a:	4967 746e 6765 7265 702e 6f72 6f74 7974     gInteger.prototy
 80a5a3a:	6570 632e 616c 706d 623d 706e 6c43 6d61     pe.clamp=bnpClam
 80a5a4a:	3b70 6942 4967 746e 6765 7265 702e 6f72     p;BigInteger.pro
 80a5a5a:	6f74 7974 6570 642e 536c 6968 7466 6f54     totype.dlShiftTo
 80a5a6a:	623d 706e 4c44 6853 6669 5474 3b6f 6942     =bnpDLShiftTo;Bi
 80a5a7a:	4967 746e 6765 7265 702e 6f72 6f74 7974     gInteger.prototy
 80a5a8a:	6570 642e 5372 6968 7466 6f54 623d 706e     pe.drShiftTo=bnp
 80a5a9a:	5244 6853 6669 5474 3b6f 6942 4967 746e     DRShiftTo;BigInt
 80a5aaa:	6765 7265 702e 6f72 6f74 7974 6570 6c2e     eger.prototype.l
 80a5aba:	6853 6669 5474 3d6f 6e62 4c70 6853 6669     ShiftTo=bnpLShif
 80a5aca:	5474 3b6f 6942 4967 746e 6765 7265 702e     tTo;BigInteger.p
 80a5ada:	6f72 6f74 7974 6570 722e 6853 6669 5474     rototype.rShiftT
 80a5aea:	3d6f 6e62 5270 6853 6669 5474 3b6f 6942     o=bnpRShiftTo;Bi
 80a5afa:	4967 746e 6765 7265 702e 6f72 6f74 7974     gInteger.prototy
 80a5b0a:	6570 732e 6275 6f54 623d 706e 7553 5462     pe.subTo=bnpSubT
 80a5b1a:	3b6f 6942 4967 746e 6765 7265 702e 6f72     o;BigInteger.pro
 80a5b2a:	6f74 7974 6570 6d2e 6c75 6974 6c70 5479     totype.multiplyT
 80a5b3a:	3d6f 6e62 4d70 6c75 6974 6c70 5479 3b6f     o=bnpMultiplyTo;
 80a5b4a:	6942 4967 746e 6765 7265 702e 6f72 6f74     BigInteger.proto
 80a5b5a:	7974 6570 732e 7571 7261 5465 3d6f 6e62     type.squareTo=bn
 80a5b6a:	5370 7571 7261 5465 3b6f 6942 4967 746e     pSquareTo;BigInt
 80a5b7a:	6765 7265 702e 6f72 6f74 7974 6570 642e     eger.prototype.d
 80a5b8a:	7669 6552 546d 3d6f 6e62 4470 7669 6552     ivRemTo=bnpDivRe
 80a5b9a:	546d 3b6f 6942 4967 746e 6765 7265 702e     mTo;BigInteger.p
 80a5baa:	6f72 6f74 7974 6570 692e 766e 6944 6967     rototype.invDigi
 80a5bba:	3d74 6e62 4970 766e 6944 6967 3b74 6942     t=bnpInvDigit;Bi
 80a5bca:	4967 746e 6765 7265 702e 6f72 6f74 7974     gInteger.prototy
 80a5bda:	6570 692e 4573 6576 3d6e 6e62 4970 4573     pe.isEven=bnpIsE
 80a5bea:	6576 3b6e 6942 4967 746e 6765 7265 702e     ven;BigInteger.p
 80a5bfa:	6f72 6f74 7974 6570 652e 7078 623d 706e     rototype.exp=bnp
 80a5c0a:	7845 3b70 6942 4967 746e 6765 7265 702e     Exp;BigInteger.p
 80a5c1a:	6f72 6f74 7974 6570 742e 536f 7274 6e69     rototype.toStrin
 80a5c2a:	3d67 6e62 6f54 7453 6972 676e 423b 6769     g=bnToString;Big
 80a5c3a:	6e49 6574 6567 2e72 7270 746f 746f 7079     Integer.prototyp
 80a5c4a:	2e65 656e 6167 6574 623d 4e6e 6765 7461     e.negate=bnNegat
 80a5c5a:	3b65 6942 4967 746e 6765 7265 702e 6f72     e;BigInteger.pro
 80a5c6a:	6f74 7974 6570 612e 7362 623d 416e 7362     totype.abs=bnAbs
 80a5c7a:	423b 6769 6e49 6574 6567 2e72 7270 746f     ;BigInteger.prot
 80a5c8a:	746f 7079 2e65 6f63 706d 7261 5465 3d6f     otype.compareTo=
 80a5c9a:	6e62 6f43 706d 7261 5465 3b6f 6942 4967     bnCompareTo;BigI
 80a5caa:	746e 6765 7265 702e 6f72 6f74 7974 6570     nteger.prototype
 80a5cba:	622e 7469 654c 676e 6874 623d 426e 7469     .bitLength=bnBit
 80a5cca:	654c 676e 6874 423b 6769 6e49 6574 6567     Length;BigIntege
 80a5cda:	2e72 7270 746f 746f 7079 2e65 6f6d 3d64     r.prototype.mod=
 80a5cea:	6e62 6f4d 3b64 6942 4967 746e 6765 7265     bnMod;BigInteger
 80a5cfa:	702e 6f72 6f74 7974 6570 6d2e 646f 6f50     .prototype.modPo
 80a5d0a:	4977 746e 623d 4d6e 646f 6f50 4977 746e     wInt=bnModPowInt
 80a5d1a:	423b 6769 6e49 6574 6567 2e72 455a 4f52     ;BigInteger.ZERO
 80a5d2a:	6e3d 7662 3028 3b29 6942 4967 746e 6765     =nbv(0);BigInteg
 80a5d3a:	7265 4f2e 454e 6e3d 7662 3128 3b29 3c00          er.ONE=nbv(1);.

080a5d49 <_ZL10index_html>:
 80a5d49:	213c 4f44 5443 5059 2045 7468 6c6d 3c3e     <!DOCTYPE html><
 80a5d59:	7468 6c6d 3c3e 6568 6461 3c3e 656d 6174     html><head><meta
 80a5d69:	6e20 6d61 3d65 7627 6569 7077 726f 2774      name='viewport'
 80a5d79:	6320 6e6f 6574 746e 273d 6977 7464 3d68      content='width=
 80a5d89:	6564 6976 6563 772d 6469 6874 202c 6e69     device-width, in
 80a5d99:	7469 6169 2d6c 6373 6c61 3d65 2731 3c3e     itial-scale=1'><
 80a5da9:	6974 6c74 3e65 6553 7574 2070 6f79 7275     title>Setup your
 80a5db9:	6420 7665 6369 3c65 742f 7469 656c 3c3e      device</title><
 80a5dc9:	696c 6b6e 7220 6c65 273d 7473 6c79 7365     link rel='styles
 80a5dd9:	6568 7465 2027 7974 6570 273d 6574 7478     heet' type='text
 80a5de9:	632f 7373 2027 7268 6665 273d 7473 6c79     /css' href='styl
 80a5df9:	2e65 7363 2773 3c3e 682f 6165 3e64 623c     e.css'></head><b
 80a5e09:	646f 3e79 683c 3e31 6f43 6e6e 6365 2074     ody><h1>Connect 
 80a5e19:	656d 7420 206f 6f79 7275 5720 4669 2169     me to your WiFi!
 80a5e29:	2f3c 3168 3c3e 3368 4d3e 2079 6564 6976     </h1><h3>My devi
 80a5e39:	6563 4920 3a44 2f3c 3368 3c3e 6e69 7570     ce ID:</h3><inpu
 80a5e49:	2074 7974 6570 743d 7865 2074 6469 273d     t type=text id='
 80a5e59:	6564 6976 6563 692d 2764 7320 7a69 3d65     device-id' size=
 80a5e69:	3227 2735 7620 6c61 6575 273d 2027 6964     '25' value='' di
 80a5e79:	6173 6c62 6465 3e2f 623c 7475 6f74 206e     sabled/><button 
 80a5e89:	7974 6570 273d 7562 7474 6e6f 2027 6c63     type='button' cl
 80a5e99:	7361 3d73 6927 706e 7475 682d 6c65 6570     ass='input-helpe
 80a5ea9:	2772 6920 3d64 6327 706f 2d79 7562 7474     r' id='copy-butt
 80a5eb9:	6e6f 3e27 6f43 7970 2f3c 7562 7474 6e6f     on'>Copy</button
 80a5ec9:	3c3e 6964 2076 6469 273d 6373 6e61 642d     ><div id='scan-d
 80a5ed9:	7669 3e27 683c 3e33 6353 6e61 6620 726f     iv'><h3>Scan for
 80a5ee9:	7620 7369 6269 656c 5720 4669 2069 656e      visible WiFi ne
 80a5ef9:	7774 726f 736b 2f3c 3368 3c3e 7562 7474     tworks</h3><butt
 80a5f09:	6e6f 6920 3d64 7327 6163 2d6e 7562 7474     on id='scan-butt
 80a5f19:	6e6f 2027 7974 6570 273d 7562 7474 6e6f     on' type='button
 80a5f29:	3e27 6353 6e61 2f3c 7562 7474 6e6f 3c3e     '>Scan</button><
 80a5f39:	642f 7669 3c3e 6964 2076 6469 273d 656e     /div><div id='ne
 80a5f49:	7774 726f 736b 642d 7669 3e27 2f3c 6964     tworks-div'></di
 80a5f59:	3e76 643c 7669 6920 3d64 6327 6e6f 656e     v><div id='conne
 80a5f69:	7463 642d 7669 2027 7473 6c79 3d65 6427     ct-div' style='d
 80a5f79:	7369 6c70 7961 203a 6f6e 656e 3e27 703c     isplay: none'><p
 80a5f89:	443e 6e6f 7427 7320 6565 7920 756f 2072     >Don't see your 
 80a5f99:	656e 7774 726f 3f6b 4d20 766f 2065 656d     network? Move me
 80a5fa9:	6320 6f6c 6573 2072 6f74 7920 756f 2072      closer to your 
 80a5fb9:	6f72 7475 7265 202c 6874 6e65 7220 2d65     router, then re-
 80a5fc9:	6373 6e61 3c2e 702f 3c3e 6f66 6d72 6920     scan.</p><form i
 80a5fd9:	3d64 6327 6e6f 656e 7463 662d 726f 276d     d='connect-form'
 80a5fe9:	3c3e 6e69 7570 2074 7974 6570 273d 6170     ><input type='pa
 80a5ff9:	7373 6f77 6472 2027 6469 273d 6170 7373     ssword' id='pass
 80a6009:	6f77 6472 2027 6973 657a 273d 3532 2027     word' size='25' 
 80a6019:	6c70 6361 6865 6c6f 6564 3d72 7027 7361     placeholder='pas
 80a6029:	7773 726f 2764 3e2f 623c 7475 6f74 206e     sword'/><button 
 80a6039:	7974 6570 273d 7562 7474 6e6f 2027 6c63     type='button' cl
 80a6049:	7361 3d73 6927 706e 7475 682d 6c65 6570     ass='input-helpe
 80a6059:	2772 6920 3d64 7327 6f68 2d77 7562 7474     r' id='show-butt
 80a6069:	6e6f 3e27 6853 776f 2f3c 7562 7474 6e6f     on'>Show</button
 80a6079:	3c3e 7562 7474 6e6f 7420 7079 3d65 7327     ><button type='s
 80a6089:	6275 696d 2774 6920 3d64 6327 6e6f 656e     ubmit' id='conne
 80a6099:	7463 622d 7475 6f74 276e 433e 6e6f 656e     ct-button'>Conne
 80a60a9:	7463 2f3c 7562 7474 6e6f 3c3e 662f 726f     ct</button></for
 80a60b9:	3e6d 2f3c 6964 3e76 733c 7263 7069 2074     m></div><script 
 80a60c9:	7273 3d63 7227 6173 752d 6974 736c 6a2f     src='rsa-utils/j
 80a60d9:	6273 5f6e 2e31 736a 3e27 2f3c 6373 6972     sbn_1.js'></scri
 80a60e9:	7470 3c3e 6373 6972 7470 7320 6372 273d     pt><script src='
 80a60f9:	7372 2d61 7475 6c69 2f73 736a 6e62 325f     rsa-utils/jsbn_2
 80a6109:	6a2e 2773 3c3e 732f 7263 7069 3e74 733c     .js'></script><s
 80a6119:	7263 7069 2074 7273 3d63 7227 6173 752d     cript src='rsa-u
 80a6129:	6974 736c 702f 6e72 3467 6a2e 2773 3c3e     tils/prng4.js'><
 80a6139:	732f 7263 7069 3e74 733c 7263 7069 2074     /script><script 
 80a6149:	7273 3d63 7227 6173 752d 6974 736c 722f     src='rsa-utils/r
 80a6159:	676e 6a2e 2773 3c3e 732f 7263 7069 3e74     ng.js'></script>
 80a6169:	733c 7263 7069 2074 7273 3d63 7227 6173     <script src='rsa
 80a6179:	752d 6974 736c 722f 6173 6a2e 2773 3c3e     -utils/rsa.js'><
 80a6189:	732f 7263 7069 3e74 733c 7263 7069 2074     /script><script 
 80a6199:	7273 3d63 7327 7263 7069 2e74 736a 3e27     src='script.js'>
 80a61a9:	2f3c 6373 6972 7470 3c3e 622f 646f 3e79     </script></body>
 80a61b9:	2f3c 7468 6c6d 003e                         </html>.

080a61c1 <_ZL9jsbn_1_js>:
 80a61c1:	6176 2072 6264 7469 3b73 6176 2072 6163     var dbits;var ca
 80a61d1:	616e 7972 303d 6478 6165 6264 6565 6366     nary=0xdeadbeefc
 80a61e1:	6661 3b65 6176 2072 5f6a 6d6c 283d 6328     afe;var j_lm=((c
 80a61f1:	6e61 7261 2679 7830 6666 6666 6666 3d29     anary&0xffffff)=
 80a6201:	303d 6578 6366 6661 2965 663b 6e75 7463     =0xefcafe);funct
 80a6211:	6f69 206e 6942 4967 746e 6765 7265 6128     ion BigInteger(a
 80a6221:	622c 632c 7b29 6669 6128 3d21 756e 6c6c     ,b,c){if(a!=null
 80a6231:	6929 2866 6e27 6d75 6562 2772 3d3d 7974     )if('number'==ty
 80a6241:	6570 666f 6120 7429 6968 2e73 7266 6d6f     peof a)this.from
 80a6251:	754e 626d 7265 6128 622c 632c 3b29 6c65     Number(a,b,c);el
 80a6261:	6573 6920 2866 3d62 6e3d 6c75 266c 2726     se if(b==null&&'
 80a6271:	7473 6972 676e 2127 743d 7079 6f65 2066     string'!=typeof 
 80a6281:	2961 6874 7369 662e 6f72 536d 7274 6e69     a)this.fromStrin
 80a6291:	2867 2c61 3532 2936 653b 736c 2065 6874     g(a,256);else th
 80a62a1:	7369 662e 6f72 536d 7274 6e69 2867 2c61     is.fromString(a,
 80a62b1:	2962 7d3b 7566 636e 6974 6e6f 6e20 6962     b);}function nbi
 80a62c1:	2928 727b 7465 7275 206e 656e 2077 6942     (){return new Bi
 80a62d1:	4967 746e 6765 7265 6e28 6c75 296c 7d3b     gInteger(null);}
 80a62e1:	7566 636e 6974 6e6f 6120 316d 6128 622c     function am1(a,b
 80a62f1:	632c 642c 652c 662c 7b29 6877 6c69 2865     ,c,d,e,f){while(
 80a6301:	2d2d 3e66 303d 7b29 6176 2072 3d67 2a62     --f>=0){var g=b*
 80a6311:	6874 7369 615b 2b2b 2b5d 5b63 5d64 652b     this[a++]+c[d]+e
 80a6321:	653b 4d3d 7461 2e68 6c66 6f6f 2872 2f67     ;e=Math.floor(g/
 80a6331:	7830 3034 3030 3030 2930 633b 645b 2b2b     0x4000000);c[d++
 80a6341:	3d5d 2667 7830 6633 6666 6666 3b66 727d     ]=g&0x3ffffff;}r
 80a6351:	7465 7275 206e 3b65 667d 6e75 7463 6f69     eturn e;}functio
 80a6361:	206e 6d61 2832 2c61 2c62 2c63 2c64 2c65     n am2(a,b,c,d,e,
 80a6371:	2966 767b 7261 6720 623d 3026 3778 6666     f){var g=b&0x7ff
 80a6381:	2c66 3d68 3e62 313e 3b35 6877 6c69 2865     f,h=b>>15;while(
 80a6391:	2d2d 3e66 303d 7b29 6176 2072 3d69 6874     --f>=0){var i=th
 80a63a1:	7369 615b 265d 7830 6637 6666 763b 7261     is[a]&0x7fff;var
 80a63b1:	6a20 743d 6968 5b73 2b61 5d2b 3e3e 3531      j=this[a++]>>15
 80a63c1:	763b 7261 6b20 683d 692a 6a2b 672a 693b     ;var k=h*i+j*g;i
 80a63d1:	673d 692a 282b 6b28 3026 3778 6666 2966     =g*i+((k&0x7fff)
 80a63e1:	3c3c 3531 2b29 5b63 5d64 282b 2665 7830     <<15)+c[d]+(e&0x
 80a63f1:	6633 6666 6666 6666 3b29 3d65 6928 3e3e     3fffffff);e=(i>>
 80a6401:	333e 2930 282b 3e6b 3e3e 3531 2b29 2a68     >30)+(k>>>15)+h*
 80a6411:	2b6a 6528 3e3e 333e 2930 633b 645b 2b2b     j+(e>>>30);c[d++
 80a6421:	3d5d 2669 7830 6633 6666 6666 6666 7d3b     ]=i&0x3fffffff;}
 80a6431:	6572 7574 6e72 6520 7d3b 7566 636e 6974     return e;}functi
 80a6441:	6e6f 6120 336d 6128 622c 632c 642c 652c     on am3(a,b,c,d,e
 80a6451:	662c 7b29 6176 2072 3d67 2662 7830 6633     ,f){var g=b&0x3f
 80a6461:	6666 682c 623d 3e3e 3431 773b 6968 656c     ff,h=b>>14;while
 80a6471:	2d28 662d 3d3e 2930 767b 7261 6920 743d     (--f>=0){var i=t
 80a6481:	6968 5b73 5d61 3026 3378 6666 3b66 6176     his[a]&0x3fff;va
 80a6491:	2072 3d6a 6874 7369 615b 2b2b 3e5d 313e     r j=this[a++]>>1
 80a64a1:	3b34 6176 2072 3d6b 2a68 2b69 2a6a 3b67     4;var k=h*i+j*g;
 80a64b1:	3d69 2a67 2b69 2828 266b 7830 6633 6666     i=g*i+((k&0x3fff
 80a64c1:	3c29 313c 2934 632b 645b 2b5d 3b65 3d65     )<<14)+c[d]+e;e=
 80a64d1:	6928 3e3e 3832 2b29 6b28 3e3e 3431 2b29     (i>>28)+(k>>14)+
 80a64e1:	2a68 3b6a 5b63 2b64 5d2b 693d 3026 6678     h*j;c[d++]=i&0xf
 80a64f1:	6666 6666 6666 7d3b 6572 7574 6e72 6520     ffffff;}return e
 80a6501:	7d3b 6669 6a28 6c5f 266d 2826 616e 6976     ;}if(j_lm&&(navi
 80a6511:	6167 6f74 2e72 7061 4e70 6d61 3d65 273d     gator.appName=='
 80a6521:	694d 7263 736f 666f 2074 6e49 6574 6e72     Microsoft Intern
 80a6531:	7465 4520 7078 6f6c 6572 2772 2929 427b     et Explorer')){B
 80a6541:	6769 6e49 6574 6567 2e72 7270 746f 746f     igInteger.protot
 80a6551:	7079 2e65 6d61 613d 326d 643b 6962 7374     ype.am=am2;dbits
 80a6561:	333d 3b30 657d 736c 2065 6669 6a28 6c5f     =30;}else if(j_l
 80a6571:	266d 2826 616e 6976 6167 6f74 2e72 7061     m&&(navigator.ap
 80a6581:	4e70 6d61 2165 273d 654e 7374 6163 6570     pName!='Netscape
 80a6591:	2927 7b29 6942 4967 746e 6765 7265 702e     ')){BigInteger.p
 80a65a1:	6f72 6f74 7974 6570 612e 3d6d 6d61 3b31     rototype.am=am1;
 80a65b1:	6264 7469 3d73 3632 7d3b 6c65 6573 427b     dbits=26;}else{B
 80a65c1:	6769 6e49 6574 6567 2e72 7270 746f 746f     igInteger.protot
 80a65d1:	7079 2e65 6d61 613d 336d 643b 6962 7374     ype.am=am3;dbits
 80a65e1:	323d 3b38 427d 6769 6e49 6574 6567 2e72     =28;}BigInteger.
 80a65f1:	7270 746f 746f 7079 2e65 4244 643d 6962     prototype.DB=dbi
 80a6601:	7374 423b 6769 6e49 6574 6567 2e72 7270     ts;BigInteger.pr
 80a6611:	746f 746f 7079 2e65 4d44 283d 3128 3c3c     ototype.DM=((1<<
 80a6621:	6264 7469 2973 312d 3b29 6942 4967 746e     dbits)-1);BigInt
 80a6631:	6765 7265 702e 6f72 6f74 7974 6570 442e     eger.prototype.D
 80a6641:	3d56 3128 3c3c 6264 7469 2973 763b 7261     V=(1<<dbits);var
 80a6651:	4220 5f49 5046 353d 3b32 6942 4967 746e      BI_FP=52;BigInt
 80a6661:	6765 7265 702e 6f72 6f74 7974 6570 462e     eger.prototype.F
 80a6671:	3d56 614d 6874 702e 776f 3228 422c 5f49     V=Math.pow(2,BI_
 80a6681:	5046 3b29 6942 4967 746e 6765 7265 702e     FP);BigInteger.p
 80a6691:	6f72 6f74 7974 6570 462e 3d31 4942 465f     rototype.F1=BI_F
 80a66a1:	2d50 6264 7469 3b73 6942 4967 746e 6765     P-dbits;BigInteg
 80a66b1:	7265 702e 6f72 6f74 7974 6570 462e 3d32     er.prototype.F2=
 80a66c1:	2a32 6264 7469 2d73 4942 465f 3b50 6176     2*dbits-BI_FP;va
 80a66d1:	2072 4942 525f 3d4d 3027 3231 3433 3635     r BI_RM='0123456
 80a66e1:	3837 6139 6362 6564 6766 6968 6b6a 6d6c     789abcdefghijklm
 80a66f1:	6f6e 7170 7372 7574 7776 7978 277a 763b     nopqrstuvwxyz';v
 80a6701:	7261 4220 5f49 4352 6e3d 7765 4120 7272     ar BI_RC=new Arr
 80a6711:	7961 2928 763b 7261 7220 2c72 7676 723b     ay();var rr,vv;r
 80a6721:	3d72 3027 2e27 6863 7261 6f43 6564 7441     r='0'.charCodeAt
 80a6731:	3028 3b29 6f66 2872 7676 303d 763b 3c76     (0);for(vv=0;vv<
 80a6741:	393d 2b3b 762b 2976 4942 525f 5b43 7272     =9;++vv)BI_RC[rr
 80a6751:	2b2b 3d5d 7676 723b 3d72 6127 2e27 6863     ++]=vv;rr='a'.ch
 80a6761:	7261 6f43 6564 7441 3028 3b29 6f66 2872     arCodeAt(0);for(
 80a6771:	7676 313d 3b30 7676 333c 3b36 2b2b 7676     vv=10;vv<36;++vv
 80a6781:	4229 5f49 4352 725b 2b72 5d2b 763d 3b76     )BI_RC[rr++]=vv;
 80a6791:	7272 273d 2741 632e 6168 4372 646f 4165     rr='A'.charCodeA
 80a67a1:	2874 2930 663b 726f 7628 3d76 3031 763b     t(0);for(vv=10;v
 80a67b1:	3c76 3633 2b3b 762b 2976 4942 525f 5b43     v<36;++vv)BI_RC[
 80a67c1:	7272 2b2b 3d5d 7676 663b 6e75 7463 6f69     rr++]=vv;functio
 80a67d1:	206e 6e69 3274 6863 7261 6128 7b29 6572     n int2char(a){re
 80a67e1:	7574 6e72 4220 5f49 4d52 632e 6168 4172     turn BI_RM.charA
 80a67f1:	2874 2961 7d3b 7566 636e 6974 6e6f 6920     t(a);}function i
 80a6801:	746e 7441 6128 622c 7b29 6176 2072 3d63     ntAt(a,b){var c=
 80a6811:	4942 525f 5b43 2e61 6863 7261 6f43 6564     BI_RC[a.charCode
 80a6821:	7441 6228 5d29 723b 7465 7275 286e 3d63     At(b)];return(c=
 80a6831:	6e3d 6c75 296c 2d3f 3a31 3b63 667d 6e75     =null)?-1:c;}fun
 80a6841:	7463 6f69 206e 6e62 4370 706f 5479 286f     ction bnpCopyTo(
 80a6851:	2961 667b 726f 7628 7261 6220 743d 6968     a){for(var b=thi
 80a6861:	2e73 2d74 3b31 3e62 303d 2d3b 622d 6129     s.t-1;b>=0;--b)a
 80a6871:	625b 3d5d 6874 7369 625b 3b5d 2e61 3d74     [b]=this[b];a.t=
 80a6881:	6874 7369 742e 613b 732e 743d 6968 2e73     this.t;a.s=this.
 80a6891:	3b73 667d 6e75 7463 6f69 206e 6e62 4670     s;}function bnpF
 80a68a1:	6f72 496d 746e 6128 7b29 6874 7369 742e     romInt(a){this.t
 80a68b1:	313d 743b 6968 2e73 3d73 6128 303c 3f29     =1;this.s=(a<0)?
 80a68c1:	312d 303a 693b 2866 3e61 2930 6874 7369     -1:0;if(a>0)this
 80a68d1:	305b 3d5d 3b61 6c65 6573 6920 2866 3c61     [0]=a;else if(a<
 80a68e1:	312d 7429 6968 5b73 5d30 613d 742b 6968     -1)this[0]=a+thi
 80a68f1:	2e73 5644 653b 736c 2065 6874 7369 742e     s.DV;else this.t
 80a6901:	303d 7d3b 7566 636e 6974 6e6f 6e20 7662     =0;}function nbv
 80a6911:	6128 7b29 6176 2072 3d62 626e 2869 3b29     (a){var b=nbi();
 80a6921:	2e62 7266 6d6f 6e49 2874 2961 723b 7465     b.fromInt(a);ret
 80a6931:	7275 206e 3b62 667d 6e75 7463 6f69 206e     urn b;}function 
 80a6941:	6e62 4670 6f72 536d 7274 6e69 2867 2c61     bnpFromString(a,
 80a6951:	2962 767b 7261 6320 693b 2866 3d62 313d     b){var c;if(b==1
 80a6961:	2936 3d63 3b34 6c65 6573 6920 2866 3d62     6)c=4;else if(b=
 80a6971:	383d 6329 333d 653b 736c 2065 6669 6228     =8)c=3;else if(b
 80a6981:	3d3d 3532 2936 3d63 3b38 6c65 6573 6920     ==256)c=8;else i
 80a6991:	2866 3d62 323d 6329 313d 653b 736c 2065     f(b==2)c=1;else 
 80a69a1:	6669 6228 3d3d 3233 6329 353d 653b 736c     if(b==32)c=5;els
 80a69b1:	2065 6669 6228 3d3d 2934 3d63 3b32 6c65     e if(b==4)c=2;el
 80a69c1:	6573 747b 6968 2e73 7266 6d6f 6152 6964     se{this.fromRadi
 80a69d1:	2878 2c61 2962 723b 7465 7275 3b6e 747d     x(a,b);return;}t
 80a69e1:	6968 2e73 3d74 3b30 6874 7369 732e 303d     his.t=0;this.s=0
 80a69f1:	763b 7261 6420 613d 6c2e 6e65 7467 2c68     ;var d=a.length,
 80a6a01:	3d65 6166 736c 2c65 3d66 3b30 6877 6c69     e=false,f=0;whil
 80a6a11:	2865 2d2d 3e64 303d 7b29 6176 2072 3d67     e(--d>=0){var g=
 80a6a21:	6328 3d3d 2938 613f 645b 265d 7830 6666     (c==8)?a[d]&0xff
 80a6a31:	693a 746e 7441 6128 642c 3b29 6669 6728     :intAt(a,d);if(g
 80a6a41:	303c 7b29 6669 6128 632e 6168 4172 2874     <0){if(a.charAt(
 80a6a51:	2964 3d3d 2d27 2927 3d65 7274 6575 633b     d)=='-')e=true;c
 80a6a61:	6e6f 6974 756e 3b65 657d 663d 6c61 6573     ontinue;}e=false
 80a6a71:	693b 2866 3d66 303d 7429 6968 5b73 6874     ;if(f==0)this[th
 80a6a81:	7369 742e 2b2b 3d5d 3b67 6c65 6573 6920     is.t++]=g;else i
 80a6a91:	2866 2b66 3e63 6874 7369 442e 2942 747b     f(f+c>this.DB){t
 80a6aa1:	6968 5b73 6874 7369 742e 312d 7c5d 283d     his[this.t-1]|=(
 80a6ab1:	2667 2828 3c31 283c 6874 7369 442e 2d42     g&((1<<(this.DB-
 80a6ac1:	2966 2d29 2931 3c29 663c 743b 6968 5b73     f))-1))<<f;this[
 80a6ad1:	6874 7369 742e 2b2b 3d5d 6728 3e3e 7428     this.t++]=(g>>(t
 80a6ae1:	6968 2e73 4244 662d 2929 7d3b 6c65 6573     his.DB-f));}else
 80a6af1:	7420 6968 5b73 6874 7369 742e 312d 7c5d      this[this.t-1]|
 80a6b01:	673d 3c3c 3b66 2b66 633d 693b 2866 3e66     =g<<f;f+=c;if(f>
 80a6b11:	743d 6968 2e73 4244 6629 3d2d 6874 7369     =this.DB)f-=this
 80a6b21:	442e 3b42 697d 2866 3d63 383d 2626 6128     .DB;}if(c==8&&(a
 80a6b31:	305b 265d 7830 3038 2129 303d 7b29 6874     [0]&0x80)!=0){th
 80a6b41:	7369 732e 2d3d 3b31 6669 6628 303e 7429     is.s=-1;if(f>0)t
 80a6b51:	6968 5b73 6874 7369 742e 312d 7c5d 283d     his[this.t-1]|=(
 80a6b61:	3128 3c3c 7428 6968 2e73 4244 662d 2929     (1<<(this.DB-f))
 80a6b71:	312d 3c29 663c 7d3b 6874 7369 632e 616c     -1)<<f;}this.cla
 80a6b81:	706d 2928 693b 2866 2965 6942 4967 746e     mp();if(e)BigInt
 80a6b91:	6765 7265 5a2e 5245 2e4f 7573 5462 286f     eger.ZERO.subTo(
 80a6ba1:	6874 7369 742c 6968 2973 7d3b 7566 636e     this,this);}func
 80a6bb1:	6974 6e6f 6220 706e 6c43 6d61 2870 7b29     tion bnpClamp(){
 80a6bc1:	6176 2072 3d61 6874 7369 732e 7426 6968     var a=this.s&thi
 80a6bd1:	2e73 4d44 773b 6968 656c 7428 6968 2e73     s.DM;while(this.
 80a6be1:	3e74 2630 7426 6968 5b73 6874 7369 742e     t>0&&this[this.t
 80a6bf1:	312d 3d5d 613d 2d29 742d 6968 2e73 3b74     -1]==a)--this.t;
 80a6c01:	667d 6e75 7463 6f69 206e 6e62 6f54 7453     }function bnToSt
 80a6c11:	6972 676e 6128 7b29 6669 7428 6968 2e73     ring(a){if(this.
 80a6c21:	3c73 2930 6572 7574 6e72 2720 272d 742b     s<0)return '-'+t
 80a6c31:	6968 2e73 656e 6167 6574 2928 742e 536f     his.negate().toS
 80a6c41:	7274 6e69 2867 2961 763b 7261 6220 693b     tring(a);var b;i
 80a6c51:	2866 3d61 313d 2936 3d62 3b34 6c65 6573     f(a==16)b=4;else
 80a6c61:	6920 2866 3d61 383d 6229 333d 653b 736c      if(a==8)b=3;els
 80a6c71:	2065 6669 6128 3d3d 2932 3d62 3b31 6c65     e if(a==2)b=1;el
 80a6c81:	6573 6920 2866 3d61 333d 2932 3d62 3b35     se if(a==32)b=5;
 80a6c91:	6c65 6573 6920 2866 3d61 343d 6229 323d     else if(a==4)b=2
 80a6ca1:	653b 736c 2065 6572 7574 6e72 7420 6968     ;else return thi
 80a6cb1:	2e73 6f74 6152 6964 2878 2961 763b 7261     s.toRadix(a);var
 80a6cc1:	6320 283d 3c31 623c 2d29 2c31 2c64 3d65      c=(1<<b)-1,d,e=
 80a6cd1:	6166 736c 2c65 3d66 2727 672c 743d 6968     false,f='',g=thi
 80a6ce1:	2e73 3b74 6176 2072 3d68 6874 7369 442e     s.t;var h=this.D
 80a6cf1:	2d42 6728 742a 6968 2e73 4244 2529 3b62     B-(g*this.DB)%b;
 80a6d01:	6669 6728 2d2d 303e 7b29 6669 6828 743c     if(g-->0){if(h<t
 80a6d11:	6968 2e73 4244 2626 6428 743d 6968 5b73     his.DB&&(d=this[
 80a6d21:	5d67 3e3e 2968 303e 7b29 3d65 7274 6575     g]>>h)>0){e=true
 80a6d31:	663b 693d 746e 6332 6168 2872 2964 7d3b     ;f=int2char(d);}
 80a6d41:	6877 6c69 2865 3e67 303d 7b29 6669 6828     while(g>=0){if(h
 80a6d51:	623c 7b29 3d64 7428 6968 5b73 5d67 2826     <b){d=(this[g]&(
 80a6d61:	3128 3c3c 2968 312d 2929 3c3c 6228 682d     (1<<h)-1))<<(b-h
 80a6d71:	3b29 7c64 743d 6968 5b73 2d2d 5d67 3e3e     );d|=this[--g]>>
 80a6d81:	6828 3d2b 6874 7369 442e 2d42 2962 7d3b     (h+=this.DB-b);}
 80a6d91:	6c65 6573 647b 283d 6874 7369 675b 3e5d     else{d=(this[g]>
 80a6da1:	283e 2d68 623d 2929 6326 693b 2866 3c68     >(h-=b))&c;if(h<
 80a6db1:	303d 7b29 2b68 743d 6968 2e73 4244 2d3b     =0){h+=this.DB;-
 80a6dc1:	672d 7d3b 697d 2866 3e64 2930 3d65 7274     -g;}}if(d>0)e=tr
 80a6dd1:	6575 693b 2866 2965 2b66 693d 746e 6332     ue;if(e)f+=int2c
 80a6de1:	6168 2872 2964 7d3b 727d 7465 7275 206e     har(d);}}return 
 80a6df1:	3f65 3a66 3027 3b27 667d 6e75 7463 6f69     e?f:'0';}functio
 80a6e01:	206e 6e62 654e 6167 6574 2928 767b 7261     n bnNegate(){var
 80a6e11:	6120 6e3d 6962 2928 423b 6769 6e49 6574      a=nbi();BigInte
 80a6e21:	6567 2e72 455a 4f52 732e 6275 6f54 7428     ger.ZERO.subTo(t
 80a6e31:	6968 2c73 2961 723b 7465 7275 206e 3b61     his,a);return a;
 80a6e41:	667d 6e75 7463 6f69 206e 6e62 6241 2873     }function bnAbs(
 80a6e51:	7b29 6572 7574 6e72 7428 6968 2e73 3c73     ){return(this.s<
 80a6e61:	2930 743f 6968 2e73 656e 6167 6574 2928     0)?this.negate()
 80a6e71:	743a 6968 3b73 667d 6e75 7463 6f69 206e     :this;}function 
 80a6e81:	6e62 6f43 706d 7261 5465 286f 2961 767b     bnCompareTo(a){v
 80a6e91:	7261 6220 743d 6968 2e73 2d73 2e61 3b73     ar b=this.s-a.s;
 80a6ea1:	6669 6228 3d21 2930 6572 7574 6e72 6220     if(b!=0)return b
 80a6eb1:	763b 7261 6320 743d 6968 2e73 3b74 3d62     ;var c=this.t;b=
 80a6ec1:	2d63 2e61 3b74 6669 6228 3d21 2930 6572     c-a.t;if(b!=0)re
 80a6ed1:	7574 6e72 7428 6968 2e73 3c73 2930 2d3f     turn(this.s<0)?-
 80a6ee1:	3a62 3b62 6877 6c69 2865 2d2d 3e63 303d     b:b;while(--c>=0
 80a6ef1:	6929 2866 6228 743d 6968 5b73 5d63 612d     )if((b=this[c]-a
 80a6f01:	635b 295d 3d21 2930 6572 7574 6e72 6220     [c])!=0)return b
 80a6f11:	723b 7465 7275 206e 3b30 667d 6e75 7463     ;return 0;}funct
 80a6f21:	6f69 206e 626e 7469 2873 2961 767b 7261     ion nbits(a){var
 80a6f31:	6220 313d 632c 693b 2866 6328 613d 3e3e      b=1,c;if((c=a>>
 80a6f41:	313e 2936 3d21 2930 617b 633d 623b 3d2b     >16)!=0){a=c;b+=
 80a6f51:	3631 7d3b 6669 2828 3d63 3e61 383e 2129     16;}if((c=a>>8)!
 80a6f61:	303d 7b29 3d61 3b63 2b62 383d 7d3b 6669     =0){a=c;b+=8;}if
 80a6f71:	2828 3d63 3e61 343e 2129 303d 7b29 3d61     ((c=a>>4)!=0){a=
 80a6f81:	3b63 2b62 343d 7d3b 6669 2828 3d63 3e61     c;b+=4;}if((c=a>
 80a6f91:	323e 2129 303d 7b29 3d61 3b63 2b62 323d     >2)!=0){a=c;b+=2
 80a6fa1:	7d3b 6669 2828 3d63 3e61 313e 2129 303d     ;}if((c=a>>1)!=0
 80a6fb1:	7b29 3d61 3b63 2b62 313d 7d3b 6572 7574     ){a=c;b+=1;}retu
 80a6fc1:	6e72 6220 7d3b 7566 636e 6974 6e6f 6220     rn b;}function b
 80a6fd1:	426e 7469 654c 676e 6874 2928 697b 2866     nBitLength(){if(
 80a6fe1:	6874 7369 742e 3d3c 2930 6572 7574 6e72     this.t<=0)return
 80a6ff1:	3020 723b 7465 7275 206e 6874 7369 442e      0;return this.D
 80a7001:	2a42 7428 6968 2e73 2d74 2931 6e2b 6962     B*(this.t-1)+nbi
 80a7011:	7374 7428 6968 5b73 6874 7369 742e 312d     ts(this[this.t-1
 80a7021:	5e5d 7428 6968 2e73 2673 6874 7369 442e     ]^(this.s&this.D
 80a7031:	294d 3b29 667d 6e75 7463 6f69 206e 6e62     M));}function bn
 80a7041:	4470 534c 6968 7466 6f54 6128 622c 7b29     pDLShiftTo(a,b){
 80a7051:	6176 2072 3b63 6f66 2872 3d63 6874 7369     var c;for(c=this
 80a7061:	742e 312d 633b 3d3e 3b30 2d2d 2963 5b62     .t-1;c>=0;--c)b[
 80a7071:	2b63 5d61 743d 6968 5b73 5d63 663b 726f     c+a]=this[c];for
 80a7081:	6328 613d 312d 633b 3d3e 3b30 2d2d 2963     (c=a-1;c>=0;--c)
 80a7091:	5b62 5d63 303d 623b 742e 743d 6968 2e73     b[c]=0;b.t=this.
 80a70a1:	2b74 3b61 2e62 3d73 6874 7369 732e 7d3b     t+a;b.s=this.s;}
 80a70b1:	7566 636e 6974 6e6f 6220 706e 5244 6853     function bnpDRSh
 80a70c1:	6669 5474 286f 2c61 2962 667b 726f 7628     iftTo(a,b){for(v
 80a70d1:	7261 6320 613d 633b 743c 6968 2e73 3b74     ar c=a;c<this.t;
 80a70e1:	2b2b 2963 5b62 2d63 5d61 743d 6968 5b73     ++c)b[c-a]=this[
 80a70f1:	5d63 623b 742e 4d3d 7461 2e68 616d 2878     c];b.t=Math.max(
 80a7101:	6874 7369 742e 612d 302c 3b29 2e62 3d73     this.t-a,0);b.s=
 80a7111:	6874 7369 732e 7d3b 7566 636e 6974 6e6f     this.s;}function
 80a7121:	6220 706e 534c 6968 7466 6f54 6128 622c      bnpLShiftTo(a,b
 80a7131:	7b29 6176 2072 3d63 2561 6874 7369 442e     ){var c=a%this.D
 80a7141:	3b42 6176 2072 3d64 6874 7369 442e 2d42     B;var d=this.DB-
 80a7151:	3b63 6176 2072 3d65 3128 3c3c 2964 312d     c;var e=(1<<d)-1
 80a7161:	763b 7261 6620 4d3d 7461 2e68 6c66 6f6f     ;var f=Math.floo
 80a7171:	2872 2f61 6874 7369 442e 2942 672c 283d     r(a/this.DB),g=(
 80a7181:	6874 7369 732e 3c3c 2963 7426 6968 2e73     this.s<<c)&this.
 80a7191:	4d44 682c 663b 726f 6828 743d 6968 2e73     DM,h;for(h=this.
 80a71a1:	2d74 3b31 3e68 303d 2d3b 682d 7b29 5b62     t-1;h>=0;--h){b[
 80a71b1:	2b68 2b66 5d31 283d 6874 7369 685b 3e5d     h+f+1]=(this[h]>
 80a71c1:	643e 7c29 3b67 3d67 7428 6968 5b73 5d68     >d)|g;g=(this[h]
 80a71d1:	6526 3c29 633c 7d3b 6f66 2872 3d68 2d66     &e)<<c;}for(h=f-
 80a71e1:	3b31 3e68 303d 2d3b 682d 6229 685b 3d5d     1;h>=0;--h)b[h]=
 80a71f1:	3b30 5b62 5d66 673d 623b 742e 743d 6968     0;b[f]=g;b.t=thi
 80a7201:	2e73 2b74 2b66 3b31 2e62 3d73 6874 7369     s.t+f+1;b.s=this
 80a7211:	732e 623b 632e 616c 706d 2928 7d3b 7600          .s;b.clamp();}.

080a7220 <_ZL6rng_js>:
 80a7220:	6176 2072 6e72 5f67 7473 7461 3b65 6176     var rng_state;va
 80a7230:	2072 6e72 5f67 6f70 6c6f 763b 7261 7220     r rng_pool;var r
 80a7240:	676e 705f 7470 3b72 7566 636e 6974 6e6f     ng_pptr;function
 80a7250:	7220 676e 735f 6565 5f64 6e69 2874 2961      rng_seed_int(a)
 80a7260:	727b 676e 705f 6f6f 5b6c 6e72 5f67 7070     {rng_pool[rng_pp
 80a7270:	7274 2b2b 5e5d 613d 3226 3535 723b 676e     tr++]^=a&255;rng
 80a7280:	705f 6f6f 5b6c 6e72 5f67 7070 7274 2b2b     _pool[rng_pptr++
 80a7290:	5e5d 283d 3e61 383e 2629 3532 3b35 6e72     ]^=(a>>8)&255;rn
 80a72a0:	5f67 6f70 6c6f 725b 676e 705f 7470 2b72     g_pool[rng_pptr+
 80a72b0:	5d2b 3d5e 6128 3e3e 3631 2629 3532 3b35     +]^=(a>>16)&255;
 80a72c0:	6e72 5f67 6f70 6c6f 725b 676e 705f 7470     rng_pool[rng_ppt
 80a72d0:	2b72 5d2b 3d5e 6128 3e3e 3432 2629 3532     r++]^=(a>>24)&25
 80a72e0:	3b35 6669 7228 676e 705f 7470 3e72 723d     5;if(rng_pptr>=r
 80a72f0:	676e 705f 6973 657a 7229 676e 705f 7470     ng_psize)rng_ppt
 80a7300:	2d72 723d 676e 705f 6973 657a 7d3b 7566     r-=rng_psize;}fu
 80a7310:	636e 6974 6e6f 7220 676e 735f 6565 5f64     nction rng_seed_
 80a7320:	6974 656d 2928 727b 676e 735f 6565 5f64     time(){rng_seed_
 80a7330:	6e69 2874 656e 2077 6144 6574 2928 672e     int(new Date().g
 80a7340:	7465 6954 656d 2928 3b29 697d 2866 6e72     etTime());}if(rn
 80a7350:	5f67 6f70 6c6f 3d3d 756e 6c6c 7b29 6e72     g_pool==null){rn
 80a7360:	5f67 6f70 6c6f 6e3d 7765 4120 7272 7961     g_pool=new Array
 80a7370:	2928 723b 676e 705f 7470 3d72 3b30 6176     ();rng_pptr=0;va
 80a7380:	2072 3b74 6669 7728 6e69 6f64 2e77 7263     r t;if(window.cr
 80a7390:	7079 6f74 2626 6977 646e 776f 632e 7972     ypto&&window.cry
 80a73a0:	7470 2e6f 6567 5274 6e61 6f64 566d 6c61     pto.getRandomVal
 80a73b0:	6575 2973 767b 7261 7520 3d61 656e 2077     ues){var ua=new 
 80a73c0:	6955 746e 4138 7272 7961 3328 2932 773b     Uint8Array(32);w
 80a73d0:	6e69 6f64 2e77 7263 7079 6f74 672e 7465     indow.crypto.get
 80a73e0:	6152 646e 6d6f 6156 756c 7365 7528 2961     RandomValues(ua)
 80a73f0:	663b 726f 7428 303d 743b 333c 3b32 2b2b     ;for(t=0;t<32;++
 80a7400:	2974 6e72 5f67 6f70 6c6f 725b 676e 705f     t)rng_pool[rng_p
 80a7410:	7470 2b72 5d2b 753d 5b61 5d74 7d3b 6669     ptr++]=ua[t];}if
 80a7420:	6e28 7661 6769 7461 726f 612e 7070 614e     (navigator.appNa
 80a7430:	656d 3d3d 4e27 7465 6373 7061 2765 2626     me=='Netscape'&&
 80a7440:	616e 6976 6167 6f74 2e72 7061 5670 7265     navigator.appVer
 80a7450:	6973 6e6f 273c 2735 2626 6977 646e 776f     sion<'5'&&window
 80a7460:	632e 7972 7470 296f 767b 7261 7a20 773d     .crypto){var z=w
 80a7470:	6e69 6f64 2e77 7263 7079 6f74 722e 6e61     indow.crypto.ran
 80a7480:	6f64 286d 3233 3b29 6f66 2872 3d74 3b30     dom(32);for(t=0;
 80a7490:	3c74 2e7a 656c 676e 6874 2b3b 742b 7229     t<z.length;++t)r
 80a74a0:	676e 705f 6f6f 5b6c 6e72 5f67 7070 7274     ng_pool[rng_pptr
 80a74b0:	2b2b 3d5d 2e7a 6863 7261 6f43 6564 7441     ++]=z.charCodeAt
 80a74c0:	7428 2629 3532 3b35 777d 6968 656c 7228     (t)&255;}while(r
 80a74d0:	676e 705f 7470 3c72 6e72 5f67 7370 7a69     ng_pptr<rng_psiz
 80a74e0:	2965 747b 4d3d 7461 2e68 6c66 6f6f 2872     e){t=Math.floor(
 80a74f0:	3536 3335 2a36 614d 6874 722e 6e61 6f64     65536*Math.rando
 80a7500:	286d 2929 723b 676e 705f 6f6f 5b6c 6e72     m());rng_pool[rn
 80a7510:	5f67 7070 7274 2b2b 3d5d 3e74 3e3e 3b38     g_pptr++]=t>>>8;
 80a7520:	6e72 5f67 6f70 6c6f 725b 676e 705f 7470     rng_pool[rng_ppt
 80a7530:	2b72 5d2b 743d 3226 3535 7d3b 6e72 5f67     r++]=t&255;}rng_
 80a7540:	7070 7274 303d 723b 676e 735f 6565 5f64     pptr=0;rng_seed_
 80a7550:	6974 656d 2928 7d3b 7566 636e 6974 6e6f     time();}function
 80a7560:	7220 676e 675f 7465 625f 7479 2865 7b29      rng_get_byte(){
 80a7570:	6669 7228 676e 735f 6174 6574 3d3d 756e     if(rng_state==nu
 80a7580:	6c6c 7b29 6e72 5f67 6573 6465 745f 6d69     ll){rng_seed_tim
 80a7590:	2865 3b29 6e72 5f67 7473 7461 3d65 7270     e();rng_state=pr
 80a75a0:	676e 6e5f 7765 7473 7461 2865 3b29 6e72     ng_newstate();rn
 80a75b0:	5f67 7473 7461 2e65 6e69 7469 7228 676e     g_state.init(rng
 80a75c0:	705f 6f6f 296c 663b 726f 7228 676e 705f     _pool);for(rng_p
 80a75d0:	7470 3d72 3b30 6e72 5f67 7070 7274 723c     ptr=0;rng_pptr<r
 80a75e0:	676e 705f 6f6f 2e6c 656c 676e 6874 2b3b     ng_pool.length;+
 80a75f0:	722b 676e 705f 7470 2972 6e72 5f67 6f70     +rng_pptr)rng_po
 80a7600:	6c6f 725b 676e 705f 7470 5d72 303d 723b     ol[rng_pptr]=0;r
 80a7610:	676e 705f 7470 3d72 3b30 727d 7465 7275     ng_pptr=0;}retur
 80a7620:	206e 6e72 5f67 7473 7461 2e65 656e 7478     n rng_state.next
 80a7630:	2928 7d3b 7566 636e 6974 6e6f 7220 676e     ();}function rng
 80a7640:	675f 7465 625f 7479 7365 6128 7b29 6176     _get_bytes(a){va
 80a7650:	2072 3b62 6f66 2872 3d62 3b30 3c62 2e61     r b;for(b=0;b<a.
 80a7660:	656c 676e 6874 2b3b 622b 6129 625b 3d5d     length;++b)a[b]=
 80a7670:	6e72 5f67 6567 5f74 7962 6574 2928 7d3b     rng_get_byte();}
 80a7680:	7566 636e 6974 6e6f 5320 6365 7275 5265     function SecureR
 80a7690:	6e61 6f64 286d 7b29 537d 6365 7275 5265     andom(){}SecureR
 80a76a0:	6e61 6f64 2e6d 7270 746f 746f 7079 2e65     andom.prototype.
 80a76b0:	656e 7478 7942 6574 3d73 6e72 5f67 6567     nextBytes=rng_ge
 80a76c0:	5f74 7962 6574 3b73 5300 4152 3a4d 5b20     t_bytes;.SRAM: [
 80a76d0:	0020 2e5d 0020 4545 5250 4d4f 203a 205b      .]. .EEPROM: [ 
 80a76e0:	4200 7475 6f74 206e 0031 7542 7474 6e6f     .Button 1.Button
 80a76f0:	3220 4200 7475 6f74 206e 0033 6143 2070      2.Button 3.Cap 
 80a7700:	7554 6e72 4300 6c6f 4f20 6666 4400 7369     Turn.Col Off.Dis
 80a7710:	6570 736e 0065 7543 7272 5420 6d69 0065     pense.Curr Time.
 80a7720:	6544 6166 6c75 0074 7b20 2220 616e 656d     Default. { "name
 80a7730:	3a22 0020 2220 2200 202c 2000 7622 6c61     ": . ".", . "val
 80a7740:	6575 3a22 0020 7d20 2c00 2000 005d 6f63     ue": . }.,. ].co
 80a7750:	6e6e 6365 6574 0064 4f50 5453 2f20 7061     nnected.POST /ap
 80a7760:	2f69 6964 7073 6e65 6573 4820 5454 2f50     i/dispense HTTP/
 80a7770:	2e31 0031 6f48 7473 203a 3339 3737 6366     1.1.Host: 9377fc
 80a7780:	3564 6e2e 7267 6b6f 692e 006f 6f43 746e     d5.ngrok.io.Cont
 80a7790:	6e65 2d74 7954 6570 203a 7061 6c70 6369     ent-Type: applic
 80a77a0:	7461 6f69 2f6e 736a 6e6f 4300 6e6f 6574     ation/json.Conte
 80a77b0:	746e 4c2d 6e65 7467 3a68 0020 6f63 6e6e     nt-Length: .conn
 80a77c0:	6365 6974 6e6f 6620 6961 656c 0064 4545     ection failed.EE
 80a77d0:	5250 4d4f 6320 656c 7261 6465 202e 5300     PROM cleared. .S
 80a77e0:	4152 204d 6c63 6165 6572 2e64 0020 5020     RAM cleared. . P
 80a77f0:	6572 7373 6465 202e 2000 6552 656c 7361     ressed. . Releas
 80a7800:	6465 202e 0000 0000                         ed. ....

080a7808 <_ZTV7TwoWire>:
	...
 80a7810:	0cdd 080a 0d27 080a 0cff 080a 0cdf 080a     ....'...........
 80a7820:	0d07 080a 0d0f 080a 0d17 080a 0d1f 080a     ................

080a7830 <_ZTV9IPAddress>:
	...
 80a7838:	0d71 080a 0d61 080a 0d63 080a 6162 6475     q...a...c...baud
 80a7848:	5300 7265 6169 006c 5355 5342 7265 6169     .Serial.USBSeria
 80a7858:	316c 7400 7079 0065 6170 6172 006d 6d63     l1.type.param.cm
 80a7868:	0064 6469 6800 646e 7300 7274 006d 6966     d.id.hnd.strm.fi
 80a7878:	746c 6c00 6c76 6100 6464 6148 646e 656c     lt.lvl.addHandle
 80a7888:	0072 6572 6f6d 6576 6148 646e 656c 0072     r.removeHandler.
 80a7898:	6e65 6d75 6148 646e 656c 7372 4a00 4f53     enumHandlers.JSO
 80a78a8:	534e 7274 6165 4c6d 676f 6148 646e 656c     NStreamLogHandle
 80a78b8:	0072 7061 0070 3025 3031 2075 5d00 0020     r.app.%010u .] .
 80a78c8:	6425 2800 3a29 0020 5b20 6300 646f 2065     %d.(): . [.code 
 80a78d8:	203d 2500 0069 6564 6174 6c69 2073 203d     = .%i.details = 
 80a78e8:	6c00 006e 6e66 6300 646f 0065 6564 6174     .ln.fn.code.deta
 80a78f8:	6c69 6e00 6e6f 0065 7274 6361 0065 6e69     il.none.trace.in
 80a7908:	6f66 7700 7261 006e 7265 6f72 0072 6170     fo.warn.error.pa
 80a7918:	696e 0063 6c61 006c                         nic.all.

080a7920 <_ZTVN5spark12NetworkClassE>:
	...
 80a7928:	0e39 080a 0e43 080a 0e4d 080a 0e57 080a     9...C...M...W...
 80a7938:	0e61 080a 0e6d 080a 0e79 080a 0e85 080a     a...m...y.......
 80a7948:	0e8d 080a 0e97 080a 0ea1 080a               ............

080a7954 <_ZTV8SPIClass>:
	...
 80a795c:	1105 080a 1107 080a                         ........

080a7964 <_ZTVSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE>:
	...
 80a796c:	1355 080a 135b 080a 1773 080a 1369 080a     U...[...s...i...
 80a797c:	1357 080a                                   W...

080a7980 <_ZTV9TCPClient>:
	...
 80a7988:	0191 080a 01c5 080a 1311 080a 132b 080a     ............+...
 80a7998:	1471 080a 13db 080a 13ad 080a 1353 080a     q...........S...
 80a79a8:	151d 080a 178d 080a 140f 080a 14e9 080a     ................
 80a79b8:	166b 080a 16bd 080a 133b 080a 162f 080a     k.......;.../...
 80a79c8:	138d 080a 6977 6972 676e 5400 5043 6c43     ....wiring.TCPCl
 80a79d8:	6569 746e 7320 636f 656b 3d74 7825 5a00     ient socket=%x.Z
 80a79e8:	2500 302b 6433 253a 3230 0075 5925 252d     .%+03d:%02u.%Y-%
 80a79f8:	2d6d 6425 2554 3a48 4d25 253a 2553 007a     m-%dT%H:%M:%S%z.
 80a7a08:	7361 7463 6d69 0065                         asctime.

080a7a10 <_ZTV11USARTSerial>:
	...
 80a7a18:	180d 080a 185d 080a 186b 080a 0f1d 080a     ....]...k.......
 80a7a28:	1821 080a 1843 080a 182f 080a 1857 080a     !...C.../...W...
 80a7a38:	180f 080a 1813 080a                         ........

080a7a40 <_ZTV9USBSerial>:
	...
 80a7a48:	1915 080a 1965 080a 1973 080a 0f1d 080a     ....e...s.......
 80a7a58:	1951 080a 1917 080a 192d 080a 195f 080a     Q.......-..._...
 80a7a68:	1943 080a 1911 080a                         C.......

080a7a70 <_ZTVN5spark9WiFiClassE>:
	...
 80a7a78:	1b4f 080a 1b45 080a 1b3b 080a 1aad 080a     O...E...;.......
 80a7a88:	1b2f 080a 1b23 080a 1b17 080a 1b0f 080a     /...#...........
 80a7a98:	1b05 080a 1afb 080a 1ab7 080a               ............

080a7aa4 <__sf_fake_stdin>:
	...

080a7ac4 <__sf_fake_stdout>:
	...

080a7ae4 <__sf_fake_stderr>:
	...
 80a7b04:	0043                                        C.

080a7b06 <link_const_variable_data_end>:
	...

080a7b08 <link_constructors_location>:
 80a7b08:	080a018d 	.word	0x080a018d
 80a7b0c:	080a0649 	.word	0x080a0649
 80a7b10:	080a080d 	.word	0x080a080d
 80a7b14:	080a0e29 	.word	0x080a0e29
 80a7b18:	080a0f09 	.word	0x080a0f09
 80a7b1c:	080a10e9 	.word	0x080a10e9
 80a7b20:	080a12f9 	.word	0x080a12f9
 80a7b24:	080a17f9 	.word	0x080a17f9
 80a7b28:	080a1b59 	.word	0x080a1b59
 80a7b2c:	080a1ebd 	.word	0x080a1ebd
 80a7b30:	080a1eed 	.word	0x080a1eed
 80a7b34:	080a1f41 	.word	0x080a1f41
 80a7b38:	080a2005 	.word	0x080a2005
 80a7b3c:	080a2089 	.word	0x080a2089
 80a7b40:	080a210d 	.word	0x080a210d

080a7b44 <link_constructors_end>:
	...
